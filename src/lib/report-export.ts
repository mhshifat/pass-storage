import { ReportData } from "./report-generator"
import ExcelJS from "exceljs"

/**
 * Helper function to ensure a value is a Date object
 */
function ensureDate(value: Date | string | number | unknown): Date {
  if (value instanceof Date) {
    return value
  }
  if (typeof value === "string") {
    const date = new Date(value)
    if (isNaN(date.getTime())) {
      throw new Error(`Invalid date string: ${value}`)
    }
    return date
  }
  if (typeof value === "number") {
    return new Date(value)
  }
  throw new Error(`Cannot convert value to Date: ${value}`)
}

/**
 * Helper function to format field names into human-readable labels
 */
function formatFieldName(fieldName: string): string {
  // Handle common abbreviations and special cases
  const specialCases: Record<string, string> = {
    id: "ID",
    ipAddress: "IP Address",
    ip: "IP",
    url: "URL",
    api: "API",
    mfa: "MFA",
    totp: "TOTP",
    sms: "SMS",
    email: "Email",
    userId: "User ID",
    companyId: "Company ID",
    resourceId: "Resource ID",
    templateId: "Template ID",
    folderId: "Folder ID",
    passwordId: "Password ID",
    teamId: "Team ID",
    roleId: "Role ID",
    permissionId: "Permission ID",
    createdAt: "Created At",
    updatedAt: "Updated At",
    generatedAt: "Generated At",
    expiresAt: "Expires At",
    lastLoginAt: "Last Login At",
    userEmail: "User Email",
    userAgent: "User Agent",
    dateRange: "Date Range",
    totalRecords: "Total Records",
  }

  // Check if we have a special case
  if (specialCases[fieldName]) {
    return specialCases[fieldName]
  }

  // Convert camelCase or snake_case to Title Case
  return fieldName
    .replace(/([A-Z])/g, " $1") // Add space before capital letters
    .replace(/_/g, " ") // Replace underscores with spaces
    .replace(/\b\w/g, (char) => char.toUpperCase()) // Capitalize first letter of each word
    .trim()
}

/**
 * Export report to CSV format
 */
export function exportReportToCSV(reportData: ReportData): string {
  const rows: string[] = []

  // Add metadata header
  rows.push("Report Metadata")
  rows.push(`Report Name,${escapeCSVField(reportData.metadata.reportName)}`)
  rows.push(`Generated At,${escapeCSVField(ensureDate(reportData.metadata.generatedAt).toISOString())}`)
  rows.push(`Generated By,${escapeCSVField(reportData.metadata.generatedBy)}`)
  if (reportData.metadata.dateRange) {
    const startDate = ensureDate(reportData.metadata.dateRange.start)
    const endDate = ensureDate(reportData.metadata.dateRange.end)
    rows.push(
      `Date Range,${escapeCSVField(startDate.toISOString())} - ${escapeCSVField(endDate.toISOString())}`
    )
  }
  rows.push("")

  // Add summary if available
  if (reportData.summary) {
    rows.push("Summary")
    for (const [key, value] of Object.entries(reportData.summary)) {
      let displayValue: string
      if (key === "dateRange" && value && typeof value === "object" && "start" in value && "end" in value) {
        // Format dateRange object properly
        const dateRange = value as { start: Date | string; end: Date | string }
        const startDate = ensureDate(dateRange.start).toISOString()
        const endDate = ensureDate(dateRange.end).toISOString()
        displayValue = `${startDate} - ${endDate}`
      } else if (value instanceof Date) {
        displayValue = value.toISOString()
      } else if (value && typeof value === "object") {
        displayValue = JSON.stringify(value)
      } else {
        displayValue = String(value)
      }
      rows.push(`${formatFieldName(key)},${escapeCSVField(displayValue)}`)
    }
    rows.push("")
  }

  // Add data headers
  if (reportData.data.length > 0) {
    const firstRow = reportData.data[0] as Record<string, unknown>
    const headers = Object.keys(firstRow)
    rows.push(headers.map(header => escapeCSVField(formatFieldName(header))).join(","))

    // Add data rows
    for (const row of reportData.data) {
      const rowData = row as Record<string, unknown>
      const values = headers.map((header) => {
        const value = rowData[header]
        if (value === null || value === undefined) {
          return ""
        }
        if (value instanceof Date) {
          return escapeCSVField(value.toISOString())
        }
        if (typeof value === "object") {
          return escapeCSVField(JSON.stringify(value))
        }
        return escapeCSVField(String(value))
      })
      rows.push(values.join(","))
    }
  }

  return rows.join("\n")
}

/**
 * Export report to JSON format
 */
export function exportReportToJSON(reportData: ReportData, pretty: boolean = false): string {
  if (pretty) {
    return JSON.stringify(reportData, null, 2)
  }
  return JSON.stringify(reportData)
}

/**
 * Export report to PDF format
 * Note: For Next.js, we use dynamic import to avoid bundling issues
 */
export async function exportReportToPDF(reportData: ReportData): Promise<Buffer> {
  // Use dynamic import to avoid font loading issues in Next.js
  const PDFDocument = (await import("pdfkit")).default

  return new Promise((resolve, reject) => {
    try {
      // Create PDF document - wrap in try-catch to handle font loading errors
      // pdfkit may throw errors if font files are not accessible in Next.js/serverless environments
      let doc: InstanceType<typeof PDFDocument>
      try {
        doc = new PDFDocument({ 
          margin: 50,
          size: "LETTER"
        })
      } catch (fontError: unknown) {
        // If font loading fails during document creation, provide helpful error
        const error = fontError as Error
        if (error.message && (error.message.includes("ENOENT") || error.message.includes(".afm"))) {
          reject(new Error(
            "PDF generation failed: Font files not found. " +
            "This is a known issue with pdfkit in Next.js/serverless environments. " +
            "Please use a different export format (CSV, Excel, JSON) or ensure pdfkit font files are available in node_modules/pdfkit/js/data/"
          ))
          return
        }
        throw fontError
      }

      const chunks: Buffer[] = []

      doc.on("data", (chunk: Buffer) => chunks.push(chunk))
      doc.on("end", () => {
        resolve(Buffer.concat(chunks))
      })
      doc.on("error", (error: Error) => {
        console.error("PDF generation error:", error)
        reject(error)
      })

      // Add title - pdfkit will attempt to use Helvetica, fallback to default if not available
      doc.fontSize(20).text(reportData.metadata.reportName, { align: "center" })
      doc.moveDown()

      // Add metadata
      doc.fontSize(12)
      doc.text(`Generated At: ${ensureDate(reportData.metadata.generatedAt).toLocaleString()}`)
      doc.text(`Generated By: ${reportData.metadata.generatedBy}`)
      if (reportData.metadata.dateRange) {
        const startDate = ensureDate(reportData.metadata.dateRange.start)
        const endDate = ensureDate(reportData.metadata.dateRange.end)
        doc.text(
          `Date Range: ${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}`
        )
      }
      doc.moveDown()

      // Add summary if available
      if (reportData.summary) {
        doc.fontSize(14).text("Summary", { underline: true })
        doc.moveDown(0.5)
        doc.fontSize(10)
        for (const [key, value] of Object.entries(reportData.summary)) {
          if (key !== "totalRecords" || reportData.data.length > 0) {
            let displayValue: string
            if (key === "dateRange" && value && typeof value === "object" && "start" in value && "end" in value) {
              // Format dateRange object properly
              const dateRange = value as { start: Date | string; end: Date | string }
              const startDate = ensureDate(dateRange.start).toLocaleDateString()
              const endDate = ensureDate(dateRange.end).toLocaleDateString()
              displayValue = `${startDate} - ${endDate}`
            } else if (value instanceof Date) {
              displayValue = value.toLocaleString()
            } else if (value && typeof value === "object") {
              displayValue = JSON.stringify(value)
            } else {
              displayValue = String(value)
            }
            doc.text(`${formatFieldName(key)}: ${displayValue}`)
          }
        }
        doc.moveDown()
      }

      // Add data table
      if (reportData.data.length > 0) {
        doc.fontSize(14).text("Data", { underline: true })
        doc.moveDown(0.5)
        doc.fontSize(10)

        const firstRow = reportData.data[0] as Record<string, unknown>
        const headers = Object.keys(firstRow)

        // Calculate column widths based on content
        const pageWidth = doc.page.width - 100 // Account for margins (50 on each side)
        const numColumns = headers.length
        
        // Adjust font size and column widths based on number of columns
        // More columns = smaller font and smaller min width
        let tableFontSize = 10
        let minColumnWidth = 80
        let maxColumnWidth = 150
        const columnSpacing = 3
        
        if (numColumns > 8) {
          tableFontSize = 8
          minColumnWidth = 50
          maxColumnWidth = 100
        } else if (numColumns > 6) {
          tableFontSize = 9
          minColumnWidth = 60
          maxColumnWidth = 120
        }
        
        doc.fontSize(tableFontSize)
        
        // Calculate optimal column widths
        const columnWidths: number[] = []
        const totalAvailableWidth = pageWidth - (columnSpacing * (numColumns - 1))
        
        headers.forEach((header) => {
          // Calculate width based on header length and sample data
          let maxContentLength = header.length
          const sampleRows = reportData.data.slice(0, 10) // Sample first 10 rows
          sampleRows.forEach((row) => {
            const value = (row as Record<string, unknown>)[header]
            let displayValue = ""
            if (value === null || value === undefined) {
              displayValue = ""
            } else if (value instanceof Date) {
              displayValue = value.toLocaleString()
            } else if (typeof value === "object") {
              displayValue = JSON.stringify(value).substring(0, 50)
            } else {
              displayValue = String(value)
            }
            maxContentLength = Math.max(maxContentLength, displayValue.length)
          })
          // Calculate width: adjust pixels per character based on font size
          const pixelsPerChar = tableFontSize === 8 ? 4.5 : tableFontSize === 9 ? 5.5 : 6
          const calculatedWidth = Math.max(minColumnWidth, Math.min(maxColumnWidth, maxContentLength * pixelsPerChar))
          columnWidths.push(calculatedWidth)
        })

        // Normalize widths to fit page - ensure we don't exceed page width
        let totalCalculatedWidth = columnWidths.reduce((sum, w) => sum + w, 0) + (columnSpacing * (numColumns - 1))
        if (totalCalculatedWidth > totalAvailableWidth) {
          const scaleFactor = totalAvailableWidth / totalCalculatedWidth
          columnWidths.forEach((width, index) => {
            columnWidths[index] = Math.max(minColumnWidth * 0.7, width * scaleFactor) // Allow smaller min width when scaling
          })
          // Recalculate to ensure we fit
          totalCalculatedWidth = columnWidths.reduce((sum, w) => sum + w, 0) + (columnSpacing * (numColumns - 1))
          if (totalCalculatedWidth > totalAvailableWidth) {
            // Last resort: equal width distribution
            const equalWidth = (totalAvailableWidth - (columnSpacing * (numColumns - 1))) / numColumns
            columnWidths.forEach((_, index) => {
              columnWidths[index] = Math.max(minColumnWidth * 0.5, equalWidth)
            })
          }
        }

        // Calculate starting X positions for each column
        const columnPositions: number[] = []
        let currentX = 50 // Left margin
        columnWidths.forEach((width) => {
          columnPositions.push(currentX)
          currentX += width + columnSpacing
        })

        // Table header
        let yPosition = doc.y
        doc.fontSize(tableFontSize)
        doc.font("Helvetica-Bold")
        let maxHeaderHeight = 0
        headers.forEach((header, index) => {
          const formattedHeader = formatFieldName(header)
          const height = doc.heightOfString(formattedHeader, { width: columnWidths[index] })
          doc.text(formattedHeader, columnPositions[index], yPosition, { 
            width: columnWidths[index],
            align: "left"
          })
          maxHeaderHeight = Math.max(maxHeaderHeight, height)
        })
        yPosition += maxHeaderHeight + 5

        // Draw header underline
        doc.moveTo(50, yPosition - 2)
          .lineTo(pageWidth + 50, yPosition - 2)
          .stroke()
        
        yPosition += 5

        // Table rows (limit to first 100 rows for PDF)
        doc.font("Helvetica") // Reset to regular font
        doc.fontSize(tableFontSize)
        const rowsToShow = reportData.data.slice(0, 100)
        rowsToShow.forEach((row) => {
          const rowData = row as Record<string, unknown>
          let maxRowHeight = 0
          
          // First pass: calculate the height needed for this row
          headers.forEach((header, index) => {
            const value = rowData[header]
            let displayValue = ""
            if (value === null || value === undefined) {
              displayValue = ""
            } else if (value instanceof Date) {
              displayValue = value.toLocaleString()
            } else if (typeof value === "object") {
              // Truncate JSON objects more aggressively for tables with many columns
              const maxLength = numColumns > 8 ? 30 : numColumns > 6 ? 50 : 100
              displayValue = JSON.stringify(value).substring(0, maxLength)
            } else {
              // Truncate long strings to prevent overflow
              const maxLength = numColumns > 8 ? 40 : numColumns > 6 ? 60 : 200
              const strValue = String(value)
              displayValue = strValue.length > maxLength ? strValue.substring(0, maxLength - 3) + "..." : strValue
            }
            const height = doc.heightOfString(displayValue, { width: columnWidths[index] })
            maxRowHeight = Math.max(maxRowHeight, height)
          })

          // Check if we need a new page
          if (yPosition + maxRowHeight > doc.page.height - 50) {
            doc.addPage()
            yPosition = 50
          }

          // Second pass: render the cells
          headers.forEach((header, index) => {
            const value = rowData[header]
            let displayValue = ""
            if (value === null || value === undefined) {
              displayValue = ""
            } else if (value instanceof Date) {
              displayValue = value.toLocaleString()
            } else if (typeof value === "object") {
              // Truncate JSON objects more aggressively for tables with many columns
              const maxLength = numColumns > 8 ? 30 : numColumns > 6 ? 50 : 100
              displayValue = JSON.stringify(value).substring(0, maxLength)
            } else {
              // Truncate long strings to prevent overflow
              const maxLength = numColumns > 8 ? 40 : numColumns > 6 ? 60 : 200
              const strValue = String(value)
              displayValue = strValue.length > maxLength ? strValue.substring(0, maxLength - 3) + "..." : strValue
            }
            
            // Ensure we don't render outside page bounds
            if (columnPositions[index] + columnWidths[index] <= pageWidth + 50) {
              doc.text(displayValue, columnPositions[index], yPosition, { 
                width: columnWidths[index],
                align: "left"
              })
            }
          })
          
          yPosition += maxRowHeight + 3 // Add spacing between rows
        })

        if (reportData.data.length > 100) {
          doc.moveDown()
          doc.text(`... and ${reportData.data.length - 100} more rows`)
        }
      }

      doc.end()
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Export report to Excel format
 */
export async function exportReportToExcel(reportData: ReportData): Promise<Buffer> {
  const workbook = new ExcelJS.Workbook()
  const worksheet = workbook.addWorksheet("Report")

  // Add metadata
  worksheet.addRow(["Report Metadata"])
  worksheet.addRow(["Report Name", reportData.metadata.reportName])
  worksheet.addRow(["Generated At", ensureDate(reportData.metadata.generatedAt).toISOString()])
  worksheet.addRow(["Generated By", reportData.metadata.generatedBy])
  if (reportData.metadata.dateRange) {
    const startDate = ensureDate(reportData.metadata.dateRange.start)
    const endDate = ensureDate(reportData.metadata.dateRange.end)
    worksheet.addRow([
      "Date Range",
      `${startDate.toISOString()} - ${endDate.toISOString()}`,
    ])
  }
  worksheet.addRow([])

  // Add summary if available
  if (reportData.summary) {
    worksheet.addRow(["Summary"])
    for (const [key, value] of Object.entries(reportData.summary)) {
      let displayValue: string | Date
      if (key === "dateRange" && value && typeof value === "object" && "start" in value && "end" in value) {
        // Format dateRange object properly
        const dateRange = value as { start: Date | string; end: Date | string }
        const startDate = ensureDate(dateRange.start)
        const endDate = ensureDate(dateRange.end)
        displayValue = `${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}`
      } else if (value instanceof Date) {
        displayValue = value
      } else if (value && typeof value === "object") {
        displayValue = JSON.stringify(value)
      } else {
        displayValue = String(value)
      }
      worksheet.addRow([formatFieldName(key), displayValue])
    }
    worksheet.addRow([])
  }

  // Add data table
  if (reportData.data.length > 0) {
    const firstRow = reportData.data[0] as Record<string, unknown>
    const headers = Object.keys(firstRow)

    // Add headers
    const formattedHeaders = headers.map(header => formatFieldName(header))
    const headerRow = worksheet.addRow(formattedHeaders)
    headerRow.font = { bold: true }
    headerRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "FFE0E0E0" },
    }

    // Add data rows
    for (const row of reportData.data) {
      const rowData = row as Record<string, unknown>
      const values = headers.map((header) => {
        const value = rowData[header]
        if (value === null || value === undefined) {
          return ""
        }
        if (value instanceof Date) {
          return value
        }
        if (typeof value === "object") {
          return JSON.stringify(value)
        }
        return String(value)
      })
      worksheet.addRow(values)
    }

    // Auto-fit columns
    worksheet.columns.forEach((column) => {
      if (column.header) {
        column.width = Math.max(15, Math.min(50, String(column.header).length + 2))
      }
    })
  }

  // Generate buffer
  const buffer = await workbook.xlsx.writeBuffer()
  return Buffer.from(buffer)
}

/**
 * Helper function to escape CSV fields
 */
function escapeCSVField(field: string): string {
  if (!field) return ""
  // If field contains comma, quote, or newline, wrap in quotes and escape quotes
  if (field.includes(",") || field.includes('"') || field.includes("\n")) {
    return `"${field.replace(/"/g, '""')}"`
  }
  return field
}




