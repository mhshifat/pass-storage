
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Password
 * 
 */
export type Password = $Result.DefaultSelection<Prisma.$PasswordPayload>
/**
 * Model PasswordHistory
 * 
 */
export type PasswordHistory = $Result.DefaultSelection<Prisma.$PasswordHistoryPayload>
/**
 * Model PasswordBreach
 * 
 */
export type PasswordBreach = $Result.DefaultSelection<Prisma.$PasswordBreachPayload>
/**
 * Model PasswordRotationPolicy
 * 
 */
export type PasswordRotationPolicy = $Result.DefaultSelection<Prisma.$PasswordRotationPolicyPayload>
/**
 * Model PasswordRotation
 * 
 */
export type PasswordRotation = $Result.DefaultSelection<Prisma.$PasswordRotationPayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model PasswordShare
 * 
 */
export type PasswordShare = $Result.DefaultSelection<Prisma.$PasswordSharePayload>
/**
 * Model TemporaryPasswordShare
 * 
 */
export type TemporaryPasswordShare = $Result.DefaultSelection<Prisma.$TemporaryPasswordSharePayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model PasswordTag
 * 
 */
export type PasswordTag = $Result.DefaultSelection<Prisma.$PasswordTagPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AuditLogArchive
 * 
 */
export type AuditLogArchive = $Result.DefaultSelection<Prisma.$AuditLogArchivePayload>
/**
 * Model AuditLogSearch
 * 
 */
export type AuditLogSearch = $Result.DefaultSelection<Prisma.$AuditLogSearchPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model ThreatEvent
 * 
 */
export type ThreatEvent = $Result.DefaultSelection<Prisma.$ThreatEventPayload>
/**
 * Model RateLimit
 * 
 */
export type RateLimit = $Result.DefaultSelection<Prisma.$RateLimitPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model MfaCredential
 * 
 */
export type MfaCredential = $Result.DefaultSelection<Prisma.$MfaCredentialPayload>
/**
 * Model RecoveryCode
 * 
 */
export type RecoveryCode = $Result.DefaultSelection<Prisma.$RecoveryCodePayload>
/**
 * Model SavedSearch
 * 
 */
export type SavedSearch = $Result.DefaultSelection<Prisma.$SavedSearchPayload>
/**
 * Model SearchHistory
 * 
 */
export type SearchHistory = $Result.DefaultSelection<Prisma.$SearchHistoryPayload>
/**
 * Model PasswordTemplate
 * 
 */
export type PasswordTemplate = $Result.DefaultSelection<Prisma.$PasswordTemplatePayload>
/**
 * Model EmailVerificationToken
 * 
 */
export type EmailVerificationToken = $Result.DefaultSelection<Prisma.$EmailVerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model SecurityQuestion
 * 
 */
export type SecurityQuestion = $Result.DefaultSelection<Prisma.$SecurityQuestionPayload>
/**
 * Model IpWhitelist
 * 
 */
export type IpWhitelist = $Result.DefaultSelection<Prisma.$IpWhitelistPayload>
/**
 * Model GeographicRestriction
 * 
 */
export type GeographicRestriction = $Result.DefaultSelection<Prisma.$GeographicRestrictionPayload>
/**
 * Model PasswordPolicy
 * 
 */
export type PasswordPolicy = $Result.DefaultSelection<Prisma.$PasswordPolicyPayload>
/**
 * Model DataRetentionPolicy
 * 
 */
export type DataRetentionPolicy = $Result.DefaultSelection<Prisma.$DataRetentionPolicyPayload>
/**
 * Model DataExport
 * 
 */
export type DataExport = $Result.DefaultSelection<Prisma.$DataExportPayload>
/**
 * Model DataDeletionRequest
 * 
 */
export type DataDeletionRequest = $Result.DefaultSelection<Prisma.$DataDeletionRequestPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model ReportTemplate
 * 
 */
export type ReportTemplate = $Result.DefaultSelection<Prisma.$ReportTemplatePayload>
/**
 * Model ScheduledReport
 * 
 */
export type ScheduledReport = $Result.DefaultSelection<Prisma.$ScheduledReportPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ThreatType: {
  BRUTE_FORCE: 'BRUTE_FORCE',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  UNUSUAL_ACCESS_PATTERN: 'UNUSUAL_ACCESS_PATTERN',
  SUSPICIOUS_LOCATION: 'SUSPICIOUS_LOCATION',
  MULTIPLE_FAILED_LOGINS: 'MULTIPLE_FAILED_LOGINS',
  ANOMALY_DETECTED: 'ANOMALY_DETECTED'
};

export type ThreatType = (typeof ThreatType)[keyof typeof ThreatType]


export const ThreatSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type ThreatSeverity = (typeof ThreatSeverity)[keyof typeof ThreatSeverity]


export const RateLimitType: {
  IP: 'IP',
  USER: 'USER'
};

export type RateLimitType = (typeof RateLimitType)[keyof typeof RateLimitType]


export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  USER: 'USER',
  AUDITOR: 'AUDITOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TeamRole: {
  MANAGER: 'MANAGER',
  MEMBER: 'MEMBER'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const SharePermission: {
  READ: 'READ',
  WRITE: 'WRITE',
  ADMIN: 'ADMIN'
};

export type SharePermission = (typeof SharePermission)[keyof typeof SharePermission]


export const PasswordStrength: {
  WEAK: 'WEAK',
  MEDIUM: 'MEDIUM',
  STRONG: 'STRONG'
};

export type PasswordStrength = (typeof PasswordStrength)[keyof typeof PasswordStrength]


export const AuditStatus: {
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  WARNING: 'WARNING',
  BLOCKED: 'BLOCKED'
};

export type AuditStatus = (typeof AuditStatus)[keyof typeof AuditStatus]


export const MfaMethod: {
  TOTP: 'TOTP',
  SMS: 'SMS',
  EMAIL: 'EMAIL',
  WEBAUTHN: 'WEBAUTHN'
};

export type MfaMethod = (typeof MfaMethod)[keyof typeof MfaMethod]

}

export type ThreatType = $Enums.ThreatType

export const ThreatType: typeof $Enums.ThreatType

export type ThreatSeverity = $Enums.ThreatSeverity

export const ThreatSeverity: typeof $Enums.ThreatSeverity

export type RateLimitType = $Enums.RateLimitType

export const RateLimitType: typeof $Enums.RateLimitType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type SharePermission = $Enums.SharePermission

export const SharePermission: typeof $Enums.SharePermission

export type PasswordStrength = $Enums.PasswordStrength

export const PasswordStrength: typeof $Enums.PasswordStrength

export type AuditStatus = $Enums.AuditStatus

export const AuditStatus: typeof $Enums.AuditStatus

export type MfaMethod = $Enums.MfaMethod

export const MfaMethod: typeof $Enums.MfaMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password`: Exposes CRUD operations for the **Password** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passwords
    * const passwords = await prisma.password.findMany()
    * ```
    */
  get password(): Prisma.PasswordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordHistory`: Exposes CRUD operations for the **PasswordHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordHistories
    * const passwordHistories = await prisma.passwordHistory.findMany()
    * ```
    */
  get passwordHistory(): Prisma.PasswordHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordBreach`: Exposes CRUD operations for the **PasswordBreach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordBreaches
    * const passwordBreaches = await prisma.passwordBreach.findMany()
    * ```
    */
  get passwordBreach(): Prisma.PasswordBreachDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordRotationPolicy`: Exposes CRUD operations for the **PasswordRotationPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordRotationPolicies
    * const passwordRotationPolicies = await prisma.passwordRotationPolicy.findMany()
    * ```
    */
  get passwordRotationPolicy(): Prisma.PasswordRotationPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordRotation`: Exposes CRUD operations for the **PasswordRotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordRotations
    * const passwordRotations = await prisma.passwordRotation.findMany()
    * ```
    */
  get passwordRotation(): Prisma.PasswordRotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordShare`: Exposes CRUD operations for the **PasswordShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordShares
    * const passwordShares = await prisma.passwordShare.findMany()
    * ```
    */
  get passwordShare(): Prisma.PasswordShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.temporaryPasswordShare`: Exposes CRUD operations for the **TemporaryPasswordShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemporaryPasswordShares
    * const temporaryPasswordShares = await prisma.temporaryPasswordShare.findMany()
    * ```
    */
  get temporaryPasswordShare(): Prisma.TemporaryPasswordShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordTag`: Exposes CRUD operations for the **PasswordTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordTags
    * const passwordTags = await prisma.passwordTag.findMany()
    * ```
    */
  get passwordTag(): Prisma.PasswordTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLogArchive`: Exposes CRUD operations for the **AuditLogArchive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogArchives
    * const auditLogArchives = await prisma.auditLogArchive.findMany()
    * ```
    */
  get auditLogArchive(): Prisma.AuditLogArchiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLogSearch`: Exposes CRUD operations for the **AuditLogSearch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogSearches
    * const auditLogSearches = await prisma.auditLogSearch.findMany()
    * ```
    */
  get auditLogSearch(): Prisma.AuditLogSearchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threatEvent`: Exposes CRUD operations for the **ThreatEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreatEvents
    * const threatEvents = await prisma.threatEvent.findMany()
    * ```
    */
  get threatEvent(): Prisma.ThreatEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rateLimit`: Exposes CRUD operations for the **RateLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateLimits
    * const rateLimits = await prisma.rateLimit.findMany()
    * ```
    */
  get rateLimit(): Prisma.RateLimitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mfaCredential`: Exposes CRUD operations for the **MfaCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MfaCredentials
    * const mfaCredentials = await prisma.mfaCredential.findMany()
    * ```
    */
  get mfaCredential(): Prisma.MfaCredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recoveryCode`: Exposes CRUD operations for the **RecoveryCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryCodes
    * const recoveryCodes = await prisma.recoveryCode.findMany()
    * ```
    */
  get recoveryCode(): Prisma.RecoveryCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedSearch`: Exposes CRUD operations for the **SavedSearch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedSearches
    * const savedSearches = await prisma.savedSearch.findMany()
    * ```
    */
  get savedSearch(): Prisma.SavedSearchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchHistory`: Exposes CRUD operations for the **SearchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchHistories
    * const searchHistories = await prisma.searchHistory.findMany()
    * ```
    */
  get searchHistory(): Prisma.SearchHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordTemplate`: Exposes CRUD operations for the **PasswordTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordTemplates
    * const passwordTemplates = await prisma.passwordTemplate.findMany()
    * ```
    */
  get passwordTemplate(): Prisma.PasswordTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerificationToken`: Exposes CRUD operations for the **EmailVerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerificationTokens
    * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
    * ```
    */
  get emailVerificationToken(): Prisma.EmailVerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityQuestion`: Exposes CRUD operations for the **SecurityQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityQuestions
    * const securityQuestions = await prisma.securityQuestion.findMany()
    * ```
    */
  get securityQuestion(): Prisma.SecurityQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ipWhitelist`: Exposes CRUD operations for the **IpWhitelist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IpWhitelists
    * const ipWhitelists = await prisma.ipWhitelist.findMany()
    * ```
    */
  get ipWhitelist(): Prisma.IpWhitelistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.geographicRestriction`: Exposes CRUD operations for the **GeographicRestriction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeographicRestrictions
    * const geographicRestrictions = await prisma.geographicRestriction.findMany()
    * ```
    */
  get geographicRestriction(): Prisma.GeographicRestrictionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordPolicy`: Exposes CRUD operations for the **PasswordPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordPolicies
    * const passwordPolicies = await prisma.passwordPolicy.findMany()
    * ```
    */
  get passwordPolicy(): Prisma.PasswordPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataRetentionPolicy`: Exposes CRUD operations for the **DataRetentionPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRetentionPolicies
    * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany()
    * ```
    */
  get dataRetentionPolicy(): Prisma.DataRetentionPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataExport`: Exposes CRUD operations for the **DataExport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataExports
    * const dataExports = await prisma.dataExport.findMany()
    * ```
    */
  get dataExport(): Prisma.DataExportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataDeletionRequest`: Exposes CRUD operations for the **DataDeletionRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataDeletionRequests
    * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
    * ```
    */
  get dataDeletionRequest(): Prisma.DataDeletionRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportTemplate`: Exposes CRUD operations for the **ReportTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportTemplates
    * const reportTemplates = await prisma.reportTemplate.findMany()
    * ```
    */
  get reportTemplate(): Prisma.ReportTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledReport`: Exposes CRUD operations for the **ScheduledReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledReports
    * const scheduledReports = await prisma.scheduledReport.findMany()
    * ```
    */
  get scheduledReport(): Prisma.ScheduledReportDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.1
   * Query Engine version: f09f2815f091dbba658cdcd2264306d88bb5bda6
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Password: 'Password',
    PasswordHistory: 'PasswordHistory',
    PasswordBreach: 'PasswordBreach',
    PasswordRotationPolicy: 'PasswordRotationPolicy',
    PasswordRotation: 'PasswordRotation',
    Folder: 'Folder',
    PasswordShare: 'PasswordShare',
    TemporaryPasswordShare: 'TemporaryPasswordShare',
    Team: 'Team',
    TeamMember: 'TeamMember',
    Tag: 'Tag',
    PasswordTag: 'PasswordTag',
    AuditLog: 'AuditLog',
    AuditLogArchive: 'AuditLogArchive',
    AuditLogSearch: 'AuditLogSearch',
    Settings: 'Settings',
    ThreatEvent: 'ThreatEvent',
    RateLimit: 'RateLimit',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    MfaCredential: 'MfaCredential',
    RecoveryCode: 'RecoveryCode',
    SavedSearch: 'SavedSearch',
    SearchHistory: 'SearchHistory',
    PasswordTemplate: 'PasswordTemplate',
    EmailVerificationToken: 'EmailVerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    SecurityQuestion: 'SecurityQuestion',
    IpWhitelist: 'IpWhitelist',
    GeographicRestriction: 'GeographicRestriction',
    PasswordPolicy: 'PasswordPolicy',
    DataRetentionPolicy: 'DataRetentionPolicy',
    DataExport: 'DataExport',
    DataDeletionRequest: 'DataDeletionRequest',
    Report: 'Report',
    ReportTemplate: 'ReportTemplate',
    ScheduledReport: 'ScheduledReport'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "user" | "account" | "session" | "password" | "passwordHistory" | "passwordBreach" | "passwordRotationPolicy" | "passwordRotation" | "folder" | "passwordShare" | "temporaryPasswordShare" | "team" | "teamMember" | "tag" | "passwordTag" | "auditLog" | "auditLogArchive" | "auditLogSearch" | "settings" | "threatEvent" | "rateLimit" | "role" | "permission" | "rolePermission" | "mfaCredential" | "recoveryCode" | "savedSearch" | "searchHistory" | "passwordTemplate" | "emailVerificationToken" | "passwordResetToken" | "securityQuestion" | "ipWhitelist" | "geographicRestriction" | "passwordPolicy" | "dataRetentionPolicy" | "dataExport" | "dataDeletionRequest" | "report" | "reportTemplate" | "scheduledReport"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Password: {
        payload: Prisma.$PasswordPayload<ExtArgs>
        fields: Prisma.PasswordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          findFirst: {
            args: Prisma.PasswordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          findMany: {
            args: Prisma.PasswordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          create: {
            args: Prisma.PasswordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          createMany: {
            args: Prisma.PasswordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          delete: {
            args: Prisma.PasswordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          update: {
            args: Prisma.PasswordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          deleteMany: {
            args: Prisma.PasswordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          upsert: {
            args: Prisma.PasswordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          aggregate: {
            args: Prisma.PasswordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword>
          }
          groupBy: {
            args: Prisma.PasswordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordCountAggregateOutputType> | number
          }
        }
      }
      PasswordHistory: {
        payload: Prisma.$PasswordHistoryPayload<ExtArgs>
        fields: Prisma.PasswordHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          findFirst: {
            args: Prisma.PasswordHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          findMany: {
            args: Prisma.PasswordHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          create: {
            args: Prisma.PasswordHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          createMany: {
            args: Prisma.PasswordHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          delete: {
            args: Prisma.PasswordHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          update: {
            args: Prisma.PasswordHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PasswordHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PasswordHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          aggregate: {
            args: Prisma.PasswordHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordHistory>
          }
          groupBy: {
            args: Prisma.PasswordHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistoryCountAggregateOutputType> | number
          }
        }
      }
      PasswordBreach: {
        payload: Prisma.$PasswordBreachPayload<ExtArgs>
        fields: Prisma.PasswordBreachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordBreachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordBreachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          findFirst: {
            args: Prisma.PasswordBreachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordBreachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          findMany: {
            args: Prisma.PasswordBreachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>[]
          }
          create: {
            args: Prisma.PasswordBreachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          createMany: {
            args: Prisma.PasswordBreachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordBreachCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>[]
          }
          delete: {
            args: Prisma.PasswordBreachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          update: {
            args: Prisma.PasswordBreachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          deleteMany: {
            args: Prisma.PasswordBreachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordBreachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordBreachUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>[]
          }
          upsert: {
            args: Prisma.PasswordBreachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          aggregate: {
            args: Prisma.PasswordBreachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordBreach>
          }
          groupBy: {
            args: Prisma.PasswordBreachGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordBreachGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordBreachCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordBreachCountAggregateOutputType> | number
          }
        }
      }
      PasswordRotationPolicy: {
        payload: Prisma.$PasswordRotationPolicyPayload<ExtArgs>
        fields: Prisma.PasswordRotationPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordRotationPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordRotationPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          findFirst: {
            args: Prisma.PasswordRotationPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordRotationPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          findMany: {
            args: Prisma.PasswordRotationPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>[]
          }
          create: {
            args: Prisma.PasswordRotationPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          createMany: {
            args: Prisma.PasswordRotationPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordRotationPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>[]
          }
          delete: {
            args: Prisma.PasswordRotationPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          update: {
            args: Prisma.PasswordRotationPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PasswordRotationPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordRotationPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordRotationPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>[]
          }
          upsert: {
            args: Prisma.PasswordRotationPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          aggregate: {
            args: Prisma.PasswordRotationPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordRotationPolicy>
          }
          groupBy: {
            args: Prisma.PasswordRotationPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordRotationPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationPolicyCountAggregateOutputType> | number
          }
        }
      }
      PasswordRotation: {
        payload: Prisma.$PasswordRotationPayload<ExtArgs>
        fields: Prisma.PasswordRotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordRotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordRotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          findFirst: {
            args: Prisma.PasswordRotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordRotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          findMany: {
            args: Prisma.PasswordRotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>[]
          }
          create: {
            args: Prisma.PasswordRotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          createMany: {
            args: Prisma.PasswordRotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordRotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>[]
          }
          delete: {
            args: Prisma.PasswordRotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          update: {
            args: Prisma.PasswordRotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          deleteMany: {
            args: Prisma.PasswordRotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordRotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordRotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>[]
          }
          upsert: {
            args: Prisma.PasswordRotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          aggregate: {
            args: Prisma.PasswordRotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordRotation>
          }
          groupBy: {
            args: Prisma.PasswordRotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordRotationCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      PasswordShare: {
        payload: Prisma.$PasswordSharePayload<ExtArgs>
        fields: Prisma.PasswordShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          findFirst: {
            args: Prisma.PasswordShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          findMany: {
            args: Prisma.PasswordShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>[]
          }
          create: {
            args: Prisma.PasswordShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          createMany: {
            args: Prisma.PasswordShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>[]
          }
          delete: {
            args: Prisma.PasswordShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          update: {
            args: Prisma.PasswordShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          deleteMany: {
            args: Prisma.PasswordShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>[]
          }
          upsert: {
            args: Prisma.PasswordShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          aggregate: {
            args: Prisma.PasswordShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordShare>
          }
          groupBy: {
            args: Prisma.PasswordShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordShareCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordShareCountAggregateOutputType> | number
          }
        }
      }
      TemporaryPasswordShare: {
        payload: Prisma.$TemporaryPasswordSharePayload<ExtArgs>
        fields: Prisma.TemporaryPasswordShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemporaryPasswordShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemporaryPasswordShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>
          }
          findFirst: {
            args: Prisma.TemporaryPasswordShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemporaryPasswordShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>
          }
          findMany: {
            args: Prisma.TemporaryPasswordShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>[]
          }
          create: {
            args: Prisma.TemporaryPasswordShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>
          }
          createMany: {
            args: Prisma.TemporaryPasswordShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemporaryPasswordShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>[]
          }
          delete: {
            args: Prisma.TemporaryPasswordShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>
          }
          update: {
            args: Prisma.TemporaryPasswordShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>
          }
          deleteMany: {
            args: Prisma.TemporaryPasswordShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemporaryPasswordShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemporaryPasswordShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>[]
          }
          upsert: {
            args: Prisma.TemporaryPasswordShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemporaryPasswordSharePayload>
          }
          aggregate: {
            args: Prisma.TemporaryPasswordShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemporaryPasswordShare>
          }
          groupBy: {
            args: Prisma.TemporaryPasswordShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemporaryPasswordShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemporaryPasswordShareCountArgs<ExtArgs>
            result: $Utils.Optional<TemporaryPasswordShareCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      PasswordTag: {
        payload: Prisma.$PasswordTagPayload<ExtArgs>
        fields: Prisma.PasswordTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          findFirst: {
            args: Prisma.PasswordTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          findMany: {
            args: Prisma.PasswordTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>[]
          }
          create: {
            args: Prisma.PasswordTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          createMany: {
            args: Prisma.PasswordTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>[]
          }
          delete: {
            args: Prisma.PasswordTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          update: {
            args: Prisma.PasswordTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          deleteMany: {
            args: Prisma.PasswordTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>[]
          }
          upsert: {
            args: Prisma.PasswordTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          aggregate: {
            args: Prisma.PasswordTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordTag>
          }
          groupBy: {
            args: Prisma.PasswordTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordTagCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordTagCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AuditLogArchive: {
        payload: Prisma.$AuditLogArchivePayload<ExtArgs>
        fields: Prisma.AuditLogArchiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogArchiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogArchiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>
          }
          findFirst: {
            args: Prisma.AuditLogArchiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogArchiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>
          }
          findMany: {
            args: Prisma.AuditLogArchiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>[]
          }
          create: {
            args: Prisma.AuditLogArchiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>
          }
          createMany: {
            args: Prisma.AuditLogArchiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogArchiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>[]
          }
          delete: {
            args: Prisma.AuditLogArchiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>
          }
          update: {
            args: Prisma.AuditLogArchiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>
          }
          deleteMany: {
            args: Prisma.AuditLogArchiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogArchiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogArchiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>[]
          }
          upsert: {
            args: Prisma.AuditLogArchiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogArchivePayload>
          }
          aggregate: {
            args: Prisma.AuditLogArchiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLogArchive>
          }
          groupBy: {
            args: Prisma.AuditLogArchiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogArchiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogArchiveCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogArchiveCountAggregateOutputType> | number
          }
        }
      }
      AuditLogSearch: {
        payload: Prisma.$AuditLogSearchPayload<ExtArgs>
        fields: Prisma.AuditLogSearchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogSearchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogSearchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>
          }
          findFirst: {
            args: Prisma.AuditLogSearchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogSearchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>
          }
          findMany: {
            args: Prisma.AuditLogSearchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>[]
          }
          create: {
            args: Prisma.AuditLogSearchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>
          }
          createMany: {
            args: Prisma.AuditLogSearchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogSearchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>[]
          }
          delete: {
            args: Prisma.AuditLogSearchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>
          }
          update: {
            args: Prisma.AuditLogSearchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogSearchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogSearchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogSearchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogSearchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogSearchPayload>
          }
          aggregate: {
            args: Prisma.AuditLogSearchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLogSearch>
          }
          groupBy: {
            args: Prisma.AuditLogSearchGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogSearchGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogSearchCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogSearchCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      ThreatEvent: {
        payload: Prisma.$ThreatEventPayload<ExtArgs>
        fields: Prisma.ThreatEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThreatEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThreatEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>
          }
          findFirst: {
            args: Prisma.ThreatEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThreatEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>
          }
          findMany: {
            args: Prisma.ThreatEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>[]
          }
          create: {
            args: Prisma.ThreatEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>
          }
          createMany: {
            args: Prisma.ThreatEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThreatEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>[]
          }
          delete: {
            args: Prisma.ThreatEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>
          }
          update: {
            args: Prisma.ThreatEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>
          }
          deleteMany: {
            args: Prisma.ThreatEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThreatEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThreatEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>[]
          }
          upsert: {
            args: Prisma.ThreatEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatEventPayload>
          }
          aggregate: {
            args: Prisma.ThreatEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreatEvent>
          }
          groupBy: {
            args: Prisma.ThreatEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThreatEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThreatEventCountArgs<ExtArgs>
            result: $Utils.Optional<ThreatEventCountAggregateOutputType> | number
          }
        }
      }
      RateLimit: {
        payload: Prisma.$RateLimitPayload<ExtArgs>
        fields: Prisma.RateLimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RateLimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RateLimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          findFirst: {
            args: Prisma.RateLimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RateLimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          findMany: {
            args: Prisma.RateLimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>[]
          }
          create: {
            args: Prisma.RateLimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          createMany: {
            args: Prisma.RateLimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RateLimitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>[]
          }
          delete: {
            args: Prisma.RateLimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          update: {
            args: Prisma.RateLimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          deleteMany: {
            args: Prisma.RateLimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RateLimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RateLimitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>[]
          }
          upsert: {
            args: Prisma.RateLimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          aggregate: {
            args: Prisma.RateLimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRateLimit>
          }
          groupBy: {
            args: Prisma.RateLimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<RateLimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.RateLimitCountArgs<ExtArgs>
            result: $Utils.Optional<RateLimitCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      MfaCredential: {
        payload: Prisma.$MfaCredentialPayload<ExtArgs>
        fields: Prisma.MfaCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MfaCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MfaCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          findFirst: {
            args: Prisma.MfaCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MfaCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          findMany: {
            args: Prisma.MfaCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>[]
          }
          create: {
            args: Prisma.MfaCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          createMany: {
            args: Prisma.MfaCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MfaCredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>[]
          }
          delete: {
            args: Prisma.MfaCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          update: {
            args: Prisma.MfaCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          deleteMany: {
            args: Prisma.MfaCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MfaCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MfaCredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>[]
          }
          upsert: {
            args: Prisma.MfaCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          aggregate: {
            args: Prisma.MfaCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMfaCredential>
          }
          groupBy: {
            args: Prisma.MfaCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MfaCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MfaCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<MfaCredentialCountAggregateOutputType> | number
          }
        }
      }
      RecoveryCode: {
        payload: Prisma.$RecoveryCodePayload<ExtArgs>
        fields: Prisma.RecoveryCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          findFirst: {
            args: Prisma.RecoveryCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          findMany: {
            args: Prisma.RecoveryCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>[]
          }
          create: {
            args: Prisma.RecoveryCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          createMany: {
            args: Prisma.RecoveryCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecoveryCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>[]
          }
          delete: {
            args: Prisma.RecoveryCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          update: {
            args: Prisma.RecoveryCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          deleteMany: {
            args: Prisma.RecoveryCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecoveryCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>[]
          }
          upsert: {
            args: Prisma.RecoveryCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          aggregate: {
            args: Prisma.RecoveryCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryCode>
          }
          groupBy: {
            args: Prisma.RecoveryCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryCodeCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryCodeCountAggregateOutputType> | number
          }
        }
      }
      SavedSearch: {
        payload: Prisma.$SavedSearchPayload<ExtArgs>
        fields: Prisma.SavedSearchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedSearchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedSearchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          findFirst: {
            args: Prisma.SavedSearchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedSearchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          findMany: {
            args: Prisma.SavedSearchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          create: {
            args: Prisma.SavedSearchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          createMany: {
            args: Prisma.SavedSearchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedSearchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          delete: {
            args: Prisma.SavedSearchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          update: {
            args: Prisma.SavedSearchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          deleteMany: {
            args: Prisma.SavedSearchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedSearchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedSearchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          upsert: {
            args: Prisma.SavedSearchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          aggregate: {
            args: Prisma.SavedSearchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedSearch>
          }
          groupBy: {
            args: Prisma.SavedSearchGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedSearchGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedSearchCountArgs<ExtArgs>
            result: $Utils.Optional<SavedSearchCountAggregateOutputType> | number
          }
        }
      }
      SearchHistory: {
        payload: Prisma.$SearchHistoryPayload<ExtArgs>
        fields: Prisma.SearchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findFirst: {
            args: Prisma.SearchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findMany: {
            args: Prisma.SearchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          create: {
            args: Prisma.SearchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          createMany: {
            args: Prisma.SearchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          delete: {
            args: Prisma.SearchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          update: {
            args: Prisma.SearchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SearchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SearchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          aggregate: {
            args: Prisma.SearchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchHistory>
          }
          groupBy: {
            args: Prisma.SearchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryCountAggregateOutputType> | number
          }
        }
      }
      PasswordTemplate: {
        payload: Prisma.$PasswordTemplatePayload<ExtArgs>
        fields: Prisma.PasswordTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          findFirst: {
            args: Prisma.PasswordTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          findMany: {
            args: Prisma.PasswordTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>[]
          }
          create: {
            args: Prisma.PasswordTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          createMany: {
            args: Prisma.PasswordTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>[]
          }
          delete: {
            args: Prisma.PasswordTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          update: {
            args: Prisma.PasswordTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          deleteMany: {
            args: Prisma.PasswordTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>[]
          }
          upsert: {
            args: Prisma.PasswordTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          aggregate: {
            args: Prisma.PasswordTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordTemplate>
          }
          groupBy: {
            args: Prisma.PasswordTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailVerificationToken: {
        payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>
        fields: Prisma.EmailVerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          update: {
            args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerificationToken>
          }
          groupBy: {
            args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      SecurityQuestion: {
        payload: Prisma.$SecurityQuestionPayload<ExtArgs>
        fields: Prisma.SecurityQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          findFirst: {
            args: Prisma.SecurityQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          findMany: {
            args: Prisma.SecurityQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>[]
          }
          create: {
            args: Prisma.SecurityQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          createMany: {
            args: Prisma.SecurityQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>[]
          }
          delete: {
            args: Prisma.SecurityQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          update: {
            args: Prisma.SecurityQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          deleteMany: {
            args: Prisma.SecurityQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>[]
          }
          upsert: {
            args: Prisma.SecurityQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          aggregate: {
            args: Prisma.SecurityQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityQuestion>
          }
          groupBy: {
            args: Prisma.SecurityQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityQuestionCountAggregateOutputType> | number
          }
        }
      }
      IpWhitelist: {
        payload: Prisma.$IpWhitelistPayload<ExtArgs>
        fields: Prisma.IpWhitelistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IpWhitelistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IpWhitelistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          findFirst: {
            args: Prisma.IpWhitelistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IpWhitelistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          findMany: {
            args: Prisma.IpWhitelistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>[]
          }
          create: {
            args: Prisma.IpWhitelistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          createMany: {
            args: Prisma.IpWhitelistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IpWhitelistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>[]
          }
          delete: {
            args: Prisma.IpWhitelistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          update: {
            args: Prisma.IpWhitelistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          deleteMany: {
            args: Prisma.IpWhitelistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IpWhitelistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IpWhitelistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>[]
          }
          upsert: {
            args: Prisma.IpWhitelistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IpWhitelistPayload>
          }
          aggregate: {
            args: Prisma.IpWhitelistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIpWhitelist>
          }
          groupBy: {
            args: Prisma.IpWhitelistGroupByArgs<ExtArgs>
            result: $Utils.Optional<IpWhitelistGroupByOutputType>[]
          }
          count: {
            args: Prisma.IpWhitelistCountArgs<ExtArgs>
            result: $Utils.Optional<IpWhitelistCountAggregateOutputType> | number
          }
        }
      }
      GeographicRestriction: {
        payload: Prisma.$GeographicRestrictionPayload<ExtArgs>
        fields: Prisma.GeographicRestrictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeographicRestrictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeographicRestrictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>
          }
          findFirst: {
            args: Prisma.GeographicRestrictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeographicRestrictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>
          }
          findMany: {
            args: Prisma.GeographicRestrictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>[]
          }
          create: {
            args: Prisma.GeographicRestrictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>
          }
          createMany: {
            args: Prisma.GeographicRestrictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeographicRestrictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>[]
          }
          delete: {
            args: Prisma.GeographicRestrictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>
          }
          update: {
            args: Prisma.GeographicRestrictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>
          }
          deleteMany: {
            args: Prisma.GeographicRestrictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeographicRestrictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeographicRestrictionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>[]
          }
          upsert: {
            args: Prisma.GeographicRestrictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeographicRestrictionPayload>
          }
          aggregate: {
            args: Prisma.GeographicRestrictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeographicRestriction>
          }
          groupBy: {
            args: Prisma.GeographicRestrictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeographicRestrictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeographicRestrictionCountArgs<ExtArgs>
            result: $Utils.Optional<GeographicRestrictionCountAggregateOutputType> | number
          }
        }
      }
      PasswordPolicy: {
        payload: Prisma.$PasswordPolicyPayload<ExtArgs>
        fields: Prisma.PasswordPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>
          }
          findFirst: {
            args: Prisma.PasswordPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>
          }
          findMany: {
            args: Prisma.PasswordPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>[]
          }
          create: {
            args: Prisma.PasswordPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>
          }
          createMany: {
            args: Prisma.PasswordPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>[]
          }
          delete: {
            args: Prisma.PasswordPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>
          }
          update: {
            args: Prisma.PasswordPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PasswordPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>[]
          }
          upsert: {
            args: Prisma.PasswordPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPolicyPayload>
          }
          aggregate: {
            args: Prisma.PasswordPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordPolicy>
          }
          groupBy: {
            args: Prisma.PasswordPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordPolicyCountAggregateOutputType> | number
          }
        }
      }
      DataRetentionPolicy: {
        payload: Prisma.$DataRetentionPolicyPayload<ExtArgs>
        fields: Prisma.DataRetentionPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRetentionPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          findFirst: {
            args: Prisma.DataRetentionPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          findMany: {
            args: Prisma.DataRetentionPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>[]
          }
          create: {
            args: Prisma.DataRetentionPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          createMany: {
            args: Prisma.DataRetentionPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>[]
          }
          delete: {
            args: Prisma.DataRetentionPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          update: {
            args: Prisma.DataRetentionPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          deleteMany: {
            args: Prisma.DataRetentionPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRetentionPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataRetentionPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>[]
          }
          upsert: {
            args: Prisma.DataRetentionPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionPolicyPayload>
          }
          aggregate: {
            args: Prisma.DataRetentionPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRetentionPolicy>
          }
          groupBy: {
            args: Prisma.DataRetentionPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataRetentionPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionPolicyCountAggregateOutputType> | number
          }
        }
      }
      DataExport: {
        payload: Prisma.$DataExportPayload<ExtArgs>
        fields: Prisma.DataExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>
          }
          findFirst: {
            args: Prisma.DataExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>
          }
          findMany: {
            args: Prisma.DataExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>[]
          }
          create: {
            args: Prisma.DataExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>
          }
          createMany: {
            args: Prisma.DataExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>[]
          }
          delete: {
            args: Prisma.DataExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>
          }
          update: {
            args: Prisma.DataExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>
          }
          deleteMany: {
            args: Prisma.DataExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataExportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>[]
          }
          upsert: {
            args: Prisma.DataExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportPayload>
          }
          aggregate: {
            args: Prisma.DataExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataExport>
          }
          groupBy: {
            args: Prisma.DataExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataExportCountArgs<ExtArgs>
            result: $Utils.Optional<DataExportCountAggregateOutputType> | number
          }
        }
      }
      DataDeletionRequest: {
        payload: Prisma.$DataDeletionRequestPayload<ExtArgs>
        fields: Prisma.DataDeletionRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataDeletionRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          findFirst: {
            args: Prisma.DataDeletionRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataDeletionRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          findMany: {
            args: Prisma.DataDeletionRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          create: {
            args: Prisma.DataDeletionRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          createMany: {
            args: Prisma.DataDeletionRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataDeletionRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          delete: {
            args: Prisma.DataDeletionRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          update: {
            args: Prisma.DataDeletionRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataDeletionRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataDeletionRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>[]
          }
          upsert: {
            args: Prisma.DataDeletionRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataDeletionRequestPayload>
          }
          aggregate: {
            args: Prisma.DataDeletionRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataDeletionRequest>
          }
          groupBy: {
            args: Prisma.DataDeletionRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataDeletionRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataDeletionRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataDeletionRequestCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      ReportTemplate: {
        payload: Prisma.$ReportTemplatePayload<ExtArgs>
        fields: Prisma.ReportTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findFirst: {
            args: Prisma.ReportTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findMany: {
            args: Prisma.ReportTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          create: {
            args: Prisma.ReportTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          createMany: {
            args: Prisma.ReportTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          delete: {
            args: Prisma.ReportTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          update: {
            args: Prisma.ReportTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ReportTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ReportTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          aggregate: {
            args: Prisma.ReportTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportTemplate>
          }
          groupBy: {
            args: Prisma.ReportTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateCountAggregateOutputType> | number
          }
        }
      }
      ScheduledReport: {
        payload: Prisma.$ScheduledReportPayload<ExtArgs>
        fields: Prisma.ScheduledReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          findFirst: {
            args: Prisma.ScheduledReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          findMany: {
            args: Prisma.ScheduledReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          create: {
            args: Prisma.ScheduledReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          createMany: {
            args: Prisma.ScheduledReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          delete: {
            args: Prisma.ScheduledReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          update: {
            args: Prisma.ScheduledReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduledReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          upsert: {
            args: Prisma.ScheduledReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          aggregate: {
            args: Prisma.ScheduledReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledReport>
          }
          groupBy: {
            args: Prisma.ScheduledReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledReportCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReportCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    password?: PasswordOmit
    passwordHistory?: PasswordHistoryOmit
    passwordBreach?: PasswordBreachOmit
    passwordRotationPolicy?: PasswordRotationPolicyOmit
    passwordRotation?: PasswordRotationOmit
    folder?: FolderOmit
    passwordShare?: PasswordShareOmit
    temporaryPasswordShare?: TemporaryPasswordShareOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    tag?: TagOmit
    passwordTag?: PasswordTagOmit
    auditLog?: AuditLogOmit
    auditLogArchive?: AuditLogArchiveOmit
    auditLogSearch?: AuditLogSearchOmit
    settings?: SettingsOmit
    threatEvent?: ThreatEventOmit
    rateLimit?: RateLimitOmit
    role?: RoleOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    mfaCredential?: MfaCredentialOmit
    recoveryCode?: RecoveryCodeOmit
    savedSearch?: SavedSearchOmit
    searchHistory?: SearchHistoryOmit
    passwordTemplate?: PasswordTemplateOmit
    emailVerificationToken?: EmailVerificationTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    securityQuestion?: SecurityQuestionOmit
    ipWhitelist?: IpWhitelistOmit
    geographicRestriction?: GeographicRestrictionOmit
    passwordPolicy?: PasswordPolicyOmit
    dataRetentionPolicy?: DataRetentionPolicyOmit
    dataExport?: DataExportOmit
    dataDeletionRequest?: DataDeletionRequestOmit
    report?: ReportOmit
    reportTemplate?: ReportTemplateOmit
    scheduledReport?: ScheduledReportOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    templates: number
    ipWhitelists: number
    geographicRestrictions: number
    threatEvents: number
    rateLimits: number
    dataExports: number
    dataDeletionRequests: number
    auditLogArchives: number
    auditLogSearches: number
    reports: number
    reportTemplates: number
    scheduledReports: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    templates?: boolean | CompanyCountOutputTypeCountTemplatesArgs
    ipWhitelists?: boolean | CompanyCountOutputTypeCountIpWhitelistsArgs
    geographicRestrictions?: boolean | CompanyCountOutputTypeCountGeographicRestrictionsArgs
    threatEvents?: boolean | CompanyCountOutputTypeCountThreatEventsArgs
    rateLimits?: boolean | CompanyCountOutputTypeCountRateLimitsArgs
    dataExports?: boolean | CompanyCountOutputTypeCountDataExportsArgs
    dataDeletionRequests?: boolean | CompanyCountOutputTypeCountDataDeletionRequestsArgs
    auditLogArchives?: boolean | CompanyCountOutputTypeCountAuditLogArchivesArgs
    auditLogSearches?: boolean | CompanyCountOutputTypeCountAuditLogSearchesArgs
    reports?: boolean | CompanyCountOutputTypeCountReportsArgs
    reportTemplates?: boolean | CompanyCountOutputTypeCountReportTemplatesArgs
    scheduledReports?: boolean | CompanyCountOutputTypeCountScheduledReportsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTemplateWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountIpWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpWhitelistWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountGeographicRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeographicRestrictionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountThreatEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreatEventWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountRateLimitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateLimitWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDataExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataExportWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDataDeletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDeletionRequestWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogArchivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogArchiveWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogSearchWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountReportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountScheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedPasswords: number
    sharedPasswords: number
    teamMemberships: number
    auditLogs: number
    threatEvents: number
    sessions: number
    accounts: number
    mfaCredentials: number
    recoveryCodes: number
    passwordHistory: number
    passwordBreachesChecked: number
    passwordBreachesResolved: number
    rotationPolicies: number
    passwordRotations: number
    temporaryPasswordShares: number
    savedSearches: number
    searchHistory: number
    passwordTemplates: number
    reports: number
    reportTemplates: number
    scheduledReports: number
    createdUsers: number
    createdRoles: number
    dataExports: number
    dataDeletionRequests: number
    processedDeletions: number
    auditLogArchives: number
    auditLogSearches: number
    emailVerificationTokens: number
    passwordResetTokens: number
    securityQuestions: number
    ipWhitelists: number
    geographicRestrictions: number
    createdIpWhitelists: number
    createdGeographicRestrictions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPasswords?: boolean | UserCountOutputTypeCountOwnedPasswordsArgs
    sharedPasswords?: boolean | UserCountOutputTypeCountSharedPasswordsArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    threatEvents?: boolean | UserCountOutputTypeCountThreatEventsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    mfaCredentials?: boolean | UserCountOutputTypeCountMfaCredentialsArgs
    recoveryCodes?: boolean | UserCountOutputTypeCountRecoveryCodesArgs
    passwordHistory?: boolean | UserCountOutputTypeCountPasswordHistoryArgs
    passwordBreachesChecked?: boolean | UserCountOutputTypeCountPasswordBreachesCheckedArgs
    passwordBreachesResolved?: boolean | UserCountOutputTypeCountPasswordBreachesResolvedArgs
    rotationPolicies?: boolean | UserCountOutputTypeCountRotationPoliciesArgs
    passwordRotations?: boolean | UserCountOutputTypeCountPasswordRotationsArgs
    temporaryPasswordShares?: boolean | UserCountOutputTypeCountTemporaryPasswordSharesArgs
    savedSearches?: boolean | UserCountOutputTypeCountSavedSearchesArgs
    searchHistory?: boolean | UserCountOutputTypeCountSearchHistoryArgs
    passwordTemplates?: boolean | UserCountOutputTypeCountPasswordTemplatesArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    reportTemplates?: boolean | UserCountOutputTypeCountReportTemplatesArgs
    scheduledReports?: boolean | UserCountOutputTypeCountScheduledReportsArgs
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    createdRoles?: boolean | UserCountOutputTypeCountCreatedRolesArgs
    dataExports?: boolean | UserCountOutputTypeCountDataExportsArgs
    dataDeletionRequests?: boolean | UserCountOutputTypeCountDataDeletionRequestsArgs
    processedDeletions?: boolean | UserCountOutputTypeCountProcessedDeletionsArgs
    auditLogArchives?: boolean | UserCountOutputTypeCountAuditLogArchivesArgs
    auditLogSearches?: boolean | UserCountOutputTypeCountAuditLogSearchesArgs
    emailVerificationTokens?: boolean | UserCountOutputTypeCountEmailVerificationTokensArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    securityQuestions?: boolean | UserCountOutputTypeCountSecurityQuestionsArgs
    ipWhitelists?: boolean | UserCountOutputTypeCountIpWhitelistsArgs
    geographicRestrictions?: boolean | UserCountOutputTypeCountGeographicRestrictionsArgs
    createdIpWhitelists?: boolean | UserCountOutputTypeCountCreatedIpWhitelistsArgs
    createdGeographicRestrictions?: boolean | UserCountOutputTypeCountCreatedGeographicRestrictionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountThreatEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreatEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMfaCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MfaCredentialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecoveryCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordBreachesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordBreachesResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRotationPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationPolicyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTemporaryPasswordSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemporaryPasswordShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedSearchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataExportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataDeletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDeletionRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessedDeletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDeletionRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArchivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogArchiveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogSearchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSecurityQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityQuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIpWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpWhitelistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeographicRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeographicRestrictionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedIpWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpWhitelistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGeographicRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeographicRestrictionWhereInput
  }


  /**
   * Count Type PasswordCountOutputType
   */

  export type PasswordCountOutputType = {
    sharedWith: number
    temporaryShares: number
    tags: number
    history: number
    breaches: number
    rotations: number
  }

  export type PasswordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedWith?: boolean | PasswordCountOutputTypeCountSharedWithArgs
    temporaryShares?: boolean | PasswordCountOutputTypeCountTemporarySharesArgs
    tags?: boolean | PasswordCountOutputTypeCountTagsArgs
    history?: boolean | PasswordCountOutputTypeCountHistoryArgs
    breaches?: boolean | PasswordCountOutputTypeCountBreachesArgs
    rotations?: boolean | PasswordCountOutputTypeCountRotationsArgs
  }

  // Custom InputTypes
  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordCountOutputType
     */
    select?: PasswordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountSharedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountTemporarySharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemporaryPasswordShareWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTagWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountBreachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
  }


  /**
   * Count Type PasswordRotationPolicyCountOutputType
   */

  export type PasswordRotationPolicyCountOutputType = {
    passwords: number
    rotations: number
  }

  export type PasswordRotationPolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwords?: boolean | PasswordRotationPolicyCountOutputTypeCountPasswordsArgs
    rotations?: boolean | PasswordRotationPolicyCountOutputTypeCountRotationsArgs
  }

  // Custom InputTypes
  /**
   * PasswordRotationPolicyCountOutputType without action
   */
  export type PasswordRotationPolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicyCountOutputType
     */
    select?: PasswordRotationPolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PasswordRotationPolicyCountOutputType without action
   */
  export type PasswordRotationPolicyCountOutputTypeCountPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
  }

  /**
   * PasswordRotationPolicyCountOutputType without action
   */
  export type PasswordRotationPolicyCountOutputTypeCountRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    children: number
    passwords: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FolderCountOutputTypeCountChildrenArgs
    passwords?: boolean | FolderCountOutputTypeCountPasswordsArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    sharedPasswords: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    sharedPasswords?: boolean | TeamCountOutputTypeCountSharedPasswordsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    passwords: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwords?: boolean | TagCountOutputTypeCountPasswordsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTagWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type ReportTemplateCountOutputType
   */

  export type ReportTemplateCountOutputType = {
    reports: number
    scheduledReports: number
  }

  export type ReportTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ReportTemplateCountOutputTypeCountReportsArgs
    scheduledReports?: boolean | ReportTemplateCountOutputTypeCountScheduledReportsArgs
  }

  // Custom InputTypes
  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplateCountOutputType
     */
    select?: ReportTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeCountScheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    subdomain: string
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    templates?: boolean | Company$templatesArgs<ExtArgs>
    ipWhitelists?: boolean | Company$ipWhitelistsArgs<ExtArgs>
    geographicRestrictions?: boolean | Company$geographicRestrictionsArgs<ExtArgs>
    threatEvents?: boolean | Company$threatEventsArgs<ExtArgs>
    rateLimits?: boolean | Company$rateLimitsArgs<ExtArgs>
    passwordPolicy?: boolean | Company$passwordPolicyArgs<ExtArgs>
    dataRetentionPolicy?: boolean | Company$dataRetentionPolicyArgs<ExtArgs>
    dataExports?: boolean | Company$dataExportsArgs<ExtArgs>
    dataDeletionRequests?: boolean | Company$dataDeletionRequestsArgs<ExtArgs>
    auditLogArchives?: boolean | Company$auditLogArchivesArgs<ExtArgs>
    auditLogSearches?: boolean | Company$auditLogSearchesArgs<ExtArgs>
    reports?: boolean | Company$reportsArgs<ExtArgs>
    reportTemplates?: boolean | Company$reportTemplatesArgs<ExtArgs>
    scheduledReports?: boolean | Company$scheduledReportsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subdomain" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    templates?: boolean | Company$templatesArgs<ExtArgs>
    ipWhitelists?: boolean | Company$ipWhitelistsArgs<ExtArgs>
    geographicRestrictions?: boolean | Company$geographicRestrictionsArgs<ExtArgs>
    threatEvents?: boolean | Company$threatEventsArgs<ExtArgs>
    rateLimits?: boolean | Company$rateLimitsArgs<ExtArgs>
    passwordPolicy?: boolean | Company$passwordPolicyArgs<ExtArgs>
    dataRetentionPolicy?: boolean | Company$dataRetentionPolicyArgs<ExtArgs>
    dataExports?: boolean | Company$dataExportsArgs<ExtArgs>
    dataDeletionRequests?: boolean | Company$dataDeletionRequestsArgs<ExtArgs>
    auditLogArchives?: boolean | Company$auditLogArchivesArgs<ExtArgs>
    auditLogSearches?: boolean | Company$auditLogSearchesArgs<ExtArgs>
    reports?: boolean | Company$reportsArgs<ExtArgs>
    reportTemplates?: boolean | Company$reportTemplatesArgs<ExtArgs>
    scheduledReports?: boolean | Company$scheduledReportsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      templates: Prisma.$PasswordTemplatePayload<ExtArgs>[]
      ipWhitelists: Prisma.$IpWhitelistPayload<ExtArgs>[]
      geographicRestrictions: Prisma.$GeographicRestrictionPayload<ExtArgs>[]
      threatEvents: Prisma.$ThreatEventPayload<ExtArgs>[]
      rateLimits: Prisma.$RateLimitPayload<ExtArgs>[]
      passwordPolicy: Prisma.$PasswordPolicyPayload<ExtArgs> | null
      dataRetentionPolicy: Prisma.$DataRetentionPolicyPayload<ExtArgs> | null
      dataExports: Prisma.$DataExportPayload<ExtArgs>[]
      dataDeletionRequests: Prisma.$DataDeletionRequestPayload<ExtArgs>[]
      auditLogArchives: Prisma.$AuditLogArchivePayload<ExtArgs>[]
      auditLogSearches: Prisma.$AuditLogSearchPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      reportTemplates: Prisma.$ReportTemplatePayload<ExtArgs>[]
      scheduledReports: Prisma.$ScheduledReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subdomain: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templates<T extends Company$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ipWhitelists<T extends Company$ipWhitelistsArgs<ExtArgs> = {}>(args?: Subset<T, Company$ipWhitelistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    geographicRestrictions<T extends Company$geographicRestrictionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$geographicRestrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    threatEvents<T extends Company$threatEventsArgs<ExtArgs> = {}>(args?: Subset<T, Company$threatEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rateLimits<T extends Company$rateLimitsArgs<ExtArgs> = {}>(args?: Subset<T, Company$rateLimitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordPolicy<T extends Company$passwordPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Company$passwordPolicyArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dataRetentionPolicy<T extends Company$dataRetentionPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Company$dataRetentionPolicyArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dataExports<T extends Company$dataExportsArgs<ExtArgs> = {}>(args?: Subset<T, Company$dataExportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataDeletionRequests<T extends Company$dataDeletionRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Company$dataDeletionRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogArchives<T extends Company$auditLogArchivesArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogArchivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogSearches<T extends Company$auditLogSearchesArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogSearchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Company$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Company$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportTemplates<T extends Company$reportTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$reportTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduledReports<T extends Company$scheduledReportsArgs<ExtArgs> = {}>(args?: Subset<T, Company$scheduledReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly subdomain: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.templates
   */
  export type Company$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    where?: PasswordTemplateWhereInput
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    cursor?: PasswordTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * Company.ipWhitelists
   */
  export type Company$ipWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    where?: IpWhitelistWhereInput
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    cursor?: IpWhitelistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * Company.geographicRestrictions
   */
  export type Company$geographicRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    where?: GeographicRestrictionWhereInput
    orderBy?: GeographicRestrictionOrderByWithRelationInput | GeographicRestrictionOrderByWithRelationInput[]
    cursor?: GeographicRestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeographicRestrictionScalarFieldEnum | GeographicRestrictionScalarFieldEnum[]
  }

  /**
   * Company.threatEvents
   */
  export type Company$threatEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    where?: ThreatEventWhereInput
    orderBy?: ThreatEventOrderByWithRelationInput | ThreatEventOrderByWithRelationInput[]
    cursor?: ThreatEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreatEventScalarFieldEnum | ThreatEventScalarFieldEnum[]
  }

  /**
   * Company.rateLimits
   */
  export type Company$rateLimitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    where?: RateLimitWhereInput
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    cursor?: RateLimitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateLimitScalarFieldEnum | RateLimitScalarFieldEnum[]
  }

  /**
   * Company.passwordPolicy
   */
  export type Company$passwordPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    where?: PasswordPolicyWhereInput
  }

  /**
   * Company.dataRetentionPolicy
   */
  export type Company$dataRetentionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    where?: DataRetentionPolicyWhereInput
  }

  /**
   * Company.dataExports
   */
  export type Company$dataExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    where?: DataExportWhereInput
    orderBy?: DataExportOrderByWithRelationInput | DataExportOrderByWithRelationInput[]
    cursor?: DataExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataExportScalarFieldEnum | DataExportScalarFieldEnum[]
  }

  /**
   * Company.dataDeletionRequests
   */
  export type Company$dataDeletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    where?: DataDeletionRequestWhereInput
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    cursor?: DataDeletionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * Company.auditLogArchives
   */
  export type Company$auditLogArchivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    where?: AuditLogArchiveWhereInput
    orderBy?: AuditLogArchiveOrderByWithRelationInput | AuditLogArchiveOrderByWithRelationInput[]
    cursor?: AuditLogArchiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogArchiveScalarFieldEnum | AuditLogArchiveScalarFieldEnum[]
  }

  /**
   * Company.auditLogSearches
   */
  export type Company$auditLogSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    where?: AuditLogSearchWhereInput
    orderBy?: AuditLogSearchOrderByWithRelationInput | AuditLogSearchOrderByWithRelationInput[]
    cursor?: AuditLogSearchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogSearchScalarFieldEnum | AuditLogSearchScalarFieldEnum[]
  }

  /**
   * Company.reports
   */
  export type Company$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Company.reportTemplates
   */
  export type Company$reportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    cursor?: ReportTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * Company.scheduledReports
   */
  export type Company$scheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    recoveryEmail: string | null
    recoveryEmailVerified: Date | null
    image: string | null
    password: string | null
    phoneNumber: string | null
    bio: string | null
    role: string | null
    isActive: boolean | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaMethod: $Enums.MfaMethod | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    createdById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    recoveryEmail: string | null
    recoveryEmailVerified: Date | null
    image: string | null
    password: string | null
    phoneNumber: string | null
    bio: string | null
    role: string | null
    isActive: boolean | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaMethod: $Enums.MfaMethod | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    createdById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    recoveryEmail: number
    recoveryEmailVerified: number
    image: number
    password: number
    phoneNumber: number
    bio: number
    preferences: number
    role: number
    isActive: number
    mfaEnabled: number
    mfaSecret: number
    mfaMethod: number
    companyId: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    createdById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    recoveryEmail?: true
    recoveryEmailVerified?: true
    image?: true
    password?: true
    phoneNumber?: true
    bio?: true
    role?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaMethod?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    createdById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    recoveryEmail?: true
    recoveryEmailVerified?: true
    image?: true
    password?: true
    phoneNumber?: true
    bio?: true
    role?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaMethod?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    createdById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    recoveryEmail?: true
    recoveryEmailVerified?: true
    image?: true
    password?: true
    phoneNumber?: true
    bio?: true
    preferences?: true
    role?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaMethod?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    createdById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: Date | null
    recoveryEmail: string | null
    recoveryEmailVerified: Date | null
    image: string | null
    password: string | null
    phoneNumber: string | null
    bio: string | null
    preferences: JsonValue | null
    role: string
    isActive: boolean
    mfaEnabled: boolean
    mfaSecret: string | null
    mfaMethod: $Enums.MfaMethod | null
    companyId: string | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    createdById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    ownedPasswords?: boolean | User$ownedPasswordsArgs<ExtArgs>
    sharedPasswords?: boolean | User$sharedPasswordsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    threatEvents?: boolean | User$threatEventsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    mfaCredentials?: boolean | User$mfaCredentialsArgs<ExtArgs>
    recoveryCodes?: boolean | User$recoveryCodesArgs<ExtArgs>
    passwordHistory?: boolean | User$passwordHistoryArgs<ExtArgs>
    passwordBreachesChecked?: boolean | User$passwordBreachesCheckedArgs<ExtArgs>
    passwordBreachesResolved?: boolean | User$passwordBreachesResolvedArgs<ExtArgs>
    rotationPolicies?: boolean | User$rotationPoliciesArgs<ExtArgs>
    passwordRotations?: boolean | User$passwordRotationsArgs<ExtArgs>
    temporaryPasswordShares?: boolean | User$temporaryPasswordSharesArgs<ExtArgs>
    savedSearches?: boolean | User$savedSearchesArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    passwordTemplates?: boolean | User$passwordTemplatesArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    reportTemplates?: boolean | User$reportTemplatesArgs<ExtArgs>
    scheduledReports?: boolean | User$scheduledReportsArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    createdRoles?: boolean | User$createdRolesArgs<ExtArgs>
    dataExports?: boolean | User$dataExportsArgs<ExtArgs>
    dataDeletionRequests?: boolean | User$dataDeletionRequestsArgs<ExtArgs>
    processedDeletions?: boolean | User$processedDeletionsArgs<ExtArgs>
    auditLogArchives?: boolean | User$auditLogArchivesArgs<ExtArgs>
    auditLogSearches?: boolean | User$auditLogSearchesArgs<ExtArgs>
    emailVerificationTokens?: boolean | User$emailVerificationTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    securityQuestions?: boolean | User$securityQuestionsArgs<ExtArgs>
    ipWhitelists?: boolean | User$ipWhitelistsArgs<ExtArgs>
    geographicRestrictions?: boolean | User$geographicRestrictionsArgs<ExtArgs>
    createdIpWhitelists?: boolean | User$createdIpWhitelistsArgs<ExtArgs>
    createdGeographicRestrictions?: boolean | User$createdGeographicRestrictionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "recoveryEmail" | "recoveryEmailVerified" | "image" | "password" | "phoneNumber" | "bio" | "preferences" | "role" | "isActive" | "mfaEnabled" | "mfaSecret" | "mfaMethod" | "companyId" | "createdAt" | "updatedAt" | "lastLoginAt" | "createdById", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    ownedPasswords?: boolean | User$ownedPasswordsArgs<ExtArgs>
    sharedPasswords?: boolean | User$sharedPasswordsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    threatEvents?: boolean | User$threatEventsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    mfaCredentials?: boolean | User$mfaCredentialsArgs<ExtArgs>
    recoveryCodes?: boolean | User$recoveryCodesArgs<ExtArgs>
    passwordHistory?: boolean | User$passwordHistoryArgs<ExtArgs>
    passwordBreachesChecked?: boolean | User$passwordBreachesCheckedArgs<ExtArgs>
    passwordBreachesResolved?: boolean | User$passwordBreachesResolvedArgs<ExtArgs>
    rotationPolicies?: boolean | User$rotationPoliciesArgs<ExtArgs>
    passwordRotations?: boolean | User$passwordRotationsArgs<ExtArgs>
    temporaryPasswordShares?: boolean | User$temporaryPasswordSharesArgs<ExtArgs>
    savedSearches?: boolean | User$savedSearchesArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    passwordTemplates?: boolean | User$passwordTemplatesArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    reportTemplates?: boolean | User$reportTemplatesArgs<ExtArgs>
    scheduledReports?: boolean | User$scheduledReportsArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    createdRoles?: boolean | User$createdRolesArgs<ExtArgs>
    dataExports?: boolean | User$dataExportsArgs<ExtArgs>
    dataDeletionRequests?: boolean | User$dataDeletionRequestsArgs<ExtArgs>
    processedDeletions?: boolean | User$processedDeletionsArgs<ExtArgs>
    auditLogArchives?: boolean | User$auditLogArchivesArgs<ExtArgs>
    auditLogSearches?: boolean | User$auditLogSearchesArgs<ExtArgs>
    emailVerificationTokens?: boolean | User$emailVerificationTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    securityQuestions?: boolean | User$securityQuestionsArgs<ExtArgs>
    ipWhitelists?: boolean | User$ipWhitelistsArgs<ExtArgs>
    geographicRestrictions?: boolean | User$geographicRestrictionsArgs<ExtArgs>
    createdIpWhitelists?: boolean | User$createdIpWhitelistsArgs<ExtArgs>
    createdGeographicRestrictions?: boolean | User$createdGeographicRestrictionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      ownedPasswords: Prisma.$PasswordPayload<ExtArgs>[]
      sharedPasswords: Prisma.$PasswordSharePayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      threatEvents: Prisma.$ThreatEventPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      mfaCredentials: Prisma.$MfaCredentialPayload<ExtArgs>[]
      recoveryCodes: Prisma.$RecoveryCodePayload<ExtArgs>[]
      passwordHistory: Prisma.$PasswordHistoryPayload<ExtArgs>[]
      passwordBreachesChecked: Prisma.$PasswordBreachPayload<ExtArgs>[]
      passwordBreachesResolved: Prisma.$PasswordBreachPayload<ExtArgs>[]
      rotationPolicies: Prisma.$PasswordRotationPolicyPayload<ExtArgs>[]
      passwordRotations: Prisma.$PasswordRotationPayload<ExtArgs>[]
      temporaryPasswordShares: Prisma.$TemporaryPasswordSharePayload<ExtArgs>[]
      savedSearches: Prisma.$SavedSearchPayload<ExtArgs>[]
      searchHistory: Prisma.$SearchHistoryPayload<ExtArgs>[]
      passwordTemplates: Prisma.$PasswordTemplatePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      reportTemplates: Prisma.$ReportTemplatePayload<ExtArgs>[]
      scheduledReports: Prisma.$ScheduledReportPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      createdRoles: Prisma.$RolePayload<ExtArgs>[]
      dataExports: Prisma.$DataExportPayload<ExtArgs>[]
      dataDeletionRequests: Prisma.$DataDeletionRequestPayload<ExtArgs>[]
      processedDeletions: Prisma.$DataDeletionRequestPayload<ExtArgs>[]
      auditLogArchives: Prisma.$AuditLogArchivePayload<ExtArgs>[]
      auditLogSearches: Prisma.$AuditLogSearchPayload<ExtArgs>[]
      emailVerificationTokens: Prisma.$EmailVerificationTokenPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      securityQuestions: Prisma.$SecurityQuestionPayload<ExtArgs>[]
      ipWhitelists: Prisma.$IpWhitelistPayload<ExtArgs>[]
      geographicRestrictions: Prisma.$GeographicRestrictionPayload<ExtArgs>[]
      createdIpWhitelists: Prisma.$IpWhitelistPayload<ExtArgs>[]
      createdGeographicRestrictions: Prisma.$GeographicRestrictionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: Date | null
      recoveryEmail: string | null
      recoveryEmailVerified: Date | null
      image: string | null
      password: string | null
      phoneNumber: string | null
      bio: string | null
      preferences: Prisma.JsonValue | null
      role: string
      isActive: boolean
      mfaEnabled: boolean
      mfaSecret: string | null
      mfaMethod: $Enums.MfaMethod | null
      companyId: string | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      createdById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedPasswords<T extends User$ownedPasswordsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedPasswordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedPasswords<T extends User$sharedPasswordsArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedPasswordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    threatEvents<T extends User$threatEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$threatEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mfaCredentials<T extends User$mfaCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$mfaCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recoveryCodes<T extends User$recoveryCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$recoveryCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordHistory<T extends User$passwordHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordBreachesChecked<T extends User$passwordBreachesCheckedArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordBreachesCheckedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordBreachesResolved<T extends User$passwordBreachesResolvedArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordBreachesResolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotationPolicies<T extends User$rotationPoliciesArgs<ExtArgs> = {}>(args?: Subset<T, User$rotationPoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordRotations<T extends User$passwordRotationsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordRotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    temporaryPasswordShares<T extends User$temporaryPasswordSharesArgs<ExtArgs> = {}>(args?: Subset<T, User$temporaryPasswordSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedSearches<T extends User$savedSearchesArgs<ExtArgs> = {}>(args?: Subset<T, User$savedSearchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchHistory<T extends User$searchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$searchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordTemplates<T extends User$passwordTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportTemplates<T extends User$reportTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$reportTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduledReports<T extends User$scheduledReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$scheduledReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdRoles<T extends User$createdRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataExports<T extends User$dataExportsArgs<ExtArgs> = {}>(args?: Subset<T, User$dataExportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataDeletionRequests<T extends User$dataDeletionRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$dataDeletionRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processedDeletions<T extends User$processedDeletionsArgs<ExtArgs> = {}>(args?: Subset<T, User$processedDeletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogArchives<T extends User$auditLogArchivesArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogArchivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogSearches<T extends User$auditLogSearchesArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogSearchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailVerificationTokens<T extends User$emailVerificationTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$emailVerificationTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityQuestions<T extends User$securityQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$securityQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ipWhitelists<T extends User$ipWhitelistsArgs<ExtArgs> = {}>(args?: Subset<T, User$ipWhitelistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    geographicRestrictions<T extends User$geographicRestrictionsArgs<ExtArgs> = {}>(args?: Subset<T, User$geographicRestrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdIpWhitelists<T extends User$createdIpWhitelistsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdIpWhitelistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdGeographicRestrictions<T extends User$createdGeographicRestrictionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGeographicRestrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly recoveryEmail: FieldRef<"User", 'String'>
    readonly recoveryEmailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly mfaEnabled: FieldRef<"User", 'Boolean'>
    readonly mfaSecret: FieldRef<"User", 'String'>
    readonly mfaMethod: FieldRef<"User", 'MfaMethod'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.ownedPasswords
   */
  export type User$ownedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    cursor?: PasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * User.sharedPasswords
   */
  export type User$sharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    cursor?: PasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.threatEvents
   */
  export type User$threatEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    where?: ThreatEventWhereInput
    orderBy?: ThreatEventOrderByWithRelationInput | ThreatEventOrderByWithRelationInput[]
    cursor?: ThreatEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreatEventScalarFieldEnum | ThreatEventScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.mfaCredentials
   */
  export type User$mfaCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    where?: MfaCredentialWhereInput
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    cursor?: MfaCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * User.recoveryCodes
   */
  export type User$recoveryCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    where?: RecoveryCodeWhereInput
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    cursor?: RecoveryCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * User.passwordHistory
   */
  export type User$passwordHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    cursor?: PasswordHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * User.passwordBreachesChecked
   */
  export type User$passwordBreachesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    cursor?: PasswordBreachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * User.passwordBreachesResolved
   */
  export type User$passwordBreachesResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    cursor?: PasswordBreachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * User.rotationPolicies
   */
  export type User$rotationPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    where?: PasswordRotationPolicyWhereInput
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    cursor?: PasswordRotationPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * User.passwordRotations
   */
  export type User$passwordRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    cursor?: PasswordRotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * User.temporaryPasswordShares
   */
  export type User$temporaryPasswordSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    where?: TemporaryPasswordShareWhereInput
    orderBy?: TemporaryPasswordShareOrderByWithRelationInput | TemporaryPasswordShareOrderByWithRelationInput[]
    cursor?: TemporaryPasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemporaryPasswordShareScalarFieldEnum | TemporaryPasswordShareScalarFieldEnum[]
  }

  /**
   * User.savedSearches
   */
  export type User$savedSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    where?: SavedSearchWhereInput
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    cursor?: SavedSearchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * User.searchHistory
   */
  export type User$searchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * User.passwordTemplates
   */
  export type User$passwordTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    where?: PasswordTemplateWhereInput
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    cursor?: PasswordTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.reportTemplates
   */
  export type User$reportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    cursor?: ReportTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * User.scheduledReports
   */
  export type User$scheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.createdRoles
   */
  export type User$createdRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * User.dataExports
   */
  export type User$dataExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    where?: DataExportWhereInput
    orderBy?: DataExportOrderByWithRelationInput | DataExportOrderByWithRelationInput[]
    cursor?: DataExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataExportScalarFieldEnum | DataExportScalarFieldEnum[]
  }

  /**
   * User.dataDeletionRequests
   */
  export type User$dataDeletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    where?: DataDeletionRequestWhereInput
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    cursor?: DataDeletionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * User.processedDeletions
   */
  export type User$processedDeletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    where?: DataDeletionRequestWhereInput
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    cursor?: DataDeletionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * User.auditLogArchives
   */
  export type User$auditLogArchivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    where?: AuditLogArchiveWhereInput
    orderBy?: AuditLogArchiveOrderByWithRelationInput | AuditLogArchiveOrderByWithRelationInput[]
    cursor?: AuditLogArchiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogArchiveScalarFieldEnum | AuditLogArchiveScalarFieldEnum[]
  }

  /**
   * User.auditLogSearches
   */
  export type User$auditLogSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    where?: AuditLogSearchWhereInput
    orderBy?: AuditLogSearchOrderByWithRelationInput | AuditLogSearchOrderByWithRelationInput[]
    cursor?: AuditLogSearchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogSearchScalarFieldEnum | AuditLogSearchScalarFieldEnum[]
  }

  /**
   * User.emailVerificationTokens
   */
  export type User$emailVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    where?: EmailVerificationTokenWhereInput
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    cursor?: EmailVerificationTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.securityQuestions
   */
  export type User$securityQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    where?: SecurityQuestionWhereInput
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    cursor?: SecurityQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * User.ipWhitelists
   */
  export type User$ipWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    where?: IpWhitelistWhereInput
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    cursor?: IpWhitelistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * User.geographicRestrictions
   */
  export type User$geographicRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    where?: GeographicRestrictionWhereInput
    orderBy?: GeographicRestrictionOrderByWithRelationInput | GeographicRestrictionOrderByWithRelationInput[]
    cursor?: GeographicRestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeographicRestrictionScalarFieldEnum | GeographicRestrictionScalarFieldEnum[]
  }

  /**
   * User.createdIpWhitelists
   */
  export type User$createdIpWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    where?: IpWhitelistWhereInput
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    cursor?: IpWhitelistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * User.createdGeographicRestrictions
   */
  export type User$createdGeographicRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    where?: GeographicRestrictionWhereInput
    orderBy?: GeographicRestrictionOrderByWithRelationInput | GeographicRestrictionOrderByWithRelationInput[]
    cursor?: GeographicRestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeographicRestrictionScalarFieldEnum | GeographicRestrictionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceName: string | null
    deviceType: string | null
    deviceFingerprint: string | null
    isTrusted: boolean | null
    requireMfa: boolean | null
    lastActiveAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceName: string | null
    deviceType: string | null
    deviceFingerprint: string | null
    isTrusted: boolean | null
    requireMfa: boolean | null
    lastActiveAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    ipAddress: number
    userAgent: number
    deviceName: number
    deviceType: number
    deviceFingerprint: number
    isTrusted: number
    requireMfa: number
    lastActiveAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    deviceName?: true
    deviceType?: true
    deviceFingerprint?: true
    isTrusted?: true
    requireMfa?: true
    lastActiveAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    deviceName?: true
    deviceType?: true
    deviceFingerprint?: true
    isTrusted?: true
    requireMfa?: true
    lastActiveAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    deviceName?: true
    deviceType?: true
    deviceFingerprint?: true
    isTrusted?: true
    requireMfa?: true
    lastActiveAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    ipAddress: string | null
    userAgent: string | null
    deviceName: string | null
    deviceType: string | null
    deviceFingerprint: string | null
    isTrusted: boolean
    requireMfa: boolean
    lastActiveAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    deviceFingerprint?: boolean
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    deviceFingerprint?: boolean
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    deviceFingerprint?: boolean
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    deviceFingerprint?: boolean
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "ipAddress" | "userAgent" | "deviceName" | "deviceType" | "deviceFingerprint" | "isTrusted" | "requireMfa" | "lastActiveAt" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      ipAddress: string | null
      userAgent: string | null
      deviceName: string | null
      deviceType: string | null
      deviceFingerprint: string | null
      isTrusted: boolean
      requireMfa: boolean
      lastActiveAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly deviceName: FieldRef<"Session", 'String'>
    readonly deviceType: FieldRef<"Session", 'String'>
    readonly deviceFingerprint: FieldRef<"Session", 'String'>
    readonly isTrusted: FieldRef<"Session", 'Boolean'>
    readonly requireMfa: FieldRef<"Session", 'Boolean'>
    readonly lastActiveAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Password
   */

  export type AggregatePassword = {
    _count: PasswordCountAggregateOutputType | null
    _min: PasswordMinAggregateOutputType | null
    _max: PasswordMaxAggregateOutputType | null
  }

  export type PasswordMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    isFavorite: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rotationPolicyId: string | null
  }

  export type PasswordMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    isFavorite: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rotationPolicyId: string | null
  }

  export type PasswordCountAggregateOutputType = {
    id: number
    name: number
    username: number
    password: number
    url: number
    notes: number
    folderId: number
    strength: number
    hasTotp: number
    totpSecret: number
    expiresAt: number
    isFavorite: number
    ownerId: number
    createdAt: number
    updatedAt: number
    rotationPolicyId: number
    _all: number
  }


  export type PasswordMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    isFavorite?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    rotationPolicyId?: true
  }

  export type PasswordMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    isFavorite?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    rotationPolicyId?: true
  }

  export type PasswordCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    isFavorite?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    rotationPolicyId?: true
    _all?: true
  }

  export type PasswordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Password to aggregate.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passwords
    **/
    _count?: true | PasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordMaxAggregateInputType
  }

  export type GetPasswordAggregateType<T extends PasswordAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword[P]>
      : GetScalarType<T[P], AggregatePassword[P]>
  }




  export type PasswordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithAggregationInput | PasswordOrderByWithAggregationInput[]
    by: PasswordScalarFieldEnum[] | PasswordScalarFieldEnum
    having?: PasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordCountAggregateInputType | true
    _min?: PasswordMinAggregateInputType
    _max?: PasswordMaxAggregateInputType
  }

  export type PasswordGroupByOutputType = {
    id: string
    name: string
    username: string
    password: string
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret: string | null
    expiresAt: Date | null
    isFavorite: boolean
    ownerId: string
    createdAt: Date
    updatedAt: Date
    rotationPolicyId: string | null
    _count: PasswordCountAggregateOutputType | null
    _min: PasswordMinAggregateOutputType | null
    _max: PasswordMaxAggregateOutputType | null
  }

  type GetPasswordGroupByPayload<T extends PasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordGroupByOutputType[P]>
        }
      >
    >


  export type PasswordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    sharedWith?: boolean | Password$sharedWithArgs<ExtArgs>
    temporaryShares?: boolean | Password$temporarySharesArgs<ExtArgs>
    tags?: boolean | Password$tagsArgs<ExtArgs>
    history?: boolean | Password$historyArgs<ExtArgs>
    breaches?: boolean | Password$breachesArgs<ExtArgs>
    rotations?: boolean | Password$rotationsArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
    _count?: boolean | PasswordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
  }

  export type PasswordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "password" | "url" | "notes" | "folderId" | "strength" | "hasTotp" | "totpSecret" | "expiresAt" | "isFavorite" | "ownerId" | "createdAt" | "updatedAt" | "rotationPolicyId", ExtArgs["result"]["password"]>
  export type PasswordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    sharedWith?: boolean | Password$sharedWithArgs<ExtArgs>
    temporaryShares?: boolean | Password$temporarySharesArgs<ExtArgs>
    tags?: boolean | Password$tagsArgs<ExtArgs>
    history?: boolean | Password$historyArgs<ExtArgs>
    breaches?: boolean | Password$breachesArgs<ExtArgs>
    rotations?: boolean | Password$rotationsArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
    _count?: boolean | PasswordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PasswordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }
  export type PasswordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }

  export type $PasswordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Password"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      folder: Prisma.$FolderPayload<ExtArgs> | null
      sharedWith: Prisma.$PasswordSharePayload<ExtArgs>[]
      temporaryShares: Prisma.$TemporaryPasswordSharePayload<ExtArgs>[]
      tags: Prisma.$PasswordTagPayload<ExtArgs>[]
      history: Prisma.$PasswordHistoryPayload<ExtArgs>[]
      breaches: Prisma.$PasswordBreachPayload<ExtArgs>[]
      rotations: Prisma.$PasswordRotationPayload<ExtArgs>[]
      rotationPolicy: Prisma.$PasswordRotationPolicyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      password: string
      url: string | null
      notes: string | null
      folderId: string | null
      strength: $Enums.PasswordStrength
      hasTotp: boolean
      totpSecret: string | null
      expiresAt: Date | null
      isFavorite: boolean
      ownerId: string
      createdAt: Date
      updatedAt: Date
      rotationPolicyId: string | null
    }, ExtArgs["result"]["password"]>
    composites: {}
  }

  type PasswordGetPayload<S extends boolean | null | undefined | PasswordDefaultArgs> = $Result.GetResult<Prisma.$PasswordPayload, S>

  type PasswordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordCountAggregateInputType | true
    }

  export interface PasswordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Password'], meta: { name: 'Password' } }
    /**
     * Find zero or one Password that matches the filter.
     * @param {PasswordFindUniqueArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordFindUniqueArgs>(args: SelectSubset<T, PasswordFindUniqueArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordFindUniqueOrThrowArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindFirstArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordFindFirstArgs>(args?: SelectSubset<T, PasswordFindFirstArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindFirstOrThrowArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passwords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passwords
     * const passwords = await prisma.password.findMany()
     * 
     * // Get first 10 Passwords
     * const passwords = await prisma.password.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordWithIdOnly = await prisma.password.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordFindManyArgs>(args?: SelectSubset<T, PasswordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password.
     * @param {PasswordCreateArgs} args - Arguments to create a Password.
     * @example
     * // Create one Password
     * const Password = await prisma.password.create({
     *   data: {
     *     // ... data to create a Password
     *   }
     * })
     * 
     */
    create<T extends PasswordCreateArgs>(args: SelectSubset<T, PasswordCreateArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passwords.
     * @param {PasswordCreateManyArgs} args - Arguments to create many Passwords.
     * @example
     * // Create many Passwords
     * const password = await prisma.password.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordCreateManyArgs>(args?: SelectSubset<T, PasswordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passwords and returns the data saved in the database.
     * @param {PasswordCreateManyAndReturnArgs} args - Arguments to create many Passwords.
     * @example
     * // Create many Passwords
     * const password = await prisma.password.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passwords and only return the `id`
     * const passwordWithIdOnly = await prisma.password.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Password.
     * @param {PasswordDeleteArgs} args - Arguments to delete one Password.
     * @example
     * // Delete one Password
     * const Password = await prisma.password.delete({
     *   where: {
     *     // ... filter to delete one Password
     *   }
     * })
     * 
     */
    delete<T extends PasswordDeleteArgs>(args: SelectSubset<T, PasswordDeleteArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password.
     * @param {PasswordUpdateArgs} args - Arguments to update one Password.
     * @example
     * // Update one Password
     * const password = await prisma.password.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordUpdateArgs>(args: SelectSubset<T, PasswordUpdateArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passwords.
     * @param {PasswordDeleteManyArgs} args - Arguments to filter Passwords to delete.
     * @example
     * // Delete a few Passwords
     * const { count } = await prisma.password.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordDeleteManyArgs>(args?: SelectSubset<T, PasswordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passwords
     * const password = await prisma.password.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordUpdateManyArgs>(args: SelectSubset<T, PasswordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passwords and returns the data updated in the database.
     * @param {PasswordUpdateManyAndReturnArgs} args - Arguments to update many Passwords.
     * @example
     * // Update many Passwords
     * const password = await prisma.password.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passwords and only return the `id`
     * const passwordWithIdOnly = await prisma.password.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Password.
     * @param {PasswordUpsertArgs} args - Arguments to update or create a Password.
     * @example
     * // Update or create a Password
     * const password = await prisma.password.upsert({
     *   create: {
     *     // ... data to create a Password
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password we want to update
     *   }
     * })
     */
    upsert<T extends PasswordUpsertArgs>(args: SelectSubset<T, PasswordUpsertArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordCountArgs} args - Arguments to filter Passwords to count.
     * @example
     * // Count the number of Passwords
     * const count = await prisma.password.count({
     *   where: {
     *     // ... the filter for the Passwords we want to count
     *   }
     * })
    **/
    count<T extends PasswordCountArgs>(
      args?: Subset<T, PasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordAggregateArgs>(args: Subset<T, PasswordAggregateArgs>): Prisma.PrismaPromise<GetPasswordAggregateType<T>>

    /**
     * Group by Password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordGroupByArgs['orderBy'] }
        : { orderBy?: PasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Password model
   */
  readonly fields: PasswordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Password.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends Password$folderArgs<ExtArgs> = {}>(args?: Subset<T, Password$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sharedWith<T extends Password$sharedWithArgs<ExtArgs> = {}>(args?: Subset<T, Password$sharedWithArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    temporaryShares<T extends Password$temporarySharesArgs<ExtArgs> = {}>(args?: Subset<T, Password$temporarySharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Password$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Password$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends Password$historyArgs<ExtArgs> = {}>(args?: Subset<T, Password$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    breaches<T extends Password$breachesArgs<ExtArgs> = {}>(args?: Subset<T, Password$breachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotations<T extends Password$rotationsArgs<ExtArgs> = {}>(args?: Subset<T, Password$rotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotationPolicy<T extends Password$rotationPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Password$rotationPolicyArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Password model
   */
  interface PasswordFieldRefs {
    readonly id: FieldRef<"Password", 'String'>
    readonly name: FieldRef<"Password", 'String'>
    readonly username: FieldRef<"Password", 'String'>
    readonly password: FieldRef<"Password", 'String'>
    readonly url: FieldRef<"Password", 'String'>
    readonly notes: FieldRef<"Password", 'String'>
    readonly folderId: FieldRef<"Password", 'String'>
    readonly strength: FieldRef<"Password", 'PasswordStrength'>
    readonly hasTotp: FieldRef<"Password", 'Boolean'>
    readonly totpSecret: FieldRef<"Password", 'String'>
    readonly expiresAt: FieldRef<"Password", 'DateTime'>
    readonly isFavorite: FieldRef<"Password", 'Boolean'>
    readonly ownerId: FieldRef<"Password", 'String'>
    readonly createdAt: FieldRef<"Password", 'DateTime'>
    readonly updatedAt: FieldRef<"Password", 'DateTime'>
    readonly rotationPolicyId: FieldRef<"Password", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Password findUnique
   */
  export type PasswordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password findUniqueOrThrow
   */
  export type PasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password findFirst
   */
  export type PasswordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passwords.
     */
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password findFirstOrThrow
   */
  export type PasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passwords.
     */
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password findMany
   */
  export type PasswordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Passwords to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password create
   */
  export type PasswordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * The data needed to create a Password.
     */
    data: XOR<PasswordCreateInput, PasswordUncheckedCreateInput>
  }

  /**
   * Password createMany
   */
  export type PasswordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passwords.
     */
    data: PasswordCreateManyInput | PasswordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Password createManyAndReturn
   */
  export type PasswordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data used to create many Passwords.
     */
    data: PasswordCreateManyInput | PasswordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Password update
   */
  export type PasswordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * The data needed to update a Password.
     */
    data: XOR<PasswordUpdateInput, PasswordUncheckedUpdateInput>
    /**
     * Choose, which Password to update.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password updateMany
   */
  export type PasswordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passwords.
     */
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyInput>
    /**
     * Filter which Passwords to update
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to update.
     */
    limit?: number
  }

  /**
   * Password updateManyAndReturn
   */
  export type PasswordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data used to update Passwords.
     */
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyInput>
    /**
     * Filter which Passwords to update
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Password upsert
   */
  export type PasswordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * The filter to search for the Password to update in case it exists.
     */
    where: PasswordWhereUniqueInput
    /**
     * In case the Password found by the `where` argument doesn't exist, create a new Password with this data.
     */
    create: XOR<PasswordCreateInput, PasswordUncheckedCreateInput>
    /**
     * In case the Password was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordUpdateInput, PasswordUncheckedUpdateInput>
  }

  /**
   * Password delete
   */
  export type PasswordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter which Password to delete.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password deleteMany
   */
  export type PasswordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passwords to delete
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to delete.
     */
    limit?: number
  }

  /**
   * Password.folder
   */
  export type Password$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Password.sharedWith
   */
  export type Password$sharedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    cursor?: PasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * Password.temporaryShares
   */
  export type Password$temporarySharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    where?: TemporaryPasswordShareWhereInput
    orderBy?: TemporaryPasswordShareOrderByWithRelationInput | TemporaryPasswordShareOrderByWithRelationInput[]
    cursor?: TemporaryPasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemporaryPasswordShareScalarFieldEnum | TemporaryPasswordShareScalarFieldEnum[]
  }

  /**
   * Password.tags
   */
  export type Password$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    where?: PasswordTagWhereInput
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    cursor?: PasswordTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * Password.history
   */
  export type Password$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    cursor?: PasswordHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * Password.breaches
   */
  export type Password$breachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    cursor?: PasswordBreachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * Password.rotations
   */
  export type Password$rotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    cursor?: PasswordRotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * Password.rotationPolicy
   */
  export type Password$rotationPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    where?: PasswordRotationPolicyWhereInput
  }

  /**
   * Password without action
   */
  export type PasswordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
  }


  /**
   * Model PasswordHistory
   */

  export type AggregatePasswordHistory = {
    _count: PasswordHistoryCountAggregateOutputType | null
    _min: PasswordHistoryMinAggregateOutputType | null
    _max: PasswordHistoryMaxAggregateOutputType | null
  }

  export type PasswordHistoryMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    changedBy: string | null
    changeType: string | null
    createdAt: Date | null
  }

  export type PasswordHistoryMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    changedBy: string | null
    changeType: string | null
    createdAt: Date | null
  }

  export type PasswordHistoryCountAggregateOutputType = {
    id: number
    passwordId: number
    name: number
    username: number
    password: number
    url: number
    notes: number
    folderId: number
    strength: number
    hasTotp: number
    totpSecret: number
    expiresAt: number
    changedBy: number
    changeType: number
    createdAt: number
    _all: number
  }


  export type PasswordHistoryMinAggregateInputType = {
    id?: true
    passwordId?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
  }

  export type PasswordHistoryMaxAggregateInputType = {
    id?: true
    passwordId?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
  }

  export type PasswordHistoryCountAggregateInputType = {
    id?: true
    passwordId?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistory to aggregate.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordHistories
    **/
    _count?: true | PasswordHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordHistoryMaxAggregateInputType
  }

  export type GetPasswordHistoryAggregateType<T extends PasswordHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordHistory[P]>
      : GetScalarType<T[P], AggregatePasswordHistory[P]>
  }




  export type PasswordHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithAggregationInput | PasswordHistoryOrderByWithAggregationInput[]
    by: PasswordHistoryScalarFieldEnum[] | PasswordHistoryScalarFieldEnum
    having?: PasswordHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordHistoryCountAggregateInputType | true
    _min?: PasswordHistoryMinAggregateInputType
    _max?: PasswordHistoryMaxAggregateInputType
  }

  export type PasswordHistoryGroupByOutputType = {
    id: string
    passwordId: string
    name: string
    username: string
    password: string
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret: string | null
    expiresAt: Date | null
    changedBy: string
    changeType: string
    createdAt: Date
    _count: PasswordHistoryCountAggregateOutputType | null
    _min: PasswordHistoryMinAggregateOutputType | null
    _max: PasswordHistoryMaxAggregateOutputType | null
  }

  type GetPasswordHistoryGroupByPayload<T extends PasswordHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PasswordHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectScalar = {
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
  }

  export type PasswordHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "name" | "username" | "password" | "url" | "notes" | "folderId" | "strength" | "hasTotp" | "totpSecret" | "expiresAt" | "changedBy" | "changeType" | "createdAt", ExtArgs["result"]["passwordHistory"]>
  export type PasswordHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordHistory"
    objects: {
      passwordEntry: Prisma.$PasswordPayload<ExtArgs>
      changedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      name: string
      username: string
      password: string
      url: string | null
      notes: string | null
      folderId: string | null
      strength: $Enums.PasswordStrength
      hasTotp: boolean
      totpSecret: string | null
      expiresAt: Date | null
      changedBy: string
      changeType: string
      createdAt: Date
    }, ExtArgs["result"]["passwordHistory"]>
    composites: {}
  }

  type PasswordHistoryGetPayload<S extends boolean | null | undefined | PasswordHistoryDefaultArgs> = $Result.GetResult<Prisma.$PasswordHistoryPayload, S>

  type PasswordHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordHistoryCountAggregateInputType | true
    }

  export interface PasswordHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordHistory'], meta: { name: 'PasswordHistory' } }
    /**
     * Find zero or one PasswordHistory that matches the filter.
     * @param {PasswordHistoryFindUniqueArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordHistoryFindUniqueArgs>(args: SelectSubset<T, PasswordHistoryFindUniqueArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordHistoryFindUniqueOrThrowArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindFirstArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordHistoryFindFirstArgs>(args?: SelectSubset<T, PasswordHistoryFindFirstArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindFirstOrThrowArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordHistories
     * const passwordHistories = await prisma.passwordHistory.findMany()
     * 
     * // Get first 10 PasswordHistories
     * const passwordHistories = await prisma.passwordHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordHistoryFindManyArgs>(args?: SelectSubset<T, PasswordHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordHistory.
     * @param {PasswordHistoryCreateArgs} args - Arguments to create a PasswordHistory.
     * @example
     * // Create one PasswordHistory
     * const PasswordHistory = await prisma.passwordHistory.create({
     *   data: {
     *     // ... data to create a PasswordHistory
     *   }
     * })
     * 
     */
    create<T extends PasswordHistoryCreateArgs>(args: SelectSubset<T, PasswordHistoryCreateArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordHistories.
     * @param {PasswordHistoryCreateManyArgs} args - Arguments to create many PasswordHistories.
     * @example
     * // Create many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordHistoryCreateManyArgs>(args?: SelectSubset<T, PasswordHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordHistories and returns the data saved in the database.
     * @param {PasswordHistoryCreateManyAndReturnArgs} args - Arguments to create many PasswordHistories.
     * @example
     * // Create many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordHistories and only return the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordHistory.
     * @param {PasswordHistoryDeleteArgs} args - Arguments to delete one PasswordHistory.
     * @example
     * // Delete one PasswordHistory
     * const PasswordHistory = await prisma.passwordHistory.delete({
     *   where: {
     *     // ... filter to delete one PasswordHistory
     *   }
     * })
     * 
     */
    delete<T extends PasswordHistoryDeleteArgs>(args: SelectSubset<T, PasswordHistoryDeleteArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordHistory.
     * @param {PasswordHistoryUpdateArgs} args - Arguments to update one PasswordHistory.
     * @example
     * // Update one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordHistoryUpdateArgs>(args: SelectSubset<T, PasswordHistoryUpdateArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordHistories.
     * @param {PasswordHistoryDeleteManyArgs} args - Arguments to filter PasswordHistories to delete.
     * @example
     * // Delete a few PasswordHistories
     * const { count } = await prisma.passwordHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordHistoryDeleteManyArgs>(args?: SelectSubset<T, PasswordHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordHistoryUpdateManyArgs>(args: SelectSubset<T, PasswordHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordHistories and returns the data updated in the database.
     * @param {PasswordHistoryUpdateManyAndReturnArgs} args - Arguments to update many PasswordHistories.
     * @example
     * // Update many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordHistories and only return the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordHistory.
     * @param {PasswordHistoryUpsertArgs} args - Arguments to update or create a PasswordHistory.
     * @example
     * // Update or create a PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.upsert({
     *   create: {
     *     // ... data to create a PasswordHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordHistory we want to update
     *   }
     * })
     */
    upsert<T extends PasswordHistoryUpsertArgs>(args: SelectSubset<T, PasswordHistoryUpsertArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryCountArgs} args - Arguments to filter PasswordHistories to count.
     * @example
     * // Count the number of PasswordHistories
     * const count = await prisma.passwordHistory.count({
     *   where: {
     *     // ... the filter for the PasswordHistories we want to count
     *   }
     * })
    **/
    count<T extends PasswordHistoryCountArgs>(
      args?: Subset<T, PasswordHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordHistoryAggregateArgs>(args: Subset<T, PasswordHistoryAggregateArgs>): Prisma.PrismaPromise<GetPasswordHistoryAggregateType<T>>

    /**
     * Group by PasswordHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PasswordHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordHistory model
   */
  readonly fields: PasswordHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passwordEntry<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordHistory model
   */
  interface PasswordHistoryFieldRefs {
    readonly id: FieldRef<"PasswordHistory", 'String'>
    readonly passwordId: FieldRef<"PasswordHistory", 'String'>
    readonly name: FieldRef<"PasswordHistory", 'String'>
    readonly username: FieldRef<"PasswordHistory", 'String'>
    readonly password: FieldRef<"PasswordHistory", 'String'>
    readonly url: FieldRef<"PasswordHistory", 'String'>
    readonly notes: FieldRef<"PasswordHistory", 'String'>
    readonly folderId: FieldRef<"PasswordHistory", 'String'>
    readonly strength: FieldRef<"PasswordHistory", 'PasswordStrength'>
    readonly hasTotp: FieldRef<"PasswordHistory", 'Boolean'>
    readonly totpSecret: FieldRef<"PasswordHistory", 'String'>
    readonly expiresAt: FieldRef<"PasswordHistory", 'DateTime'>
    readonly changedBy: FieldRef<"PasswordHistory", 'String'>
    readonly changeType: FieldRef<"PasswordHistory", 'String'>
    readonly createdAt: FieldRef<"PasswordHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordHistory findUnique
   */
  export type PasswordHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory findUniqueOrThrow
   */
  export type PasswordHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory findFirst
   */
  export type PasswordHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistories.
     */
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory findFirstOrThrow
   */
  export type PasswordHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistories.
     */
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory findMany
   */
  export type PasswordHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistories to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory create
   */
  export type PasswordHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordHistory.
     */
    data: XOR<PasswordHistoryCreateInput, PasswordHistoryUncheckedCreateInput>
  }

  /**
   * PasswordHistory createMany
   */
  export type PasswordHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordHistories.
     */
    data: PasswordHistoryCreateManyInput | PasswordHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordHistory createManyAndReturn
   */
  export type PasswordHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordHistories.
     */
    data: PasswordHistoryCreateManyInput | PasswordHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordHistory update
   */
  export type PasswordHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordHistory.
     */
    data: XOR<PasswordHistoryUpdateInput, PasswordHistoryUncheckedUpdateInput>
    /**
     * Choose, which PasswordHistory to update.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory updateMany
   */
  export type PasswordHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordHistories.
     */
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PasswordHistories to update
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to update.
     */
    limit?: number
  }

  /**
   * PasswordHistory updateManyAndReturn
   */
  export type PasswordHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PasswordHistories.
     */
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PasswordHistories to update
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordHistory upsert
   */
  export type PasswordHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordHistory to update in case it exists.
     */
    where: PasswordHistoryWhereUniqueInput
    /**
     * In case the PasswordHistory found by the `where` argument doesn't exist, create a new PasswordHistory with this data.
     */
    create: XOR<PasswordHistoryCreateInput, PasswordHistoryUncheckedCreateInput>
    /**
     * In case the PasswordHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordHistoryUpdateInput, PasswordHistoryUncheckedUpdateInput>
  }

  /**
   * PasswordHistory delete
   */
  export type PasswordHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter which PasswordHistory to delete.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory deleteMany
   */
  export type PasswordHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistories to delete
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to delete.
     */
    limit?: number
  }

  /**
   * PasswordHistory without action
   */
  export type PasswordHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PasswordBreach
   */

  export type AggregatePasswordBreach = {
    _count: PasswordBreachCountAggregateOutputType | null
    _avg: PasswordBreachAvgAggregateOutputType | null
    _sum: PasswordBreachSumAggregateOutputType | null
    _min: PasswordBreachMinAggregateOutputType | null
    _max: PasswordBreachMaxAggregateOutputType | null
  }

  export type PasswordBreachAvgAggregateOutputType = {
    breachCount: number | null
  }

  export type PasswordBreachSumAggregateOutputType = {
    breachCount: number | null
  }

  export type PasswordBreachMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    isBreached: boolean | null
    breachCount: number | null
    hashPrefix: string | null
    checkedAt: Date | null
    checkedBy: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type PasswordBreachMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    isBreached: boolean | null
    breachCount: number | null
    hashPrefix: string | null
    checkedAt: Date | null
    checkedBy: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type PasswordBreachCountAggregateOutputType = {
    id: number
    passwordId: number
    isBreached: number
    breachCount: number
    hashPrefix: number
    checkedAt: number
    checkedBy: number
    resolved: number
    resolvedAt: number
    resolvedBy: number
    _all: number
  }


  export type PasswordBreachAvgAggregateInputType = {
    breachCount?: true
  }

  export type PasswordBreachSumAggregateInputType = {
    breachCount?: true
  }

  export type PasswordBreachMinAggregateInputType = {
    id?: true
    passwordId?: true
    isBreached?: true
    breachCount?: true
    hashPrefix?: true
    checkedAt?: true
    checkedBy?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type PasswordBreachMaxAggregateInputType = {
    id?: true
    passwordId?: true
    isBreached?: true
    breachCount?: true
    hashPrefix?: true
    checkedAt?: true
    checkedBy?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type PasswordBreachCountAggregateInputType = {
    id?: true
    passwordId?: true
    isBreached?: true
    breachCount?: true
    hashPrefix?: true
    checkedAt?: true
    checkedBy?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    _all?: true
  }

  export type PasswordBreachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordBreach to aggregate.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordBreaches
    **/
    _count?: true | PasswordBreachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordBreachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordBreachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordBreachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordBreachMaxAggregateInputType
  }

  export type GetPasswordBreachAggregateType<T extends PasswordBreachAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordBreach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordBreach[P]>
      : GetScalarType<T[P], AggregatePasswordBreach[P]>
  }




  export type PasswordBreachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithAggregationInput | PasswordBreachOrderByWithAggregationInput[]
    by: PasswordBreachScalarFieldEnum[] | PasswordBreachScalarFieldEnum
    having?: PasswordBreachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordBreachCountAggregateInputType | true
    _avg?: PasswordBreachAvgAggregateInputType
    _sum?: PasswordBreachSumAggregateInputType
    _min?: PasswordBreachMinAggregateInputType
    _max?: PasswordBreachMaxAggregateInputType
  }

  export type PasswordBreachGroupByOutputType = {
    id: string
    passwordId: string
    isBreached: boolean
    breachCount: number
    hashPrefix: string
    checkedAt: Date
    checkedBy: string
    resolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    _count: PasswordBreachCountAggregateOutputType | null
    _avg: PasswordBreachAvgAggregateOutputType | null
    _sum: PasswordBreachSumAggregateOutputType | null
    _min: PasswordBreachMinAggregateOutputType | null
    _max: PasswordBreachMaxAggregateOutputType | null
  }

  type GetPasswordBreachGroupByPayload<T extends PasswordBreachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordBreachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordBreachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordBreachGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordBreachGroupByOutputType[P]>
        }
      >
    >


  export type PasswordBreachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["passwordBreach"]>

  export type PasswordBreachSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["passwordBreach"]>

  export type PasswordBreachSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["passwordBreach"]>

  export type PasswordBreachSelectScalar = {
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
  }

  export type PasswordBreachOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "isBreached" | "breachCount" | "hashPrefix" | "checkedAt" | "checkedBy" | "resolved" | "resolvedAt" | "resolvedBy", ExtArgs["result"]["passwordBreach"]>
  export type PasswordBreachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }
  export type PasswordBreachIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }
  export type PasswordBreachIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }

  export type $PasswordBreachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordBreach"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      checkedByUser: Prisma.$UserPayload<ExtArgs>
      resolvedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      isBreached: boolean
      breachCount: number
      hashPrefix: string
      checkedAt: Date
      checkedBy: string
      resolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
    }, ExtArgs["result"]["passwordBreach"]>
    composites: {}
  }

  type PasswordBreachGetPayload<S extends boolean | null | undefined | PasswordBreachDefaultArgs> = $Result.GetResult<Prisma.$PasswordBreachPayload, S>

  type PasswordBreachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordBreachFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordBreachCountAggregateInputType | true
    }

  export interface PasswordBreachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordBreach'], meta: { name: 'PasswordBreach' } }
    /**
     * Find zero or one PasswordBreach that matches the filter.
     * @param {PasswordBreachFindUniqueArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordBreachFindUniqueArgs>(args: SelectSubset<T, PasswordBreachFindUniqueArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordBreach that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordBreachFindUniqueOrThrowArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordBreachFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordBreachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordBreach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachFindFirstArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordBreachFindFirstArgs>(args?: SelectSubset<T, PasswordBreachFindFirstArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordBreach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachFindFirstOrThrowArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordBreachFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordBreachFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordBreaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordBreaches
     * const passwordBreaches = await prisma.passwordBreach.findMany()
     * 
     * // Get first 10 PasswordBreaches
     * const passwordBreaches = await prisma.passwordBreach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordBreachWithIdOnly = await prisma.passwordBreach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordBreachFindManyArgs>(args?: SelectSubset<T, PasswordBreachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordBreach.
     * @param {PasswordBreachCreateArgs} args - Arguments to create a PasswordBreach.
     * @example
     * // Create one PasswordBreach
     * const PasswordBreach = await prisma.passwordBreach.create({
     *   data: {
     *     // ... data to create a PasswordBreach
     *   }
     * })
     * 
     */
    create<T extends PasswordBreachCreateArgs>(args: SelectSubset<T, PasswordBreachCreateArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordBreaches.
     * @param {PasswordBreachCreateManyArgs} args - Arguments to create many PasswordBreaches.
     * @example
     * // Create many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordBreachCreateManyArgs>(args?: SelectSubset<T, PasswordBreachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordBreaches and returns the data saved in the database.
     * @param {PasswordBreachCreateManyAndReturnArgs} args - Arguments to create many PasswordBreaches.
     * @example
     * // Create many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordBreaches and only return the `id`
     * const passwordBreachWithIdOnly = await prisma.passwordBreach.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordBreachCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordBreachCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordBreach.
     * @param {PasswordBreachDeleteArgs} args - Arguments to delete one PasswordBreach.
     * @example
     * // Delete one PasswordBreach
     * const PasswordBreach = await prisma.passwordBreach.delete({
     *   where: {
     *     // ... filter to delete one PasswordBreach
     *   }
     * })
     * 
     */
    delete<T extends PasswordBreachDeleteArgs>(args: SelectSubset<T, PasswordBreachDeleteArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordBreach.
     * @param {PasswordBreachUpdateArgs} args - Arguments to update one PasswordBreach.
     * @example
     * // Update one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordBreachUpdateArgs>(args: SelectSubset<T, PasswordBreachUpdateArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordBreaches.
     * @param {PasswordBreachDeleteManyArgs} args - Arguments to filter PasswordBreaches to delete.
     * @example
     * // Delete a few PasswordBreaches
     * const { count } = await prisma.passwordBreach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordBreachDeleteManyArgs>(args?: SelectSubset<T, PasswordBreachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordBreaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordBreachUpdateManyArgs>(args: SelectSubset<T, PasswordBreachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordBreaches and returns the data updated in the database.
     * @param {PasswordBreachUpdateManyAndReturnArgs} args - Arguments to update many PasswordBreaches.
     * @example
     * // Update many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordBreaches and only return the `id`
     * const passwordBreachWithIdOnly = await prisma.passwordBreach.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordBreachUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordBreachUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordBreach.
     * @param {PasswordBreachUpsertArgs} args - Arguments to update or create a PasswordBreach.
     * @example
     * // Update or create a PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.upsert({
     *   create: {
     *     // ... data to create a PasswordBreach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordBreach we want to update
     *   }
     * })
     */
    upsert<T extends PasswordBreachUpsertArgs>(args: SelectSubset<T, PasswordBreachUpsertArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordBreaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachCountArgs} args - Arguments to filter PasswordBreaches to count.
     * @example
     * // Count the number of PasswordBreaches
     * const count = await prisma.passwordBreach.count({
     *   where: {
     *     // ... the filter for the PasswordBreaches we want to count
     *   }
     * })
    **/
    count<T extends PasswordBreachCountArgs>(
      args?: Subset<T, PasswordBreachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordBreachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordBreach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordBreachAggregateArgs>(args: Subset<T, PasswordBreachAggregateArgs>): Prisma.PrismaPromise<GetPasswordBreachAggregateType<T>>

    /**
     * Group by PasswordBreach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordBreachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordBreachGroupByArgs['orderBy'] }
        : { orderBy?: PasswordBreachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordBreachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordBreachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordBreach model
   */
  readonly fields: PasswordBreachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordBreach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordBreachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checkedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resolvedByUser<T extends PasswordBreach$resolvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, PasswordBreach$resolvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordBreach model
   */
  interface PasswordBreachFieldRefs {
    readonly id: FieldRef<"PasswordBreach", 'String'>
    readonly passwordId: FieldRef<"PasswordBreach", 'String'>
    readonly isBreached: FieldRef<"PasswordBreach", 'Boolean'>
    readonly breachCount: FieldRef<"PasswordBreach", 'Int'>
    readonly hashPrefix: FieldRef<"PasswordBreach", 'String'>
    readonly checkedAt: FieldRef<"PasswordBreach", 'DateTime'>
    readonly checkedBy: FieldRef<"PasswordBreach", 'String'>
    readonly resolved: FieldRef<"PasswordBreach", 'Boolean'>
    readonly resolvedAt: FieldRef<"PasswordBreach", 'DateTime'>
    readonly resolvedBy: FieldRef<"PasswordBreach", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PasswordBreach findUnique
   */
  export type PasswordBreachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach findUniqueOrThrow
   */
  export type PasswordBreachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach findFirst
   */
  export type PasswordBreachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordBreaches.
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordBreaches.
     */
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * PasswordBreach findFirstOrThrow
   */
  export type PasswordBreachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordBreaches.
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordBreaches.
     */
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * PasswordBreach findMany
   */
  export type PasswordBreachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreaches to fetch.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordBreaches.
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * PasswordBreach create
   */
  export type PasswordBreachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordBreach.
     */
    data: XOR<PasswordBreachCreateInput, PasswordBreachUncheckedCreateInput>
  }

  /**
   * PasswordBreach createMany
   */
  export type PasswordBreachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordBreaches.
     */
    data: PasswordBreachCreateManyInput | PasswordBreachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordBreach createManyAndReturn
   */
  export type PasswordBreachCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordBreaches.
     */
    data: PasswordBreachCreateManyInput | PasswordBreachCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordBreach update
   */
  export type PasswordBreachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordBreach.
     */
    data: XOR<PasswordBreachUpdateInput, PasswordBreachUncheckedUpdateInput>
    /**
     * Choose, which PasswordBreach to update.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach updateMany
   */
  export type PasswordBreachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordBreaches.
     */
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyInput>
    /**
     * Filter which PasswordBreaches to update
     */
    where?: PasswordBreachWhereInput
    /**
     * Limit how many PasswordBreaches to update.
     */
    limit?: number
  }

  /**
   * PasswordBreach updateManyAndReturn
   */
  export type PasswordBreachUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * The data used to update PasswordBreaches.
     */
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyInput>
    /**
     * Filter which PasswordBreaches to update
     */
    where?: PasswordBreachWhereInput
    /**
     * Limit how many PasswordBreaches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordBreach upsert
   */
  export type PasswordBreachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordBreach to update in case it exists.
     */
    where: PasswordBreachWhereUniqueInput
    /**
     * In case the PasswordBreach found by the `where` argument doesn't exist, create a new PasswordBreach with this data.
     */
    create: XOR<PasswordBreachCreateInput, PasswordBreachUncheckedCreateInput>
    /**
     * In case the PasswordBreach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordBreachUpdateInput, PasswordBreachUncheckedUpdateInput>
  }

  /**
   * PasswordBreach delete
   */
  export type PasswordBreachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter which PasswordBreach to delete.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach deleteMany
   */
  export type PasswordBreachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordBreaches to delete
     */
    where?: PasswordBreachWhereInput
    /**
     * Limit how many PasswordBreaches to delete.
     */
    limit?: number
  }

  /**
   * PasswordBreach.resolvedByUser
   */
  export type PasswordBreach$resolvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PasswordBreach without action
   */
  export type PasswordBreachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
  }


  /**
   * Model PasswordRotationPolicy
   */

  export type AggregatePasswordRotationPolicy = {
    _count: PasswordRotationPolicyCountAggregateOutputType | null
    _avg: PasswordRotationPolicyAvgAggregateOutputType | null
    _sum: PasswordRotationPolicySumAggregateOutputType | null
    _min: PasswordRotationPolicyMinAggregateOutputType | null
    _max: PasswordRotationPolicyMaxAggregateOutputType | null
  }

  export type PasswordRotationPolicyAvgAggregateOutputType = {
    rotationDays: number | null
    reminderDays: number | null
  }

  export type PasswordRotationPolicySumAggregateOutputType = {
    rotationDays: number | null
    reminderDays: number | null
  }

  export type PasswordRotationPolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rotationDays: number | null
    reminderDays: number | null
    autoRotate: boolean | null
    requireApproval: boolean | null
    isActive: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordRotationPolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rotationDays: number | null
    reminderDays: number | null
    autoRotate: boolean | null
    requireApproval: boolean | null
    isActive: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordRotationPolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    rotationDays: number
    reminderDays: number
    autoRotate: number
    requireApproval: number
    isActive: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordRotationPolicyAvgAggregateInputType = {
    rotationDays?: true
    reminderDays?: true
  }

  export type PasswordRotationPolicySumAggregateInputType = {
    rotationDays?: true
    reminderDays?: true
  }

  export type PasswordRotationPolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rotationDays?: true
    reminderDays?: true
    autoRotate?: true
    requireApproval?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordRotationPolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rotationDays?: true
    reminderDays?: true
    autoRotate?: true
    requireApproval?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordRotationPolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rotationDays?: true
    reminderDays?: true
    autoRotate?: true
    requireApproval?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordRotationPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotationPolicy to aggregate.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordRotationPolicies
    **/
    _count?: true | PasswordRotationPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordRotationPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordRotationPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordRotationPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordRotationPolicyMaxAggregateInputType
  }

  export type GetPasswordRotationPolicyAggregateType<T extends PasswordRotationPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordRotationPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordRotationPolicy[P]>
      : GetScalarType<T[P], AggregatePasswordRotationPolicy[P]>
  }




  export type PasswordRotationPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationPolicyWhereInput
    orderBy?: PasswordRotationPolicyOrderByWithAggregationInput | PasswordRotationPolicyOrderByWithAggregationInput[]
    by: PasswordRotationPolicyScalarFieldEnum[] | PasswordRotationPolicyScalarFieldEnum
    having?: PasswordRotationPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordRotationPolicyCountAggregateInputType | true
    _avg?: PasswordRotationPolicyAvgAggregateInputType
    _sum?: PasswordRotationPolicySumAggregateInputType
    _min?: PasswordRotationPolicyMinAggregateInputType
    _max?: PasswordRotationPolicyMaxAggregateInputType
  }

  export type PasswordRotationPolicyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    rotationDays: number
    reminderDays: number
    autoRotate: boolean
    requireApproval: boolean
    isActive: boolean
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: PasswordRotationPolicyCountAggregateOutputType | null
    _avg: PasswordRotationPolicyAvgAggregateOutputType | null
    _sum: PasswordRotationPolicySumAggregateOutputType | null
    _min: PasswordRotationPolicyMinAggregateOutputType | null
    _max: PasswordRotationPolicyMaxAggregateOutputType | null
  }

  type GetPasswordRotationPolicyGroupByPayload<T extends PasswordRotationPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordRotationPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordRotationPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordRotationPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordRotationPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PasswordRotationPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    passwords?: boolean | PasswordRotationPolicy$passwordsArgs<ExtArgs>
    rotations?: boolean | PasswordRotationPolicy$rotationsArgs<ExtArgs>
    _count?: boolean | PasswordRotationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotationPolicy"]>

  export type PasswordRotationPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotationPolicy"]>

  export type PasswordRotationPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotationPolicy"]>

  export type PasswordRotationPolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordRotationPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "rotationDays" | "reminderDays" | "autoRotate" | "requireApproval" | "isActive" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordRotationPolicy"]>
  export type PasswordRotationPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    passwords?: boolean | PasswordRotationPolicy$passwordsArgs<ExtArgs>
    rotations?: boolean | PasswordRotationPolicy$rotationsArgs<ExtArgs>
    _count?: boolean | PasswordRotationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PasswordRotationPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordRotationPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordRotationPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordRotationPolicy"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      passwords: Prisma.$PasswordPayload<ExtArgs>[]
      rotations: Prisma.$PasswordRotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      rotationDays: number
      reminderDays: number
      autoRotate: boolean
      requireApproval: boolean
      isActive: boolean
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordRotationPolicy"]>
    composites: {}
  }

  type PasswordRotationPolicyGetPayload<S extends boolean | null | undefined | PasswordRotationPolicyDefaultArgs> = $Result.GetResult<Prisma.$PasswordRotationPolicyPayload, S>

  type PasswordRotationPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordRotationPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordRotationPolicyCountAggregateInputType | true
    }

  export interface PasswordRotationPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordRotationPolicy'], meta: { name: 'PasswordRotationPolicy' } }
    /**
     * Find zero or one PasswordRotationPolicy that matches the filter.
     * @param {PasswordRotationPolicyFindUniqueArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordRotationPolicyFindUniqueArgs>(args: SelectSubset<T, PasswordRotationPolicyFindUniqueArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordRotationPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordRotationPolicyFindUniqueOrThrowArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordRotationPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordRotationPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotationPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyFindFirstArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordRotationPolicyFindFirstArgs>(args?: SelectSubset<T, PasswordRotationPolicyFindFirstArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotationPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyFindFirstOrThrowArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordRotationPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordRotationPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordRotationPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordRotationPolicies
     * const passwordRotationPolicies = await prisma.passwordRotationPolicy.findMany()
     * 
     * // Get first 10 PasswordRotationPolicies
     * const passwordRotationPolicies = await prisma.passwordRotationPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordRotationPolicyWithIdOnly = await prisma.passwordRotationPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordRotationPolicyFindManyArgs>(args?: SelectSubset<T, PasswordRotationPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordRotationPolicy.
     * @param {PasswordRotationPolicyCreateArgs} args - Arguments to create a PasswordRotationPolicy.
     * @example
     * // Create one PasswordRotationPolicy
     * const PasswordRotationPolicy = await prisma.passwordRotationPolicy.create({
     *   data: {
     *     // ... data to create a PasswordRotationPolicy
     *   }
     * })
     * 
     */
    create<T extends PasswordRotationPolicyCreateArgs>(args: SelectSubset<T, PasswordRotationPolicyCreateArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordRotationPolicies.
     * @param {PasswordRotationPolicyCreateManyArgs} args - Arguments to create many PasswordRotationPolicies.
     * @example
     * // Create many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordRotationPolicyCreateManyArgs>(args?: SelectSubset<T, PasswordRotationPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordRotationPolicies and returns the data saved in the database.
     * @param {PasswordRotationPolicyCreateManyAndReturnArgs} args - Arguments to create many PasswordRotationPolicies.
     * @example
     * // Create many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordRotationPolicies and only return the `id`
     * const passwordRotationPolicyWithIdOnly = await prisma.passwordRotationPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordRotationPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordRotationPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordRotationPolicy.
     * @param {PasswordRotationPolicyDeleteArgs} args - Arguments to delete one PasswordRotationPolicy.
     * @example
     * // Delete one PasswordRotationPolicy
     * const PasswordRotationPolicy = await prisma.passwordRotationPolicy.delete({
     *   where: {
     *     // ... filter to delete one PasswordRotationPolicy
     *   }
     * })
     * 
     */
    delete<T extends PasswordRotationPolicyDeleteArgs>(args: SelectSubset<T, PasswordRotationPolicyDeleteArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordRotationPolicy.
     * @param {PasswordRotationPolicyUpdateArgs} args - Arguments to update one PasswordRotationPolicy.
     * @example
     * // Update one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordRotationPolicyUpdateArgs>(args: SelectSubset<T, PasswordRotationPolicyUpdateArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordRotationPolicies.
     * @param {PasswordRotationPolicyDeleteManyArgs} args - Arguments to filter PasswordRotationPolicies to delete.
     * @example
     * // Delete a few PasswordRotationPolicies
     * const { count } = await prisma.passwordRotationPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordRotationPolicyDeleteManyArgs>(args?: SelectSubset<T, PasswordRotationPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordRotationPolicyUpdateManyArgs>(args: SelectSubset<T, PasswordRotationPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotationPolicies and returns the data updated in the database.
     * @param {PasswordRotationPolicyUpdateManyAndReturnArgs} args - Arguments to update many PasswordRotationPolicies.
     * @example
     * // Update many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordRotationPolicies and only return the `id`
     * const passwordRotationPolicyWithIdOnly = await prisma.passwordRotationPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordRotationPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordRotationPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordRotationPolicy.
     * @param {PasswordRotationPolicyUpsertArgs} args - Arguments to update or create a PasswordRotationPolicy.
     * @example
     * // Update or create a PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.upsert({
     *   create: {
     *     // ... data to create a PasswordRotationPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordRotationPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PasswordRotationPolicyUpsertArgs>(args: SelectSubset<T, PasswordRotationPolicyUpsertArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordRotationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyCountArgs} args - Arguments to filter PasswordRotationPolicies to count.
     * @example
     * // Count the number of PasswordRotationPolicies
     * const count = await prisma.passwordRotationPolicy.count({
     *   where: {
     *     // ... the filter for the PasswordRotationPolicies we want to count
     *   }
     * })
    **/
    count<T extends PasswordRotationPolicyCountArgs>(
      args?: Subset<T, PasswordRotationPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordRotationPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordRotationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordRotationPolicyAggregateArgs>(args: Subset<T, PasswordRotationPolicyAggregateArgs>): Prisma.PrismaPromise<GetPasswordRotationPolicyAggregateType<T>>

    /**
     * Group by PasswordRotationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordRotationPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordRotationPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PasswordRotationPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordRotationPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordRotationPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordRotationPolicy model
   */
  readonly fields: PasswordRotationPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordRotationPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordRotationPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    passwords<T extends PasswordRotationPolicy$passwordsArgs<ExtArgs> = {}>(args?: Subset<T, PasswordRotationPolicy$passwordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotations<T extends PasswordRotationPolicy$rotationsArgs<ExtArgs> = {}>(args?: Subset<T, PasswordRotationPolicy$rotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordRotationPolicy model
   */
  interface PasswordRotationPolicyFieldRefs {
    readonly id: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly name: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly description: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly rotationDays: FieldRef<"PasswordRotationPolicy", 'Int'>
    readonly reminderDays: FieldRef<"PasswordRotationPolicy", 'Int'>
    readonly autoRotate: FieldRef<"PasswordRotationPolicy", 'Boolean'>
    readonly requireApproval: FieldRef<"PasswordRotationPolicy", 'Boolean'>
    readonly isActive: FieldRef<"PasswordRotationPolicy", 'Boolean'>
    readonly ownerId: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly createdAt: FieldRef<"PasswordRotationPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordRotationPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordRotationPolicy findUnique
   */
  export type PasswordRotationPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy findUniqueOrThrow
   */
  export type PasswordRotationPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy findFirst
   */
  export type PasswordRotationPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotationPolicies.
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotationPolicies.
     */
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy findFirstOrThrow
   */
  export type PasswordRotationPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotationPolicies.
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotationPolicies.
     */
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy findMany
   */
  export type PasswordRotationPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicies to fetch.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordRotationPolicies.
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy create
   */
  export type PasswordRotationPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordRotationPolicy.
     */
    data: XOR<PasswordRotationPolicyCreateInput, PasswordRotationPolicyUncheckedCreateInput>
  }

  /**
   * PasswordRotationPolicy createMany
   */
  export type PasswordRotationPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordRotationPolicies.
     */
    data: PasswordRotationPolicyCreateManyInput | PasswordRotationPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordRotationPolicy createManyAndReturn
   */
  export type PasswordRotationPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordRotationPolicies.
     */
    data: PasswordRotationPolicyCreateManyInput | PasswordRotationPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotationPolicy update
   */
  export type PasswordRotationPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordRotationPolicy.
     */
    data: XOR<PasswordRotationPolicyUpdateInput, PasswordRotationPolicyUncheckedUpdateInput>
    /**
     * Choose, which PasswordRotationPolicy to update.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy updateMany
   */
  export type PasswordRotationPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordRotationPolicies.
     */
    data: XOR<PasswordRotationPolicyUpdateManyMutationInput, PasswordRotationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotationPolicies to update
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * Limit how many PasswordRotationPolicies to update.
     */
    limit?: number
  }

  /**
   * PasswordRotationPolicy updateManyAndReturn
   */
  export type PasswordRotationPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * The data used to update PasswordRotationPolicies.
     */
    data: XOR<PasswordRotationPolicyUpdateManyMutationInput, PasswordRotationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotationPolicies to update
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * Limit how many PasswordRotationPolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotationPolicy upsert
   */
  export type PasswordRotationPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordRotationPolicy to update in case it exists.
     */
    where: PasswordRotationPolicyWhereUniqueInput
    /**
     * In case the PasswordRotationPolicy found by the `where` argument doesn't exist, create a new PasswordRotationPolicy with this data.
     */
    create: XOR<PasswordRotationPolicyCreateInput, PasswordRotationPolicyUncheckedCreateInput>
    /**
     * In case the PasswordRotationPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordRotationPolicyUpdateInput, PasswordRotationPolicyUncheckedUpdateInput>
  }

  /**
   * PasswordRotationPolicy delete
   */
  export type PasswordRotationPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter which PasswordRotationPolicy to delete.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy deleteMany
   */
  export type PasswordRotationPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotationPolicies to delete
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * Limit how many PasswordRotationPolicies to delete.
     */
    limit?: number
  }

  /**
   * PasswordRotationPolicy.passwords
   */
  export type PasswordRotationPolicy$passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    cursor?: PasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy.rotations
   */
  export type PasswordRotationPolicy$rotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    cursor?: PasswordRotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy without action
   */
  export type PasswordRotationPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
  }


  /**
   * Model PasswordRotation
   */

  export type AggregatePasswordRotation = {
    _count: PasswordRotationCountAggregateOutputType | null
    _min: PasswordRotationMinAggregateOutputType | null
    _max: PasswordRotationMaxAggregateOutputType | null
  }

  export type PasswordRotationMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    policyId: string | null
    rotationType: string | null
    oldPassword: string | null
    newPassword: string | null
    rotatedAt: Date | null
    rotatedBy: string | null
    scheduledFor: Date | null
    completedAt: Date | null
    status: string | null
    notes: string | null
  }

  export type PasswordRotationMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    policyId: string | null
    rotationType: string | null
    oldPassword: string | null
    newPassword: string | null
    rotatedAt: Date | null
    rotatedBy: string | null
    scheduledFor: Date | null
    completedAt: Date | null
    status: string | null
    notes: string | null
  }

  export type PasswordRotationCountAggregateOutputType = {
    id: number
    passwordId: number
    policyId: number
    rotationType: number
    oldPassword: number
    newPassword: number
    rotatedAt: number
    rotatedBy: number
    scheduledFor: number
    completedAt: number
    status: number
    notes: number
    _all: number
  }


  export type PasswordRotationMinAggregateInputType = {
    id?: true
    passwordId?: true
    policyId?: true
    rotationType?: true
    oldPassword?: true
    newPassword?: true
    rotatedAt?: true
    rotatedBy?: true
    scheduledFor?: true
    completedAt?: true
    status?: true
    notes?: true
  }

  export type PasswordRotationMaxAggregateInputType = {
    id?: true
    passwordId?: true
    policyId?: true
    rotationType?: true
    oldPassword?: true
    newPassword?: true
    rotatedAt?: true
    rotatedBy?: true
    scheduledFor?: true
    completedAt?: true
    status?: true
    notes?: true
  }

  export type PasswordRotationCountAggregateInputType = {
    id?: true
    passwordId?: true
    policyId?: true
    rotationType?: true
    oldPassword?: true
    newPassword?: true
    rotatedAt?: true
    rotatedBy?: true
    scheduledFor?: true
    completedAt?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type PasswordRotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotation to aggregate.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordRotations
    **/
    _count?: true | PasswordRotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordRotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordRotationMaxAggregateInputType
  }

  export type GetPasswordRotationAggregateType<T extends PasswordRotationAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordRotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordRotation[P]>
      : GetScalarType<T[P], AggregatePasswordRotation[P]>
  }




  export type PasswordRotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithAggregationInput | PasswordRotationOrderByWithAggregationInput[]
    by: PasswordRotationScalarFieldEnum[] | PasswordRotationScalarFieldEnum
    having?: PasswordRotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordRotationCountAggregateInputType | true
    _min?: PasswordRotationMinAggregateInputType
    _max?: PasswordRotationMaxAggregateInputType
  }

  export type PasswordRotationGroupByOutputType = {
    id: string
    passwordId: string
    policyId: string | null
    rotationType: string
    oldPassword: string | null
    newPassword: string
    rotatedAt: Date
    rotatedBy: string
    scheduledFor: Date | null
    completedAt: Date | null
    status: string
    notes: string | null
    _count: PasswordRotationCountAggregateOutputType | null
    _min: PasswordRotationMinAggregateOutputType | null
    _max: PasswordRotationMaxAggregateOutputType | null
  }

  type GetPasswordRotationGroupByPayload<T extends PasswordRotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordRotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordRotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordRotationGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordRotationGroupByOutputType[P]>
        }
      >
    >


  export type PasswordRotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotation"]>

  export type PasswordRotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotation"]>

  export type PasswordRotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotation"]>

  export type PasswordRotationSelectScalar = {
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
  }

  export type PasswordRotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "policyId" | "rotationType" | "oldPassword" | "newPassword" | "rotatedAt" | "rotatedBy" | "scheduledFor" | "completedAt" | "status" | "notes", ExtArgs["result"]["passwordRotation"]>
  export type PasswordRotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordRotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordRotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordRotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordRotation"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      policy: Prisma.$PasswordRotationPolicyPayload<ExtArgs> | null
      rotatedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      policyId: string | null
      rotationType: string
      oldPassword: string | null
      newPassword: string
      rotatedAt: Date
      rotatedBy: string
      scheduledFor: Date | null
      completedAt: Date | null
      status: string
      notes: string | null
    }, ExtArgs["result"]["passwordRotation"]>
    composites: {}
  }

  type PasswordRotationGetPayload<S extends boolean | null | undefined | PasswordRotationDefaultArgs> = $Result.GetResult<Prisma.$PasswordRotationPayload, S>

  type PasswordRotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordRotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordRotationCountAggregateInputType | true
    }

  export interface PasswordRotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordRotation'], meta: { name: 'PasswordRotation' } }
    /**
     * Find zero or one PasswordRotation that matches the filter.
     * @param {PasswordRotationFindUniqueArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordRotationFindUniqueArgs>(args: SelectSubset<T, PasswordRotationFindUniqueArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordRotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordRotationFindUniqueOrThrowArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordRotationFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordRotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationFindFirstArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordRotationFindFirstArgs>(args?: SelectSubset<T, PasswordRotationFindFirstArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationFindFirstOrThrowArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordRotationFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordRotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordRotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordRotations
     * const passwordRotations = await prisma.passwordRotation.findMany()
     * 
     * // Get first 10 PasswordRotations
     * const passwordRotations = await prisma.passwordRotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordRotationWithIdOnly = await prisma.passwordRotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordRotationFindManyArgs>(args?: SelectSubset<T, PasswordRotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordRotation.
     * @param {PasswordRotationCreateArgs} args - Arguments to create a PasswordRotation.
     * @example
     * // Create one PasswordRotation
     * const PasswordRotation = await prisma.passwordRotation.create({
     *   data: {
     *     // ... data to create a PasswordRotation
     *   }
     * })
     * 
     */
    create<T extends PasswordRotationCreateArgs>(args: SelectSubset<T, PasswordRotationCreateArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordRotations.
     * @param {PasswordRotationCreateManyArgs} args - Arguments to create many PasswordRotations.
     * @example
     * // Create many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordRotationCreateManyArgs>(args?: SelectSubset<T, PasswordRotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordRotations and returns the data saved in the database.
     * @param {PasswordRotationCreateManyAndReturnArgs} args - Arguments to create many PasswordRotations.
     * @example
     * // Create many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordRotations and only return the `id`
     * const passwordRotationWithIdOnly = await prisma.passwordRotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordRotationCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordRotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordRotation.
     * @param {PasswordRotationDeleteArgs} args - Arguments to delete one PasswordRotation.
     * @example
     * // Delete one PasswordRotation
     * const PasswordRotation = await prisma.passwordRotation.delete({
     *   where: {
     *     // ... filter to delete one PasswordRotation
     *   }
     * })
     * 
     */
    delete<T extends PasswordRotationDeleteArgs>(args: SelectSubset<T, PasswordRotationDeleteArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordRotation.
     * @param {PasswordRotationUpdateArgs} args - Arguments to update one PasswordRotation.
     * @example
     * // Update one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordRotationUpdateArgs>(args: SelectSubset<T, PasswordRotationUpdateArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordRotations.
     * @param {PasswordRotationDeleteManyArgs} args - Arguments to filter PasswordRotations to delete.
     * @example
     * // Delete a few PasswordRotations
     * const { count } = await prisma.passwordRotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordRotationDeleteManyArgs>(args?: SelectSubset<T, PasswordRotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordRotationUpdateManyArgs>(args: SelectSubset<T, PasswordRotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotations and returns the data updated in the database.
     * @param {PasswordRotationUpdateManyAndReturnArgs} args - Arguments to update many PasswordRotations.
     * @example
     * // Update many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordRotations and only return the `id`
     * const passwordRotationWithIdOnly = await prisma.passwordRotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordRotationUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordRotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordRotation.
     * @param {PasswordRotationUpsertArgs} args - Arguments to update or create a PasswordRotation.
     * @example
     * // Update or create a PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.upsert({
     *   create: {
     *     // ... data to create a PasswordRotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordRotation we want to update
     *   }
     * })
     */
    upsert<T extends PasswordRotationUpsertArgs>(args: SelectSubset<T, PasswordRotationUpsertArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationCountArgs} args - Arguments to filter PasswordRotations to count.
     * @example
     * // Count the number of PasswordRotations
     * const count = await prisma.passwordRotation.count({
     *   where: {
     *     // ... the filter for the PasswordRotations we want to count
     *   }
     * })
    **/
    count<T extends PasswordRotationCountArgs>(
      args?: Subset<T, PasswordRotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordRotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordRotationAggregateArgs>(args: Subset<T, PasswordRotationAggregateArgs>): Prisma.PrismaPromise<GetPasswordRotationAggregateType<T>>

    /**
     * Group by PasswordRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordRotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordRotationGroupByArgs['orderBy'] }
        : { orderBy?: PasswordRotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordRotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordRotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordRotation model
   */
  readonly fields: PasswordRotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordRotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordRotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    policy<T extends PasswordRotation$policyArgs<ExtArgs> = {}>(args?: Subset<T, PasswordRotation$policyArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rotatedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordRotation model
   */
  interface PasswordRotationFieldRefs {
    readonly id: FieldRef<"PasswordRotation", 'String'>
    readonly passwordId: FieldRef<"PasswordRotation", 'String'>
    readonly policyId: FieldRef<"PasswordRotation", 'String'>
    readonly rotationType: FieldRef<"PasswordRotation", 'String'>
    readonly oldPassword: FieldRef<"PasswordRotation", 'String'>
    readonly newPassword: FieldRef<"PasswordRotation", 'String'>
    readonly rotatedAt: FieldRef<"PasswordRotation", 'DateTime'>
    readonly rotatedBy: FieldRef<"PasswordRotation", 'String'>
    readonly scheduledFor: FieldRef<"PasswordRotation", 'DateTime'>
    readonly completedAt: FieldRef<"PasswordRotation", 'DateTime'>
    readonly status: FieldRef<"PasswordRotation", 'String'>
    readonly notes: FieldRef<"PasswordRotation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PasswordRotation findUnique
   */
  export type PasswordRotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation findUniqueOrThrow
   */
  export type PasswordRotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation findFirst
   */
  export type PasswordRotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotations.
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotations.
     */
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotation findFirstOrThrow
   */
  export type PasswordRotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotations.
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotations.
     */
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotation findMany
   */
  export type PasswordRotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotations to fetch.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordRotations.
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotation create
   */
  export type PasswordRotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordRotation.
     */
    data: XOR<PasswordRotationCreateInput, PasswordRotationUncheckedCreateInput>
  }

  /**
   * PasswordRotation createMany
   */
  export type PasswordRotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordRotations.
     */
    data: PasswordRotationCreateManyInput | PasswordRotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordRotation createManyAndReturn
   */
  export type PasswordRotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordRotations.
     */
    data: PasswordRotationCreateManyInput | PasswordRotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotation update
   */
  export type PasswordRotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordRotation.
     */
    data: XOR<PasswordRotationUpdateInput, PasswordRotationUncheckedUpdateInput>
    /**
     * Choose, which PasswordRotation to update.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation updateMany
   */
  export type PasswordRotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordRotations.
     */
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotations to update
     */
    where?: PasswordRotationWhereInput
    /**
     * Limit how many PasswordRotations to update.
     */
    limit?: number
  }

  /**
   * PasswordRotation updateManyAndReturn
   */
  export type PasswordRotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * The data used to update PasswordRotations.
     */
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotations to update
     */
    where?: PasswordRotationWhereInput
    /**
     * Limit how many PasswordRotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotation upsert
   */
  export type PasswordRotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordRotation to update in case it exists.
     */
    where: PasswordRotationWhereUniqueInput
    /**
     * In case the PasswordRotation found by the `where` argument doesn't exist, create a new PasswordRotation with this data.
     */
    create: XOR<PasswordRotationCreateInput, PasswordRotationUncheckedCreateInput>
    /**
     * In case the PasswordRotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordRotationUpdateInput, PasswordRotationUncheckedUpdateInput>
  }

  /**
   * PasswordRotation delete
   */
  export type PasswordRotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter which PasswordRotation to delete.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation deleteMany
   */
  export type PasswordRotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotations to delete
     */
    where?: PasswordRotationWhereInput
    /**
     * Limit how many PasswordRotations to delete.
     */
    limit?: number
  }

  /**
   * PasswordRotation.policy
   */
  export type PasswordRotation$policyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    where?: PasswordRotationPolicyWhereInput
  }

  /**
   * PasswordRotation without action
   */
  export type PasswordRotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    color: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    name: string
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    passwords?: boolean | Folder$passwordsArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "color" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    passwords?: boolean | Folder$passwordsArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      parent: Prisma.$FolderPayload<ExtArgs> | null
      children: Prisma.$FolderPayload<ExtArgs>[]
      passwords: Prisma.$PasswordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      icon: string | null
      color: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Folder$parentArgs<ExtArgs> = {}>(args?: Subset<T, Folder$parentArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Folder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Folder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwords<T extends Folder$passwordsArgs<ExtArgs> = {}>(args?: Subset<T, Folder$passwordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly description: FieldRef<"Folder", 'String'>
    readonly icon: FieldRef<"Folder", 'String'>
    readonly color: FieldRef<"Folder", 'String'>
    readonly parentId: FieldRef<"Folder", 'String'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.parent
   */
  export type Folder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Folder.children
   */
  export type Folder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder.passwords
   */
  export type Folder$passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    cursor?: PasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model PasswordShare
   */

  export type AggregatePasswordShare = {
    _count: PasswordShareCountAggregateOutputType | null
    _min: PasswordShareMinAggregateOutputType | null
    _max: PasswordShareMaxAggregateOutputType | null
  }

  export type PasswordShareMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    userId: string | null
    teamId: string | null
    permission: $Enums.SharePermission | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PasswordShareMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    userId: string | null
    teamId: string | null
    permission: $Enums.SharePermission | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PasswordShareCountAggregateOutputType = {
    id: number
    passwordId: number
    userId: number
    teamId: number
    permission: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type PasswordShareMinAggregateInputType = {
    id?: true
    passwordId?: true
    userId?: true
    teamId?: true
    permission?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PasswordShareMaxAggregateInputType = {
    id?: true
    passwordId?: true
    userId?: true
    teamId?: true
    permission?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PasswordShareCountAggregateInputType = {
    id?: true
    passwordId?: true
    userId?: true
    teamId?: true
    permission?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type PasswordShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordShare to aggregate.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordShares
    **/
    _count?: true | PasswordShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordShareMaxAggregateInputType
  }

  export type GetPasswordShareAggregateType<T extends PasswordShareAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordShare[P]>
      : GetScalarType<T[P], AggregatePasswordShare[P]>
  }




  export type PasswordShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithAggregationInput | PasswordShareOrderByWithAggregationInput[]
    by: PasswordShareScalarFieldEnum[] | PasswordShareScalarFieldEnum
    having?: PasswordShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordShareCountAggregateInputType | true
    _min?: PasswordShareMinAggregateInputType
    _max?: PasswordShareMaxAggregateInputType
  }

  export type PasswordShareGroupByOutputType = {
    id: string
    passwordId: string
    userId: string | null
    teamId: string | null
    permission: $Enums.SharePermission
    createdAt: Date
    expiresAt: Date | null
    _count: PasswordShareCountAggregateOutputType | null
    _min: PasswordShareMinAggregateOutputType | null
    _max: PasswordShareMaxAggregateOutputType | null
  }

  type GetPasswordShareGroupByPayload<T extends PasswordShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordShareGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordShareGroupByOutputType[P]>
        }
      >
    >


  export type PasswordShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }, ExtArgs["result"]["passwordShare"]>

  export type PasswordShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }, ExtArgs["result"]["passwordShare"]>

  export type PasswordShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }, ExtArgs["result"]["passwordShare"]>

  export type PasswordShareSelectScalar = {
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type PasswordShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "userId" | "teamId" | "permission" | "createdAt" | "expiresAt", ExtArgs["result"]["passwordShare"]>
  export type PasswordShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }
  export type PasswordShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }
  export type PasswordShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }

  export type $PasswordSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordShare"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      userId: string | null
      teamId: string | null
      permission: $Enums.SharePermission
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["passwordShare"]>
    composites: {}
  }

  type PasswordShareGetPayload<S extends boolean | null | undefined | PasswordShareDefaultArgs> = $Result.GetResult<Prisma.$PasswordSharePayload, S>

  type PasswordShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordShareCountAggregateInputType | true
    }

  export interface PasswordShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordShare'], meta: { name: 'PasswordShare' } }
    /**
     * Find zero or one PasswordShare that matches the filter.
     * @param {PasswordShareFindUniqueArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordShareFindUniqueArgs>(args: SelectSubset<T, PasswordShareFindUniqueArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordShareFindUniqueOrThrowArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordShareFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareFindFirstArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordShareFindFirstArgs>(args?: SelectSubset<T, PasswordShareFindFirstArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareFindFirstOrThrowArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordShareFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordShares
     * const passwordShares = await prisma.passwordShare.findMany()
     * 
     * // Get first 10 PasswordShares
     * const passwordShares = await prisma.passwordShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordShareWithIdOnly = await prisma.passwordShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordShareFindManyArgs>(args?: SelectSubset<T, PasswordShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordShare.
     * @param {PasswordShareCreateArgs} args - Arguments to create a PasswordShare.
     * @example
     * // Create one PasswordShare
     * const PasswordShare = await prisma.passwordShare.create({
     *   data: {
     *     // ... data to create a PasswordShare
     *   }
     * })
     * 
     */
    create<T extends PasswordShareCreateArgs>(args: SelectSubset<T, PasswordShareCreateArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordShares.
     * @param {PasswordShareCreateManyArgs} args - Arguments to create many PasswordShares.
     * @example
     * // Create many PasswordShares
     * const passwordShare = await prisma.passwordShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordShareCreateManyArgs>(args?: SelectSubset<T, PasswordShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordShares and returns the data saved in the database.
     * @param {PasswordShareCreateManyAndReturnArgs} args - Arguments to create many PasswordShares.
     * @example
     * // Create many PasswordShares
     * const passwordShare = await prisma.passwordShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordShares and only return the `id`
     * const passwordShareWithIdOnly = await prisma.passwordShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordShareCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordShare.
     * @param {PasswordShareDeleteArgs} args - Arguments to delete one PasswordShare.
     * @example
     * // Delete one PasswordShare
     * const PasswordShare = await prisma.passwordShare.delete({
     *   where: {
     *     // ... filter to delete one PasswordShare
     *   }
     * })
     * 
     */
    delete<T extends PasswordShareDeleteArgs>(args: SelectSubset<T, PasswordShareDeleteArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordShare.
     * @param {PasswordShareUpdateArgs} args - Arguments to update one PasswordShare.
     * @example
     * // Update one PasswordShare
     * const passwordShare = await prisma.passwordShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordShareUpdateArgs>(args: SelectSubset<T, PasswordShareUpdateArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordShares.
     * @param {PasswordShareDeleteManyArgs} args - Arguments to filter PasswordShares to delete.
     * @example
     * // Delete a few PasswordShares
     * const { count } = await prisma.passwordShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordShareDeleteManyArgs>(args?: SelectSubset<T, PasswordShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordShares
     * const passwordShare = await prisma.passwordShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordShareUpdateManyArgs>(args: SelectSubset<T, PasswordShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordShares and returns the data updated in the database.
     * @param {PasswordShareUpdateManyAndReturnArgs} args - Arguments to update many PasswordShares.
     * @example
     * // Update many PasswordShares
     * const passwordShare = await prisma.passwordShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordShares and only return the `id`
     * const passwordShareWithIdOnly = await prisma.passwordShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordShareUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordShare.
     * @param {PasswordShareUpsertArgs} args - Arguments to update or create a PasswordShare.
     * @example
     * // Update or create a PasswordShare
     * const passwordShare = await prisma.passwordShare.upsert({
     *   create: {
     *     // ... data to create a PasswordShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordShare we want to update
     *   }
     * })
     */
    upsert<T extends PasswordShareUpsertArgs>(args: SelectSubset<T, PasswordShareUpsertArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareCountArgs} args - Arguments to filter PasswordShares to count.
     * @example
     * // Count the number of PasswordShares
     * const count = await prisma.passwordShare.count({
     *   where: {
     *     // ... the filter for the PasswordShares we want to count
     *   }
     * })
    **/
    count<T extends PasswordShareCountArgs>(
      args?: Subset<T, PasswordShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordShareAggregateArgs>(args: Subset<T, PasswordShareAggregateArgs>): Prisma.PrismaPromise<GetPasswordShareAggregateType<T>>

    /**
     * Group by PasswordShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordShareGroupByArgs['orderBy'] }
        : { orderBy?: PasswordShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordShare model
   */
  readonly fields: PasswordShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends PasswordShare$userArgs<ExtArgs> = {}>(args?: Subset<T, PasswordShare$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends PasswordShare$teamArgs<ExtArgs> = {}>(args?: Subset<T, PasswordShare$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordShare model
   */
  interface PasswordShareFieldRefs {
    readonly id: FieldRef<"PasswordShare", 'String'>
    readonly passwordId: FieldRef<"PasswordShare", 'String'>
    readonly userId: FieldRef<"PasswordShare", 'String'>
    readonly teamId: FieldRef<"PasswordShare", 'String'>
    readonly permission: FieldRef<"PasswordShare", 'SharePermission'>
    readonly createdAt: FieldRef<"PasswordShare", 'DateTime'>
    readonly expiresAt: FieldRef<"PasswordShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordShare findUnique
   */
  export type PasswordShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare findUniqueOrThrow
   */
  export type PasswordShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare findFirst
   */
  export type PasswordShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordShares.
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordShares.
     */
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * PasswordShare findFirstOrThrow
   */
  export type PasswordShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordShares.
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordShares.
     */
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * PasswordShare findMany
   */
  export type PasswordShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShares to fetch.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordShares.
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * PasswordShare create
   */
  export type PasswordShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordShare.
     */
    data: XOR<PasswordShareCreateInput, PasswordShareUncheckedCreateInput>
  }

  /**
   * PasswordShare createMany
   */
  export type PasswordShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordShares.
     */
    data: PasswordShareCreateManyInput | PasswordShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordShare createManyAndReturn
   */
  export type PasswordShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordShares.
     */
    data: PasswordShareCreateManyInput | PasswordShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordShare update
   */
  export type PasswordShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordShare.
     */
    data: XOR<PasswordShareUpdateInput, PasswordShareUncheckedUpdateInput>
    /**
     * Choose, which PasswordShare to update.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare updateMany
   */
  export type PasswordShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordShares.
     */
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyInput>
    /**
     * Filter which PasswordShares to update
     */
    where?: PasswordShareWhereInput
    /**
     * Limit how many PasswordShares to update.
     */
    limit?: number
  }

  /**
   * PasswordShare updateManyAndReturn
   */
  export type PasswordShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * The data used to update PasswordShares.
     */
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyInput>
    /**
     * Filter which PasswordShares to update
     */
    where?: PasswordShareWhereInput
    /**
     * Limit how many PasswordShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordShare upsert
   */
  export type PasswordShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordShare to update in case it exists.
     */
    where: PasswordShareWhereUniqueInput
    /**
     * In case the PasswordShare found by the `where` argument doesn't exist, create a new PasswordShare with this data.
     */
    create: XOR<PasswordShareCreateInput, PasswordShareUncheckedCreateInput>
    /**
     * In case the PasswordShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordShareUpdateInput, PasswordShareUncheckedUpdateInput>
  }

  /**
   * PasswordShare delete
   */
  export type PasswordShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter which PasswordShare to delete.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare deleteMany
   */
  export type PasswordShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordShares to delete
     */
    where?: PasswordShareWhereInput
    /**
     * Limit how many PasswordShares to delete.
     */
    limit?: number
  }

  /**
   * PasswordShare.user
   */
  export type PasswordShare$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PasswordShare.team
   */
  export type PasswordShare$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * PasswordShare without action
   */
  export type PasswordShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
  }


  /**
   * Model TemporaryPasswordShare
   */

  export type AggregateTemporaryPasswordShare = {
    _count: TemporaryPasswordShareCountAggregateOutputType | null
    _avg: TemporaryPasswordShareAvgAggregateOutputType | null
    _sum: TemporaryPasswordShareSumAggregateOutputType | null
    _min: TemporaryPasswordShareMinAggregateOutputType | null
    _max: TemporaryPasswordShareMaxAggregateOutputType | null
  }

  export type TemporaryPasswordShareAvgAggregateOutputType = {
    accessCount: number | null
    maxAccesses: number | null
  }

  export type TemporaryPasswordShareSumAggregateOutputType = {
    accessCount: number | null
    maxAccesses: number | null
  }

  export type TemporaryPasswordShareMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    shareToken: string | null
    createdBy: string | null
    accessCount: number | null
    maxAccesses: number | null
    isOneTime: boolean | null
    includeTotp: boolean | null
    expiresAt: Date | null
    accessedAt: Date | null
    revokedAt: Date | null
    createdAt: Date | null
  }

  export type TemporaryPasswordShareMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    shareToken: string | null
    createdBy: string | null
    accessCount: number | null
    maxAccesses: number | null
    isOneTime: boolean | null
    includeTotp: boolean | null
    expiresAt: Date | null
    accessedAt: Date | null
    revokedAt: Date | null
    createdAt: Date | null
  }

  export type TemporaryPasswordShareCountAggregateOutputType = {
    id: number
    passwordId: number
    shareToken: number
    createdBy: number
    accessCount: number
    maxAccesses: number
    isOneTime: number
    includeTotp: number
    expiresAt: number
    accessedAt: number
    revokedAt: number
    createdAt: number
    _all: number
  }


  export type TemporaryPasswordShareAvgAggregateInputType = {
    accessCount?: true
    maxAccesses?: true
  }

  export type TemporaryPasswordShareSumAggregateInputType = {
    accessCount?: true
    maxAccesses?: true
  }

  export type TemporaryPasswordShareMinAggregateInputType = {
    id?: true
    passwordId?: true
    shareToken?: true
    createdBy?: true
    accessCount?: true
    maxAccesses?: true
    isOneTime?: true
    includeTotp?: true
    expiresAt?: true
    accessedAt?: true
    revokedAt?: true
    createdAt?: true
  }

  export type TemporaryPasswordShareMaxAggregateInputType = {
    id?: true
    passwordId?: true
    shareToken?: true
    createdBy?: true
    accessCount?: true
    maxAccesses?: true
    isOneTime?: true
    includeTotp?: true
    expiresAt?: true
    accessedAt?: true
    revokedAt?: true
    createdAt?: true
  }

  export type TemporaryPasswordShareCountAggregateInputType = {
    id?: true
    passwordId?: true
    shareToken?: true
    createdBy?: true
    accessCount?: true
    maxAccesses?: true
    isOneTime?: true
    includeTotp?: true
    expiresAt?: true
    accessedAt?: true
    revokedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TemporaryPasswordShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemporaryPasswordShare to aggregate.
     */
    where?: TemporaryPasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemporaryPasswordShares to fetch.
     */
    orderBy?: TemporaryPasswordShareOrderByWithRelationInput | TemporaryPasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemporaryPasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemporaryPasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemporaryPasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemporaryPasswordShares
    **/
    _count?: true | TemporaryPasswordShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemporaryPasswordShareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemporaryPasswordShareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemporaryPasswordShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemporaryPasswordShareMaxAggregateInputType
  }

  export type GetTemporaryPasswordShareAggregateType<T extends TemporaryPasswordShareAggregateArgs> = {
        [P in keyof T & keyof AggregateTemporaryPasswordShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemporaryPasswordShare[P]>
      : GetScalarType<T[P], AggregateTemporaryPasswordShare[P]>
  }




  export type TemporaryPasswordShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemporaryPasswordShareWhereInput
    orderBy?: TemporaryPasswordShareOrderByWithAggregationInput | TemporaryPasswordShareOrderByWithAggregationInput[]
    by: TemporaryPasswordShareScalarFieldEnum[] | TemporaryPasswordShareScalarFieldEnum
    having?: TemporaryPasswordShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemporaryPasswordShareCountAggregateInputType | true
    _avg?: TemporaryPasswordShareAvgAggregateInputType
    _sum?: TemporaryPasswordShareSumAggregateInputType
    _min?: TemporaryPasswordShareMinAggregateInputType
    _max?: TemporaryPasswordShareMaxAggregateInputType
  }

  export type TemporaryPasswordShareGroupByOutputType = {
    id: string
    passwordId: string
    shareToken: string
    createdBy: string
    accessCount: number
    maxAccesses: number | null
    isOneTime: boolean
    includeTotp: boolean
    expiresAt: Date | null
    accessedAt: Date | null
    revokedAt: Date | null
    createdAt: Date
    _count: TemporaryPasswordShareCountAggregateOutputType | null
    _avg: TemporaryPasswordShareAvgAggregateOutputType | null
    _sum: TemporaryPasswordShareSumAggregateOutputType | null
    _min: TemporaryPasswordShareMinAggregateOutputType | null
    _max: TemporaryPasswordShareMaxAggregateOutputType | null
  }

  type GetTemporaryPasswordShareGroupByPayload<T extends TemporaryPasswordShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemporaryPasswordShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemporaryPasswordShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemporaryPasswordShareGroupByOutputType[P]>
            : GetScalarType<T[P], TemporaryPasswordShareGroupByOutputType[P]>
        }
      >
    >


  export type TemporaryPasswordShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    shareToken?: boolean
    createdBy?: boolean
    accessCount?: boolean
    maxAccesses?: boolean
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: boolean
    accessedAt?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["temporaryPasswordShare"]>

  export type TemporaryPasswordShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    shareToken?: boolean
    createdBy?: boolean
    accessCount?: boolean
    maxAccesses?: boolean
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: boolean
    accessedAt?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["temporaryPasswordShare"]>

  export type TemporaryPasswordShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    shareToken?: boolean
    createdBy?: boolean
    accessCount?: boolean
    maxAccesses?: boolean
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: boolean
    accessedAt?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["temporaryPasswordShare"]>

  export type TemporaryPasswordShareSelectScalar = {
    id?: boolean
    passwordId?: boolean
    shareToken?: boolean
    createdBy?: boolean
    accessCount?: boolean
    maxAccesses?: boolean
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: boolean
    accessedAt?: boolean
    revokedAt?: boolean
    createdAt?: boolean
  }

  export type TemporaryPasswordShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "shareToken" | "createdBy" | "accessCount" | "maxAccesses" | "isOneTime" | "includeTotp" | "expiresAt" | "accessedAt" | "revokedAt" | "createdAt", ExtArgs["result"]["temporaryPasswordShare"]>
  export type TemporaryPasswordShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TemporaryPasswordShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TemporaryPasswordShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TemporaryPasswordSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemporaryPasswordShare"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      shareToken: string
      createdBy: string
      accessCount: number
      maxAccesses: number | null
      isOneTime: boolean
      includeTotp: boolean
      expiresAt: Date | null
      accessedAt: Date | null
      revokedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["temporaryPasswordShare"]>
    composites: {}
  }

  type TemporaryPasswordShareGetPayload<S extends boolean | null | undefined | TemporaryPasswordShareDefaultArgs> = $Result.GetResult<Prisma.$TemporaryPasswordSharePayload, S>

  type TemporaryPasswordShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemporaryPasswordShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemporaryPasswordShareCountAggregateInputType | true
    }

  export interface TemporaryPasswordShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemporaryPasswordShare'], meta: { name: 'TemporaryPasswordShare' } }
    /**
     * Find zero or one TemporaryPasswordShare that matches the filter.
     * @param {TemporaryPasswordShareFindUniqueArgs} args - Arguments to find a TemporaryPasswordShare
     * @example
     * // Get one TemporaryPasswordShare
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemporaryPasswordShareFindUniqueArgs>(args: SelectSubset<T, TemporaryPasswordShareFindUniqueArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemporaryPasswordShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemporaryPasswordShareFindUniqueOrThrowArgs} args - Arguments to find a TemporaryPasswordShare
     * @example
     * // Get one TemporaryPasswordShare
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemporaryPasswordShareFindUniqueOrThrowArgs>(args: SelectSubset<T, TemporaryPasswordShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemporaryPasswordShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemporaryPasswordShareFindFirstArgs} args - Arguments to find a TemporaryPasswordShare
     * @example
     * // Get one TemporaryPasswordShare
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemporaryPasswordShareFindFirstArgs>(args?: SelectSubset<T, TemporaryPasswordShareFindFirstArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemporaryPasswordShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemporaryPasswordShareFindFirstOrThrowArgs} args - Arguments to find a TemporaryPasswordShare
     * @example
     * // Get one TemporaryPasswordShare
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemporaryPasswordShareFindFirstOrThrowArgs>(args?: SelectSubset<T, TemporaryPasswordShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemporaryPasswordShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemporaryPasswordShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemporaryPasswordShares
     * const temporaryPasswordShares = await prisma.temporaryPasswordShare.findMany()
     * 
     * // Get first 10 TemporaryPasswordShares
     * const temporaryPasswordShares = await prisma.temporaryPasswordShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const temporaryPasswordShareWithIdOnly = await prisma.temporaryPasswordShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemporaryPasswordShareFindManyArgs>(args?: SelectSubset<T, TemporaryPasswordShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemporaryPasswordShare.
     * @param {TemporaryPasswordShareCreateArgs} args - Arguments to create a TemporaryPasswordShare.
     * @example
     * // Create one TemporaryPasswordShare
     * const TemporaryPasswordShare = await prisma.temporaryPasswordShare.create({
     *   data: {
     *     // ... data to create a TemporaryPasswordShare
     *   }
     * })
     * 
     */
    create<T extends TemporaryPasswordShareCreateArgs>(args: SelectSubset<T, TemporaryPasswordShareCreateArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemporaryPasswordShares.
     * @param {TemporaryPasswordShareCreateManyArgs} args - Arguments to create many TemporaryPasswordShares.
     * @example
     * // Create many TemporaryPasswordShares
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemporaryPasswordShareCreateManyArgs>(args?: SelectSubset<T, TemporaryPasswordShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemporaryPasswordShares and returns the data saved in the database.
     * @param {TemporaryPasswordShareCreateManyAndReturnArgs} args - Arguments to create many TemporaryPasswordShares.
     * @example
     * // Create many TemporaryPasswordShares
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemporaryPasswordShares and only return the `id`
     * const temporaryPasswordShareWithIdOnly = await prisma.temporaryPasswordShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemporaryPasswordShareCreateManyAndReturnArgs>(args?: SelectSubset<T, TemporaryPasswordShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemporaryPasswordShare.
     * @param {TemporaryPasswordShareDeleteArgs} args - Arguments to delete one TemporaryPasswordShare.
     * @example
     * // Delete one TemporaryPasswordShare
     * const TemporaryPasswordShare = await prisma.temporaryPasswordShare.delete({
     *   where: {
     *     // ... filter to delete one TemporaryPasswordShare
     *   }
     * })
     * 
     */
    delete<T extends TemporaryPasswordShareDeleteArgs>(args: SelectSubset<T, TemporaryPasswordShareDeleteArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemporaryPasswordShare.
     * @param {TemporaryPasswordShareUpdateArgs} args - Arguments to update one TemporaryPasswordShare.
     * @example
     * // Update one TemporaryPasswordShare
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemporaryPasswordShareUpdateArgs>(args: SelectSubset<T, TemporaryPasswordShareUpdateArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemporaryPasswordShares.
     * @param {TemporaryPasswordShareDeleteManyArgs} args - Arguments to filter TemporaryPasswordShares to delete.
     * @example
     * // Delete a few TemporaryPasswordShares
     * const { count } = await prisma.temporaryPasswordShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemporaryPasswordShareDeleteManyArgs>(args?: SelectSubset<T, TemporaryPasswordShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemporaryPasswordShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemporaryPasswordShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemporaryPasswordShares
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemporaryPasswordShareUpdateManyArgs>(args: SelectSubset<T, TemporaryPasswordShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemporaryPasswordShares and returns the data updated in the database.
     * @param {TemporaryPasswordShareUpdateManyAndReturnArgs} args - Arguments to update many TemporaryPasswordShares.
     * @example
     * // Update many TemporaryPasswordShares
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemporaryPasswordShares and only return the `id`
     * const temporaryPasswordShareWithIdOnly = await prisma.temporaryPasswordShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemporaryPasswordShareUpdateManyAndReturnArgs>(args: SelectSubset<T, TemporaryPasswordShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemporaryPasswordShare.
     * @param {TemporaryPasswordShareUpsertArgs} args - Arguments to update or create a TemporaryPasswordShare.
     * @example
     * // Update or create a TemporaryPasswordShare
     * const temporaryPasswordShare = await prisma.temporaryPasswordShare.upsert({
     *   create: {
     *     // ... data to create a TemporaryPasswordShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemporaryPasswordShare we want to update
     *   }
     * })
     */
    upsert<T extends TemporaryPasswordShareUpsertArgs>(args: SelectSubset<T, TemporaryPasswordShareUpsertArgs<ExtArgs>>): Prisma__TemporaryPasswordShareClient<$Result.GetResult<Prisma.$TemporaryPasswordSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemporaryPasswordShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemporaryPasswordShareCountArgs} args - Arguments to filter TemporaryPasswordShares to count.
     * @example
     * // Count the number of TemporaryPasswordShares
     * const count = await prisma.temporaryPasswordShare.count({
     *   where: {
     *     // ... the filter for the TemporaryPasswordShares we want to count
     *   }
     * })
    **/
    count<T extends TemporaryPasswordShareCountArgs>(
      args?: Subset<T, TemporaryPasswordShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemporaryPasswordShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemporaryPasswordShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemporaryPasswordShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemporaryPasswordShareAggregateArgs>(args: Subset<T, TemporaryPasswordShareAggregateArgs>): Prisma.PrismaPromise<GetTemporaryPasswordShareAggregateType<T>>

    /**
     * Group by TemporaryPasswordShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemporaryPasswordShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemporaryPasswordShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemporaryPasswordShareGroupByArgs['orderBy'] }
        : { orderBy?: TemporaryPasswordShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemporaryPasswordShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemporaryPasswordShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemporaryPasswordShare model
   */
  readonly fields: TemporaryPasswordShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemporaryPasswordShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemporaryPasswordShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemporaryPasswordShare model
   */
  interface TemporaryPasswordShareFieldRefs {
    readonly id: FieldRef<"TemporaryPasswordShare", 'String'>
    readonly passwordId: FieldRef<"TemporaryPasswordShare", 'String'>
    readonly shareToken: FieldRef<"TemporaryPasswordShare", 'String'>
    readonly createdBy: FieldRef<"TemporaryPasswordShare", 'String'>
    readonly accessCount: FieldRef<"TemporaryPasswordShare", 'Int'>
    readonly maxAccesses: FieldRef<"TemporaryPasswordShare", 'Int'>
    readonly isOneTime: FieldRef<"TemporaryPasswordShare", 'Boolean'>
    readonly includeTotp: FieldRef<"TemporaryPasswordShare", 'Boolean'>
    readonly expiresAt: FieldRef<"TemporaryPasswordShare", 'DateTime'>
    readonly accessedAt: FieldRef<"TemporaryPasswordShare", 'DateTime'>
    readonly revokedAt: FieldRef<"TemporaryPasswordShare", 'DateTime'>
    readonly createdAt: FieldRef<"TemporaryPasswordShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemporaryPasswordShare findUnique
   */
  export type TemporaryPasswordShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which TemporaryPasswordShare to fetch.
     */
    where: TemporaryPasswordShareWhereUniqueInput
  }

  /**
   * TemporaryPasswordShare findUniqueOrThrow
   */
  export type TemporaryPasswordShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which TemporaryPasswordShare to fetch.
     */
    where: TemporaryPasswordShareWhereUniqueInput
  }

  /**
   * TemporaryPasswordShare findFirst
   */
  export type TemporaryPasswordShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which TemporaryPasswordShare to fetch.
     */
    where?: TemporaryPasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemporaryPasswordShares to fetch.
     */
    orderBy?: TemporaryPasswordShareOrderByWithRelationInput | TemporaryPasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemporaryPasswordShares.
     */
    cursor?: TemporaryPasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemporaryPasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemporaryPasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemporaryPasswordShares.
     */
    distinct?: TemporaryPasswordShareScalarFieldEnum | TemporaryPasswordShareScalarFieldEnum[]
  }

  /**
   * TemporaryPasswordShare findFirstOrThrow
   */
  export type TemporaryPasswordShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which TemporaryPasswordShare to fetch.
     */
    where?: TemporaryPasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemporaryPasswordShares to fetch.
     */
    orderBy?: TemporaryPasswordShareOrderByWithRelationInput | TemporaryPasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemporaryPasswordShares.
     */
    cursor?: TemporaryPasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemporaryPasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemporaryPasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemporaryPasswordShares.
     */
    distinct?: TemporaryPasswordShareScalarFieldEnum | TemporaryPasswordShareScalarFieldEnum[]
  }

  /**
   * TemporaryPasswordShare findMany
   */
  export type TemporaryPasswordShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which TemporaryPasswordShares to fetch.
     */
    where?: TemporaryPasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemporaryPasswordShares to fetch.
     */
    orderBy?: TemporaryPasswordShareOrderByWithRelationInput | TemporaryPasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemporaryPasswordShares.
     */
    cursor?: TemporaryPasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemporaryPasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemporaryPasswordShares.
     */
    skip?: number
    distinct?: TemporaryPasswordShareScalarFieldEnum | TemporaryPasswordShareScalarFieldEnum[]
  }

  /**
   * TemporaryPasswordShare create
   */
  export type TemporaryPasswordShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * The data needed to create a TemporaryPasswordShare.
     */
    data: XOR<TemporaryPasswordShareCreateInput, TemporaryPasswordShareUncheckedCreateInput>
  }

  /**
   * TemporaryPasswordShare createMany
   */
  export type TemporaryPasswordShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemporaryPasswordShares.
     */
    data: TemporaryPasswordShareCreateManyInput | TemporaryPasswordShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemporaryPasswordShare createManyAndReturn
   */
  export type TemporaryPasswordShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * The data used to create many TemporaryPasswordShares.
     */
    data: TemporaryPasswordShareCreateManyInput | TemporaryPasswordShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemporaryPasswordShare update
   */
  export type TemporaryPasswordShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * The data needed to update a TemporaryPasswordShare.
     */
    data: XOR<TemporaryPasswordShareUpdateInput, TemporaryPasswordShareUncheckedUpdateInput>
    /**
     * Choose, which TemporaryPasswordShare to update.
     */
    where: TemporaryPasswordShareWhereUniqueInput
  }

  /**
   * TemporaryPasswordShare updateMany
   */
  export type TemporaryPasswordShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemporaryPasswordShares.
     */
    data: XOR<TemporaryPasswordShareUpdateManyMutationInput, TemporaryPasswordShareUncheckedUpdateManyInput>
    /**
     * Filter which TemporaryPasswordShares to update
     */
    where?: TemporaryPasswordShareWhereInput
    /**
     * Limit how many TemporaryPasswordShares to update.
     */
    limit?: number
  }

  /**
   * TemporaryPasswordShare updateManyAndReturn
   */
  export type TemporaryPasswordShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * The data used to update TemporaryPasswordShares.
     */
    data: XOR<TemporaryPasswordShareUpdateManyMutationInput, TemporaryPasswordShareUncheckedUpdateManyInput>
    /**
     * Filter which TemporaryPasswordShares to update
     */
    where?: TemporaryPasswordShareWhereInput
    /**
     * Limit how many TemporaryPasswordShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemporaryPasswordShare upsert
   */
  export type TemporaryPasswordShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * The filter to search for the TemporaryPasswordShare to update in case it exists.
     */
    where: TemporaryPasswordShareWhereUniqueInput
    /**
     * In case the TemporaryPasswordShare found by the `where` argument doesn't exist, create a new TemporaryPasswordShare with this data.
     */
    create: XOR<TemporaryPasswordShareCreateInput, TemporaryPasswordShareUncheckedCreateInput>
    /**
     * In case the TemporaryPasswordShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemporaryPasswordShareUpdateInput, TemporaryPasswordShareUncheckedUpdateInput>
  }

  /**
   * TemporaryPasswordShare delete
   */
  export type TemporaryPasswordShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
    /**
     * Filter which TemporaryPasswordShare to delete.
     */
    where: TemporaryPasswordShareWhereUniqueInput
  }

  /**
   * TemporaryPasswordShare deleteMany
   */
  export type TemporaryPasswordShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemporaryPasswordShares to delete
     */
    where?: TemporaryPasswordShareWhereInput
    /**
     * Limit how many TemporaryPasswordShares to delete.
     */
    limit?: number
  }

  /**
   * TemporaryPasswordShare without action
   */
  export type TemporaryPasswordShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemporaryPasswordShare
     */
    select?: TemporaryPasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemporaryPasswordShare
     */
    omit?: TemporaryPasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemporaryPasswordShareInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Team$membersArgs<ExtArgs>
    sharedPasswords?: boolean | Team$sharedPasswordsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Team$membersArgs<ExtArgs>
    sharedPasswords?: boolean | Team$sharedPasswordsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      sharedPasswords: Prisma.$PasswordSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedPasswords<T extends Team$sharedPasswordsArgs<ExtArgs> = {}>(args?: Subset<T, Team$sharedPasswordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.sharedPasswords
   */
  export type Team$sharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    cursor?: PasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    createdAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    role: $Enums.TeamRole
    createdAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "role" | "createdAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      role: $Enums.TeamRole
      createdAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'TeamRole'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    icon: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    icon?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    icon?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    icon?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string | null
    icon: string | null
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
    passwords?: boolean | Tag$passwordsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "icon" | "createdAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwords?: boolean | Tag$passwordsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      passwords: Prisma.$PasswordTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string | null
      icon: string | null
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passwords<T extends Tag$passwordsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$passwordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly icon: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.passwords
   */
  export type Tag$passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    where?: PasswordTagWhereInput
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    cursor?: PasswordTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model PasswordTag
   */

  export type AggregatePasswordTag = {
    _count: PasswordTagCountAggregateOutputType | null
    _min: PasswordTagMinAggregateOutputType | null
    _max: PasswordTagMaxAggregateOutputType | null
  }

  export type PasswordTagMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type PasswordTagMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type PasswordTagCountAggregateOutputType = {
    id: number
    passwordId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type PasswordTagMinAggregateInputType = {
    id?: true
    passwordId?: true
    tagId?: true
    createdAt?: true
  }

  export type PasswordTagMaxAggregateInputType = {
    id?: true
    passwordId?: true
    tagId?: true
    createdAt?: true
  }

  export type PasswordTagCountAggregateInputType = {
    id?: true
    passwordId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTag to aggregate.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordTags
    **/
    _count?: true | PasswordTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordTagMaxAggregateInputType
  }

  export type GetPasswordTagAggregateType<T extends PasswordTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordTag[P]>
      : GetScalarType<T[P], AggregatePasswordTag[P]>
  }




  export type PasswordTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTagWhereInput
    orderBy?: PasswordTagOrderByWithAggregationInput | PasswordTagOrderByWithAggregationInput[]
    by: PasswordTagScalarFieldEnum[] | PasswordTagScalarFieldEnum
    having?: PasswordTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordTagCountAggregateInputType | true
    _min?: PasswordTagMinAggregateInputType
    _max?: PasswordTagMaxAggregateInputType
  }

  export type PasswordTagGroupByOutputType = {
    id: string
    passwordId: string
    tagId: string
    createdAt: Date
    _count: PasswordTagCountAggregateOutputType | null
    _min: PasswordTagMinAggregateOutputType | null
    _max: PasswordTagMaxAggregateOutputType | null
  }

  type GetPasswordTagGroupByPayload<T extends PasswordTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordTagGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordTagGroupByOutputType[P]>
        }
      >
    >


  export type PasswordTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTag"]>

  export type PasswordTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTag"]>

  export type PasswordTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTag"]>

  export type PasswordTagSelectScalar = {
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type PasswordTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "tagId" | "createdAt", ExtArgs["result"]["passwordTag"]>
  export type PasswordTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PasswordTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PasswordTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PasswordTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordTag"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["passwordTag"]>
    composites: {}
  }

  type PasswordTagGetPayload<S extends boolean | null | undefined | PasswordTagDefaultArgs> = $Result.GetResult<Prisma.$PasswordTagPayload, S>

  type PasswordTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordTagCountAggregateInputType | true
    }

  export interface PasswordTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordTag'], meta: { name: 'PasswordTag' } }
    /**
     * Find zero or one PasswordTag that matches the filter.
     * @param {PasswordTagFindUniqueArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordTagFindUniqueArgs>(args: SelectSubset<T, PasswordTagFindUniqueArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordTagFindUniqueOrThrowArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagFindFirstArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordTagFindFirstArgs>(args?: SelectSubset<T, PasswordTagFindFirstArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagFindFirstOrThrowArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordTags
     * const passwordTags = await prisma.passwordTag.findMany()
     * 
     * // Get first 10 PasswordTags
     * const passwordTags = await prisma.passwordTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordTagWithIdOnly = await prisma.passwordTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordTagFindManyArgs>(args?: SelectSubset<T, PasswordTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordTag.
     * @param {PasswordTagCreateArgs} args - Arguments to create a PasswordTag.
     * @example
     * // Create one PasswordTag
     * const PasswordTag = await prisma.passwordTag.create({
     *   data: {
     *     // ... data to create a PasswordTag
     *   }
     * })
     * 
     */
    create<T extends PasswordTagCreateArgs>(args: SelectSubset<T, PasswordTagCreateArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordTags.
     * @param {PasswordTagCreateManyArgs} args - Arguments to create many PasswordTags.
     * @example
     * // Create many PasswordTags
     * const passwordTag = await prisma.passwordTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordTagCreateManyArgs>(args?: SelectSubset<T, PasswordTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordTags and returns the data saved in the database.
     * @param {PasswordTagCreateManyAndReturnArgs} args - Arguments to create many PasswordTags.
     * @example
     * // Create many PasswordTags
     * const passwordTag = await prisma.passwordTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordTags and only return the `id`
     * const passwordTagWithIdOnly = await prisma.passwordTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordTag.
     * @param {PasswordTagDeleteArgs} args - Arguments to delete one PasswordTag.
     * @example
     * // Delete one PasswordTag
     * const PasswordTag = await prisma.passwordTag.delete({
     *   where: {
     *     // ... filter to delete one PasswordTag
     *   }
     * })
     * 
     */
    delete<T extends PasswordTagDeleteArgs>(args: SelectSubset<T, PasswordTagDeleteArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordTag.
     * @param {PasswordTagUpdateArgs} args - Arguments to update one PasswordTag.
     * @example
     * // Update one PasswordTag
     * const passwordTag = await prisma.passwordTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordTagUpdateArgs>(args: SelectSubset<T, PasswordTagUpdateArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordTags.
     * @param {PasswordTagDeleteManyArgs} args - Arguments to filter PasswordTags to delete.
     * @example
     * // Delete a few PasswordTags
     * const { count } = await prisma.passwordTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordTagDeleteManyArgs>(args?: SelectSubset<T, PasswordTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordTags
     * const passwordTag = await prisma.passwordTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordTagUpdateManyArgs>(args: SelectSubset<T, PasswordTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTags and returns the data updated in the database.
     * @param {PasswordTagUpdateManyAndReturnArgs} args - Arguments to update many PasswordTags.
     * @example
     * // Update many PasswordTags
     * const passwordTag = await prisma.passwordTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordTags and only return the `id`
     * const passwordTagWithIdOnly = await prisma.passwordTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordTag.
     * @param {PasswordTagUpsertArgs} args - Arguments to update or create a PasswordTag.
     * @example
     * // Update or create a PasswordTag
     * const passwordTag = await prisma.passwordTag.upsert({
     *   create: {
     *     // ... data to create a PasswordTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordTag we want to update
     *   }
     * })
     */
    upsert<T extends PasswordTagUpsertArgs>(args: SelectSubset<T, PasswordTagUpsertArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagCountArgs} args - Arguments to filter PasswordTags to count.
     * @example
     * // Count the number of PasswordTags
     * const count = await prisma.passwordTag.count({
     *   where: {
     *     // ... the filter for the PasswordTags we want to count
     *   }
     * })
    **/
    count<T extends PasswordTagCountArgs>(
      args?: Subset<T, PasswordTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordTagAggregateArgs>(args: Subset<T, PasswordTagAggregateArgs>): Prisma.PrismaPromise<GetPasswordTagAggregateType<T>>

    /**
     * Group by PasswordTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordTagGroupByArgs['orderBy'] }
        : { orderBy?: PasswordTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordTag model
   */
  readonly fields: PasswordTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordTag model
   */
  interface PasswordTagFieldRefs {
    readonly id: FieldRef<"PasswordTag", 'String'>
    readonly passwordId: FieldRef<"PasswordTag", 'String'>
    readonly tagId: FieldRef<"PasswordTag", 'String'>
    readonly createdAt: FieldRef<"PasswordTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordTag findUnique
   */
  export type PasswordTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag findUniqueOrThrow
   */
  export type PasswordTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag findFirst
   */
  export type PasswordTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTags.
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTags.
     */
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * PasswordTag findFirstOrThrow
   */
  export type PasswordTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTags.
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTags.
     */
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * PasswordTag findMany
   */
  export type PasswordTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTags to fetch.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordTags.
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * PasswordTag create
   */
  export type PasswordTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordTag.
     */
    data: XOR<PasswordTagCreateInput, PasswordTagUncheckedCreateInput>
  }

  /**
   * PasswordTag createMany
   */
  export type PasswordTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordTags.
     */
    data: PasswordTagCreateManyInput | PasswordTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordTag createManyAndReturn
   */
  export type PasswordTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordTags.
     */
    data: PasswordTagCreateManyInput | PasswordTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTag update
   */
  export type PasswordTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordTag.
     */
    data: XOR<PasswordTagUpdateInput, PasswordTagUncheckedUpdateInput>
    /**
     * Choose, which PasswordTag to update.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag updateMany
   */
  export type PasswordTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordTags.
     */
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTags to update
     */
    where?: PasswordTagWhereInput
    /**
     * Limit how many PasswordTags to update.
     */
    limit?: number
  }

  /**
   * PasswordTag updateManyAndReturn
   */
  export type PasswordTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * The data used to update PasswordTags.
     */
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTags to update
     */
    where?: PasswordTagWhereInput
    /**
     * Limit how many PasswordTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTag upsert
   */
  export type PasswordTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordTag to update in case it exists.
     */
    where: PasswordTagWhereUniqueInput
    /**
     * In case the PasswordTag found by the `where` argument doesn't exist, create a new PasswordTag with this data.
     */
    create: XOR<PasswordTagCreateInput, PasswordTagUncheckedCreateInput>
    /**
     * In case the PasswordTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordTagUpdateInput, PasswordTagUncheckedUpdateInput>
  }

  /**
   * PasswordTag delete
   */
  export type PasswordTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter which PasswordTag to delete.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag deleteMany
   */
  export type PasswordTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTags to delete
     */
    where?: PasswordTagWhereInput
    /**
     * Limit how many PasswordTags to delete.
     */
    limit?: number
  }

  /**
   * PasswordTag without action
   */
  export type PasswordTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.AuditStatus | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.AuditStatus | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    status: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.AuditStatus
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "status" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      status: $Enums.AuditStatus
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly status: FieldRef<"AuditLog", 'AuditStatus'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AuditLogArchive
   */

  export type AggregateAuditLogArchive = {
    _count: AuditLogArchiveCountAggregateOutputType | null
    _avg: AuditLogArchiveAvgAggregateOutputType | null
    _sum: AuditLogArchiveSumAggregateOutputType | null
    _min: AuditLogArchiveMinAggregateOutputType | null
    _max: AuditLogArchiveMaxAggregateOutputType | null
  }

  export type AuditLogArchiveAvgAggregateOutputType = {
    logCount: number | null
    fileSize: number | null
  }

  export type AuditLogArchiveSumAggregateOutputType = {
    logCount: number | null
    fileSize: number | null
  }

  export type AuditLogArchiveMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    archiveDate: Date | null
    startDate: Date | null
    endDate: Date | null
    logCount: number | null
    filePath: string | null
    fileSize: number | null
    archivedBy: string | null
    status: string | null
    createdAt: Date | null
  }

  export type AuditLogArchiveMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    archiveDate: Date | null
    startDate: Date | null
    endDate: Date | null
    logCount: number | null
    filePath: string | null
    fileSize: number | null
    archivedBy: string | null
    status: string | null
    createdAt: Date | null
  }

  export type AuditLogArchiveCountAggregateOutputType = {
    id: number
    companyId: number
    archiveDate: number
    startDate: number
    endDate: number
    logCount: number
    filePath: number
    fileSize: number
    archivedBy: number
    status: number
    createdAt: number
    _all: number
  }


  export type AuditLogArchiveAvgAggregateInputType = {
    logCount?: true
    fileSize?: true
  }

  export type AuditLogArchiveSumAggregateInputType = {
    logCount?: true
    fileSize?: true
  }

  export type AuditLogArchiveMinAggregateInputType = {
    id?: true
    companyId?: true
    archiveDate?: true
    startDate?: true
    endDate?: true
    logCount?: true
    filePath?: true
    fileSize?: true
    archivedBy?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogArchiveMaxAggregateInputType = {
    id?: true
    companyId?: true
    archiveDate?: true
    startDate?: true
    endDate?: true
    logCount?: true
    filePath?: true
    fileSize?: true
    archivedBy?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogArchiveCountAggregateInputType = {
    id?: true
    companyId?: true
    archiveDate?: true
    startDate?: true
    endDate?: true
    logCount?: true
    filePath?: true
    fileSize?: true
    archivedBy?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogArchiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogArchive to aggregate.
     */
    where?: AuditLogArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogArchives to fetch.
     */
    orderBy?: AuditLogArchiveOrderByWithRelationInput | AuditLogArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogArchives
    **/
    _count?: true | AuditLogArchiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogArchiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogArchiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogArchiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogArchiveMaxAggregateInputType
  }

  export type GetAuditLogArchiveAggregateType<T extends AuditLogArchiveAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLogArchive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLogArchive[P]>
      : GetScalarType<T[P], AggregateAuditLogArchive[P]>
  }




  export type AuditLogArchiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogArchiveWhereInput
    orderBy?: AuditLogArchiveOrderByWithAggregationInput | AuditLogArchiveOrderByWithAggregationInput[]
    by: AuditLogArchiveScalarFieldEnum[] | AuditLogArchiveScalarFieldEnum
    having?: AuditLogArchiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogArchiveCountAggregateInputType | true
    _avg?: AuditLogArchiveAvgAggregateInputType
    _sum?: AuditLogArchiveSumAggregateInputType
    _min?: AuditLogArchiveMinAggregateInputType
    _max?: AuditLogArchiveMaxAggregateInputType
  }

  export type AuditLogArchiveGroupByOutputType = {
    id: string
    companyId: string | null
    archiveDate: Date
    startDate: Date
    endDate: Date
    logCount: number
    filePath: string | null
    fileSize: number | null
    archivedBy: string | null
    status: string
    createdAt: Date
    _count: AuditLogArchiveCountAggregateOutputType | null
    _avg: AuditLogArchiveAvgAggregateOutputType | null
    _sum: AuditLogArchiveSumAggregateOutputType | null
    _min: AuditLogArchiveMinAggregateOutputType | null
    _max: AuditLogArchiveMaxAggregateOutputType | null
  }

  type GetAuditLogArchiveGroupByPayload<T extends AuditLogArchiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogArchiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogArchiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogArchiveGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogArchiveGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogArchiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    archiveDate?: boolean
    startDate?: boolean
    endDate?: boolean
    logCount?: boolean
    filePath?: boolean
    fileSize?: boolean
    archivedBy?: boolean
    status?: boolean
    createdAt?: boolean
    company?: boolean | AuditLogArchive$companyArgs<ExtArgs>
    archiver?: boolean | AuditLogArchive$archiverArgs<ExtArgs>
  }, ExtArgs["result"]["auditLogArchive"]>

  export type AuditLogArchiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    archiveDate?: boolean
    startDate?: boolean
    endDate?: boolean
    logCount?: boolean
    filePath?: boolean
    fileSize?: boolean
    archivedBy?: boolean
    status?: boolean
    createdAt?: boolean
    company?: boolean | AuditLogArchive$companyArgs<ExtArgs>
    archiver?: boolean | AuditLogArchive$archiverArgs<ExtArgs>
  }, ExtArgs["result"]["auditLogArchive"]>

  export type AuditLogArchiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    archiveDate?: boolean
    startDate?: boolean
    endDate?: boolean
    logCount?: boolean
    filePath?: boolean
    fileSize?: boolean
    archivedBy?: boolean
    status?: boolean
    createdAt?: boolean
    company?: boolean | AuditLogArchive$companyArgs<ExtArgs>
    archiver?: boolean | AuditLogArchive$archiverArgs<ExtArgs>
  }, ExtArgs["result"]["auditLogArchive"]>

  export type AuditLogArchiveSelectScalar = {
    id?: boolean
    companyId?: boolean
    archiveDate?: boolean
    startDate?: boolean
    endDate?: boolean
    logCount?: boolean
    filePath?: boolean
    fileSize?: boolean
    archivedBy?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AuditLogArchiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "archiveDate" | "startDate" | "endDate" | "logCount" | "filePath" | "fileSize" | "archivedBy" | "status" | "createdAt", ExtArgs["result"]["auditLogArchive"]>
  export type AuditLogArchiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | AuditLogArchive$companyArgs<ExtArgs>
    archiver?: boolean | AuditLogArchive$archiverArgs<ExtArgs>
  }
  export type AuditLogArchiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | AuditLogArchive$companyArgs<ExtArgs>
    archiver?: boolean | AuditLogArchive$archiverArgs<ExtArgs>
  }
  export type AuditLogArchiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | AuditLogArchive$companyArgs<ExtArgs>
    archiver?: boolean | AuditLogArchive$archiverArgs<ExtArgs>
  }

  export type $AuditLogArchivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLogArchive"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      archiver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string | null
      archiveDate: Date
      startDate: Date
      endDate: Date
      logCount: number
      filePath: string | null
      fileSize: number | null
      archivedBy: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["auditLogArchive"]>
    composites: {}
  }

  type AuditLogArchiveGetPayload<S extends boolean | null | undefined | AuditLogArchiveDefaultArgs> = $Result.GetResult<Prisma.$AuditLogArchivePayload, S>

  type AuditLogArchiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogArchiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogArchiveCountAggregateInputType | true
    }

  export interface AuditLogArchiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLogArchive'], meta: { name: 'AuditLogArchive' } }
    /**
     * Find zero or one AuditLogArchive that matches the filter.
     * @param {AuditLogArchiveFindUniqueArgs} args - Arguments to find a AuditLogArchive
     * @example
     * // Get one AuditLogArchive
     * const auditLogArchive = await prisma.auditLogArchive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogArchiveFindUniqueArgs>(args: SelectSubset<T, AuditLogArchiveFindUniqueArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLogArchive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogArchiveFindUniqueOrThrowArgs} args - Arguments to find a AuditLogArchive
     * @example
     * // Get one AuditLogArchive
     * const auditLogArchive = await prisma.auditLogArchive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogArchiveFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogArchiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLogArchive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogArchiveFindFirstArgs} args - Arguments to find a AuditLogArchive
     * @example
     * // Get one AuditLogArchive
     * const auditLogArchive = await prisma.auditLogArchive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogArchiveFindFirstArgs>(args?: SelectSubset<T, AuditLogArchiveFindFirstArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLogArchive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogArchiveFindFirstOrThrowArgs} args - Arguments to find a AuditLogArchive
     * @example
     * // Get one AuditLogArchive
     * const auditLogArchive = await prisma.auditLogArchive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogArchiveFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogArchiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogArchives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogArchiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogArchives
     * const auditLogArchives = await prisma.auditLogArchive.findMany()
     * 
     * // Get first 10 AuditLogArchives
     * const auditLogArchives = await prisma.auditLogArchive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogArchiveWithIdOnly = await prisma.auditLogArchive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogArchiveFindManyArgs>(args?: SelectSubset<T, AuditLogArchiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLogArchive.
     * @param {AuditLogArchiveCreateArgs} args - Arguments to create a AuditLogArchive.
     * @example
     * // Create one AuditLogArchive
     * const AuditLogArchive = await prisma.auditLogArchive.create({
     *   data: {
     *     // ... data to create a AuditLogArchive
     *   }
     * })
     * 
     */
    create<T extends AuditLogArchiveCreateArgs>(args: SelectSubset<T, AuditLogArchiveCreateArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogArchives.
     * @param {AuditLogArchiveCreateManyArgs} args - Arguments to create many AuditLogArchives.
     * @example
     * // Create many AuditLogArchives
     * const auditLogArchive = await prisma.auditLogArchive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogArchiveCreateManyArgs>(args?: SelectSubset<T, AuditLogArchiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogArchives and returns the data saved in the database.
     * @param {AuditLogArchiveCreateManyAndReturnArgs} args - Arguments to create many AuditLogArchives.
     * @example
     * // Create many AuditLogArchives
     * const auditLogArchive = await prisma.auditLogArchive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogArchives and only return the `id`
     * const auditLogArchiveWithIdOnly = await prisma.auditLogArchive.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogArchiveCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogArchiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLogArchive.
     * @param {AuditLogArchiveDeleteArgs} args - Arguments to delete one AuditLogArchive.
     * @example
     * // Delete one AuditLogArchive
     * const AuditLogArchive = await prisma.auditLogArchive.delete({
     *   where: {
     *     // ... filter to delete one AuditLogArchive
     *   }
     * })
     * 
     */
    delete<T extends AuditLogArchiveDeleteArgs>(args: SelectSubset<T, AuditLogArchiveDeleteArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLogArchive.
     * @param {AuditLogArchiveUpdateArgs} args - Arguments to update one AuditLogArchive.
     * @example
     * // Update one AuditLogArchive
     * const auditLogArchive = await prisma.auditLogArchive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogArchiveUpdateArgs>(args: SelectSubset<T, AuditLogArchiveUpdateArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogArchives.
     * @param {AuditLogArchiveDeleteManyArgs} args - Arguments to filter AuditLogArchives to delete.
     * @example
     * // Delete a few AuditLogArchives
     * const { count } = await prisma.auditLogArchive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogArchiveDeleteManyArgs>(args?: SelectSubset<T, AuditLogArchiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogArchiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogArchives
     * const auditLogArchive = await prisma.auditLogArchive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogArchiveUpdateManyArgs>(args: SelectSubset<T, AuditLogArchiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogArchives and returns the data updated in the database.
     * @param {AuditLogArchiveUpdateManyAndReturnArgs} args - Arguments to update many AuditLogArchives.
     * @example
     * // Update many AuditLogArchives
     * const auditLogArchive = await prisma.auditLogArchive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogArchives and only return the `id`
     * const auditLogArchiveWithIdOnly = await prisma.auditLogArchive.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogArchiveUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogArchiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLogArchive.
     * @param {AuditLogArchiveUpsertArgs} args - Arguments to update or create a AuditLogArchive.
     * @example
     * // Update or create a AuditLogArchive
     * const auditLogArchive = await prisma.auditLogArchive.upsert({
     *   create: {
     *     // ... data to create a AuditLogArchive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLogArchive we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogArchiveUpsertArgs>(args: SelectSubset<T, AuditLogArchiveUpsertArgs<ExtArgs>>): Prisma__AuditLogArchiveClient<$Result.GetResult<Prisma.$AuditLogArchivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogArchiveCountArgs} args - Arguments to filter AuditLogArchives to count.
     * @example
     * // Count the number of AuditLogArchives
     * const count = await prisma.auditLogArchive.count({
     *   where: {
     *     // ... the filter for the AuditLogArchives we want to count
     *   }
     * })
    **/
    count<T extends AuditLogArchiveCountArgs>(
      args?: Subset<T, AuditLogArchiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogArchiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLogArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogArchiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogArchiveAggregateArgs>(args: Subset<T, AuditLogArchiveAggregateArgs>): Prisma.PrismaPromise<GetAuditLogArchiveAggregateType<T>>

    /**
     * Group by AuditLogArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogArchiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogArchiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogArchiveGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogArchiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogArchiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogArchiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLogArchive model
   */
  readonly fields: AuditLogArchiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLogArchive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogArchiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends AuditLogArchive$companyArgs<ExtArgs> = {}>(args?: Subset<T, AuditLogArchive$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    archiver<T extends AuditLogArchive$archiverArgs<ExtArgs> = {}>(args?: Subset<T, AuditLogArchive$archiverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLogArchive model
   */
  interface AuditLogArchiveFieldRefs {
    readonly id: FieldRef<"AuditLogArchive", 'String'>
    readonly companyId: FieldRef<"AuditLogArchive", 'String'>
    readonly archiveDate: FieldRef<"AuditLogArchive", 'DateTime'>
    readonly startDate: FieldRef<"AuditLogArchive", 'DateTime'>
    readonly endDate: FieldRef<"AuditLogArchive", 'DateTime'>
    readonly logCount: FieldRef<"AuditLogArchive", 'Int'>
    readonly filePath: FieldRef<"AuditLogArchive", 'String'>
    readonly fileSize: FieldRef<"AuditLogArchive", 'Int'>
    readonly archivedBy: FieldRef<"AuditLogArchive", 'String'>
    readonly status: FieldRef<"AuditLogArchive", 'String'>
    readonly createdAt: FieldRef<"AuditLogArchive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLogArchive findUnique
   */
  export type AuditLogArchiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogArchive to fetch.
     */
    where: AuditLogArchiveWhereUniqueInput
  }

  /**
   * AuditLogArchive findUniqueOrThrow
   */
  export type AuditLogArchiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogArchive to fetch.
     */
    where: AuditLogArchiveWhereUniqueInput
  }

  /**
   * AuditLogArchive findFirst
   */
  export type AuditLogArchiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogArchive to fetch.
     */
    where?: AuditLogArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogArchives to fetch.
     */
    orderBy?: AuditLogArchiveOrderByWithRelationInput | AuditLogArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogArchives.
     */
    cursor?: AuditLogArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogArchives.
     */
    distinct?: AuditLogArchiveScalarFieldEnum | AuditLogArchiveScalarFieldEnum[]
  }

  /**
   * AuditLogArchive findFirstOrThrow
   */
  export type AuditLogArchiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogArchive to fetch.
     */
    where?: AuditLogArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogArchives to fetch.
     */
    orderBy?: AuditLogArchiveOrderByWithRelationInput | AuditLogArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogArchives.
     */
    cursor?: AuditLogArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogArchives.
     */
    distinct?: AuditLogArchiveScalarFieldEnum | AuditLogArchiveScalarFieldEnum[]
  }

  /**
   * AuditLogArchive findMany
   */
  export type AuditLogArchiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogArchives to fetch.
     */
    where?: AuditLogArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogArchives to fetch.
     */
    orderBy?: AuditLogArchiveOrderByWithRelationInput | AuditLogArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogArchives.
     */
    cursor?: AuditLogArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogArchives.
     */
    skip?: number
    distinct?: AuditLogArchiveScalarFieldEnum | AuditLogArchiveScalarFieldEnum[]
  }

  /**
   * AuditLogArchive create
   */
  export type AuditLogArchiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLogArchive.
     */
    data: XOR<AuditLogArchiveCreateInput, AuditLogArchiveUncheckedCreateInput>
  }

  /**
   * AuditLogArchive createMany
   */
  export type AuditLogArchiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogArchives.
     */
    data: AuditLogArchiveCreateManyInput | AuditLogArchiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLogArchive createManyAndReturn
   */
  export type AuditLogArchiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogArchives.
     */
    data: AuditLogArchiveCreateManyInput | AuditLogArchiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLogArchive update
   */
  export type AuditLogArchiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLogArchive.
     */
    data: XOR<AuditLogArchiveUpdateInput, AuditLogArchiveUncheckedUpdateInput>
    /**
     * Choose, which AuditLogArchive to update.
     */
    where: AuditLogArchiveWhereUniqueInput
  }

  /**
   * AuditLogArchive updateMany
   */
  export type AuditLogArchiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogArchives.
     */
    data: XOR<AuditLogArchiveUpdateManyMutationInput, AuditLogArchiveUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogArchives to update
     */
    where?: AuditLogArchiveWhereInput
    /**
     * Limit how many AuditLogArchives to update.
     */
    limit?: number
  }

  /**
   * AuditLogArchive updateManyAndReturn
   */
  export type AuditLogArchiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogArchives.
     */
    data: XOR<AuditLogArchiveUpdateManyMutationInput, AuditLogArchiveUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogArchives to update
     */
    where?: AuditLogArchiveWhereInput
    /**
     * Limit how many AuditLogArchives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLogArchive upsert
   */
  export type AuditLogArchiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLogArchive to update in case it exists.
     */
    where: AuditLogArchiveWhereUniqueInput
    /**
     * In case the AuditLogArchive found by the `where` argument doesn't exist, create a new AuditLogArchive with this data.
     */
    create: XOR<AuditLogArchiveCreateInput, AuditLogArchiveUncheckedCreateInput>
    /**
     * In case the AuditLogArchive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogArchiveUpdateInput, AuditLogArchiveUncheckedUpdateInput>
  }

  /**
   * AuditLogArchive delete
   */
  export type AuditLogArchiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
    /**
     * Filter which AuditLogArchive to delete.
     */
    where: AuditLogArchiveWhereUniqueInput
  }

  /**
   * AuditLogArchive deleteMany
   */
  export type AuditLogArchiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogArchives to delete
     */
    where?: AuditLogArchiveWhereInput
    /**
     * Limit how many AuditLogArchives to delete.
     */
    limit?: number
  }

  /**
   * AuditLogArchive.company
   */
  export type AuditLogArchive$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * AuditLogArchive.archiver
   */
  export type AuditLogArchive$archiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLogArchive without action
   */
  export type AuditLogArchiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogArchive
     */
    select?: AuditLogArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogArchive
     */
    omit?: AuditLogArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogArchiveInclude<ExtArgs> | null
  }


  /**
   * Model AuditLogSearch
   */

  export type AggregateAuditLogSearch = {
    _count: AuditLogSearchCountAggregateOutputType | null
    _min: AuditLogSearchMinAggregateOutputType | null
    _max: AuditLogSearchMaxAggregateOutputType | null
  }

  export type AuditLogSearchMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    name: string | null
    searchQuery: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type AuditLogSearchMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    name: string | null
    searchQuery: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type AuditLogSearchCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    name: number
    searchQuery: number
    filters: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type AuditLogSearchMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    name?: true
    searchQuery?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type AuditLogSearchMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    name?: true
    searchQuery?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type AuditLogSearchCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    name?: true
    searchQuery?: true
    filters?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type AuditLogSearchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogSearch to aggregate.
     */
    where?: AuditLogSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogSearches to fetch.
     */
    orderBy?: AuditLogSearchOrderByWithRelationInput | AuditLogSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogSearches
    **/
    _count?: true | AuditLogSearchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogSearchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogSearchMaxAggregateInputType
  }

  export type GetAuditLogSearchAggregateType<T extends AuditLogSearchAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLogSearch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLogSearch[P]>
      : GetScalarType<T[P], AggregateAuditLogSearch[P]>
  }




  export type AuditLogSearchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogSearchWhereInput
    orderBy?: AuditLogSearchOrderByWithAggregationInput | AuditLogSearchOrderByWithAggregationInput[]
    by: AuditLogSearchScalarFieldEnum[] | AuditLogSearchScalarFieldEnum
    having?: AuditLogSearchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogSearchCountAggregateInputType | true
    _min?: AuditLogSearchMinAggregateInputType
    _max?: AuditLogSearchMaxAggregateInputType
  }

  export type AuditLogSearchGroupByOutputType = {
    id: string
    userId: string
    companyId: string | null
    name: string | null
    searchQuery: string
    filters: JsonValue | null
    createdAt: Date
    lastUsedAt: Date
    _count: AuditLogSearchCountAggregateOutputType | null
    _min: AuditLogSearchMinAggregateOutputType | null
    _max: AuditLogSearchMaxAggregateOutputType | null
  }

  type GetAuditLogSearchGroupByPayload<T extends AuditLogSearchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogSearchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogSearchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogSearchGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogSearchGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSearchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    name?: boolean
    searchQuery?: boolean
    filters?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLogSearch$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLogSearch"]>

  export type AuditLogSearchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    name?: boolean
    searchQuery?: boolean
    filters?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLogSearch$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLogSearch"]>

  export type AuditLogSearchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    name?: boolean
    searchQuery?: boolean
    filters?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLogSearch$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLogSearch"]>

  export type AuditLogSearchSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    name?: boolean
    searchQuery?: boolean
    filters?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type AuditLogSearchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "name" | "searchQuery" | "filters" | "createdAt" | "lastUsedAt", ExtArgs["result"]["auditLogSearch"]>
  export type AuditLogSearchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLogSearch$companyArgs<ExtArgs>
  }
  export type AuditLogSearchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLogSearch$companyArgs<ExtArgs>
  }
  export type AuditLogSearchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLogSearch$companyArgs<ExtArgs>
  }

  export type $AuditLogSearchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLogSearch"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string | null
      name: string | null
      searchQuery: string
      filters: Prisma.JsonValue | null
      createdAt: Date
      lastUsedAt: Date
    }, ExtArgs["result"]["auditLogSearch"]>
    composites: {}
  }

  type AuditLogSearchGetPayload<S extends boolean | null | undefined | AuditLogSearchDefaultArgs> = $Result.GetResult<Prisma.$AuditLogSearchPayload, S>

  type AuditLogSearchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogSearchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogSearchCountAggregateInputType | true
    }

  export interface AuditLogSearchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLogSearch'], meta: { name: 'AuditLogSearch' } }
    /**
     * Find zero or one AuditLogSearch that matches the filter.
     * @param {AuditLogSearchFindUniqueArgs} args - Arguments to find a AuditLogSearch
     * @example
     * // Get one AuditLogSearch
     * const auditLogSearch = await prisma.auditLogSearch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogSearchFindUniqueArgs>(args: SelectSubset<T, AuditLogSearchFindUniqueArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLogSearch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogSearchFindUniqueOrThrowArgs} args - Arguments to find a AuditLogSearch
     * @example
     * // Get one AuditLogSearch
     * const auditLogSearch = await prisma.auditLogSearch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogSearchFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogSearchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLogSearch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogSearchFindFirstArgs} args - Arguments to find a AuditLogSearch
     * @example
     * // Get one AuditLogSearch
     * const auditLogSearch = await prisma.auditLogSearch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogSearchFindFirstArgs>(args?: SelectSubset<T, AuditLogSearchFindFirstArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLogSearch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogSearchFindFirstOrThrowArgs} args - Arguments to find a AuditLogSearch
     * @example
     * // Get one AuditLogSearch
     * const auditLogSearch = await prisma.auditLogSearch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogSearchFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogSearchFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogSearches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogSearchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogSearches
     * const auditLogSearches = await prisma.auditLogSearch.findMany()
     * 
     * // Get first 10 AuditLogSearches
     * const auditLogSearches = await prisma.auditLogSearch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogSearchWithIdOnly = await prisma.auditLogSearch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogSearchFindManyArgs>(args?: SelectSubset<T, AuditLogSearchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLogSearch.
     * @param {AuditLogSearchCreateArgs} args - Arguments to create a AuditLogSearch.
     * @example
     * // Create one AuditLogSearch
     * const AuditLogSearch = await prisma.auditLogSearch.create({
     *   data: {
     *     // ... data to create a AuditLogSearch
     *   }
     * })
     * 
     */
    create<T extends AuditLogSearchCreateArgs>(args: SelectSubset<T, AuditLogSearchCreateArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogSearches.
     * @param {AuditLogSearchCreateManyArgs} args - Arguments to create many AuditLogSearches.
     * @example
     * // Create many AuditLogSearches
     * const auditLogSearch = await prisma.auditLogSearch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogSearchCreateManyArgs>(args?: SelectSubset<T, AuditLogSearchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogSearches and returns the data saved in the database.
     * @param {AuditLogSearchCreateManyAndReturnArgs} args - Arguments to create many AuditLogSearches.
     * @example
     * // Create many AuditLogSearches
     * const auditLogSearch = await prisma.auditLogSearch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogSearches and only return the `id`
     * const auditLogSearchWithIdOnly = await prisma.auditLogSearch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogSearchCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogSearchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLogSearch.
     * @param {AuditLogSearchDeleteArgs} args - Arguments to delete one AuditLogSearch.
     * @example
     * // Delete one AuditLogSearch
     * const AuditLogSearch = await prisma.auditLogSearch.delete({
     *   where: {
     *     // ... filter to delete one AuditLogSearch
     *   }
     * })
     * 
     */
    delete<T extends AuditLogSearchDeleteArgs>(args: SelectSubset<T, AuditLogSearchDeleteArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLogSearch.
     * @param {AuditLogSearchUpdateArgs} args - Arguments to update one AuditLogSearch.
     * @example
     * // Update one AuditLogSearch
     * const auditLogSearch = await prisma.auditLogSearch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogSearchUpdateArgs>(args: SelectSubset<T, AuditLogSearchUpdateArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogSearches.
     * @param {AuditLogSearchDeleteManyArgs} args - Arguments to filter AuditLogSearches to delete.
     * @example
     * // Delete a few AuditLogSearches
     * const { count } = await prisma.auditLogSearch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogSearchDeleteManyArgs>(args?: SelectSubset<T, AuditLogSearchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogSearchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogSearches
     * const auditLogSearch = await prisma.auditLogSearch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogSearchUpdateManyArgs>(args: SelectSubset<T, AuditLogSearchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogSearches and returns the data updated in the database.
     * @param {AuditLogSearchUpdateManyAndReturnArgs} args - Arguments to update many AuditLogSearches.
     * @example
     * // Update many AuditLogSearches
     * const auditLogSearch = await prisma.auditLogSearch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogSearches and only return the `id`
     * const auditLogSearchWithIdOnly = await prisma.auditLogSearch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogSearchUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogSearchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLogSearch.
     * @param {AuditLogSearchUpsertArgs} args - Arguments to update or create a AuditLogSearch.
     * @example
     * // Update or create a AuditLogSearch
     * const auditLogSearch = await prisma.auditLogSearch.upsert({
     *   create: {
     *     // ... data to create a AuditLogSearch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLogSearch we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogSearchUpsertArgs>(args: SelectSubset<T, AuditLogSearchUpsertArgs<ExtArgs>>): Prisma__AuditLogSearchClient<$Result.GetResult<Prisma.$AuditLogSearchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogSearchCountArgs} args - Arguments to filter AuditLogSearches to count.
     * @example
     * // Count the number of AuditLogSearches
     * const count = await prisma.auditLogSearch.count({
     *   where: {
     *     // ... the filter for the AuditLogSearches we want to count
     *   }
     * })
    **/
    count<T extends AuditLogSearchCountArgs>(
      args?: Subset<T, AuditLogSearchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogSearchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLogSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogSearchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogSearchAggregateArgs>(args: Subset<T, AuditLogSearchAggregateArgs>): Prisma.PrismaPromise<GetAuditLogSearchAggregateType<T>>

    /**
     * Group by AuditLogSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogSearchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogSearchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogSearchGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogSearchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogSearchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogSearchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLogSearch model
   */
  readonly fields: AuditLogSearchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLogSearch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogSearchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends AuditLogSearch$companyArgs<ExtArgs> = {}>(args?: Subset<T, AuditLogSearch$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLogSearch model
   */
  interface AuditLogSearchFieldRefs {
    readonly id: FieldRef<"AuditLogSearch", 'String'>
    readonly userId: FieldRef<"AuditLogSearch", 'String'>
    readonly companyId: FieldRef<"AuditLogSearch", 'String'>
    readonly name: FieldRef<"AuditLogSearch", 'String'>
    readonly searchQuery: FieldRef<"AuditLogSearch", 'String'>
    readonly filters: FieldRef<"AuditLogSearch", 'Json'>
    readonly createdAt: FieldRef<"AuditLogSearch", 'DateTime'>
    readonly lastUsedAt: FieldRef<"AuditLogSearch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLogSearch findUnique
   */
  export type AuditLogSearchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogSearch to fetch.
     */
    where: AuditLogSearchWhereUniqueInput
  }

  /**
   * AuditLogSearch findUniqueOrThrow
   */
  export type AuditLogSearchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogSearch to fetch.
     */
    where: AuditLogSearchWhereUniqueInput
  }

  /**
   * AuditLogSearch findFirst
   */
  export type AuditLogSearchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogSearch to fetch.
     */
    where?: AuditLogSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogSearches to fetch.
     */
    orderBy?: AuditLogSearchOrderByWithRelationInput | AuditLogSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogSearches.
     */
    cursor?: AuditLogSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogSearches.
     */
    distinct?: AuditLogSearchScalarFieldEnum | AuditLogSearchScalarFieldEnum[]
  }

  /**
   * AuditLogSearch findFirstOrThrow
   */
  export type AuditLogSearchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogSearch to fetch.
     */
    where?: AuditLogSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogSearches to fetch.
     */
    orderBy?: AuditLogSearchOrderByWithRelationInput | AuditLogSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogSearches.
     */
    cursor?: AuditLogSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogSearches.
     */
    distinct?: AuditLogSearchScalarFieldEnum | AuditLogSearchScalarFieldEnum[]
  }

  /**
   * AuditLogSearch findMany
   */
  export type AuditLogSearchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogSearches to fetch.
     */
    where?: AuditLogSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogSearches to fetch.
     */
    orderBy?: AuditLogSearchOrderByWithRelationInput | AuditLogSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogSearches.
     */
    cursor?: AuditLogSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogSearches.
     */
    skip?: number
    distinct?: AuditLogSearchScalarFieldEnum | AuditLogSearchScalarFieldEnum[]
  }

  /**
   * AuditLogSearch create
   */
  export type AuditLogSearchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLogSearch.
     */
    data: XOR<AuditLogSearchCreateInput, AuditLogSearchUncheckedCreateInput>
  }

  /**
   * AuditLogSearch createMany
   */
  export type AuditLogSearchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogSearches.
     */
    data: AuditLogSearchCreateManyInput | AuditLogSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLogSearch createManyAndReturn
   */
  export type AuditLogSearchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogSearches.
     */
    data: AuditLogSearchCreateManyInput | AuditLogSearchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLogSearch update
   */
  export type AuditLogSearchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLogSearch.
     */
    data: XOR<AuditLogSearchUpdateInput, AuditLogSearchUncheckedUpdateInput>
    /**
     * Choose, which AuditLogSearch to update.
     */
    where: AuditLogSearchWhereUniqueInput
  }

  /**
   * AuditLogSearch updateMany
   */
  export type AuditLogSearchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogSearches.
     */
    data: XOR<AuditLogSearchUpdateManyMutationInput, AuditLogSearchUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogSearches to update
     */
    where?: AuditLogSearchWhereInput
    /**
     * Limit how many AuditLogSearches to update.
     */
    limit?: number
  }

  /**
   * AuditLogSearch updateManyAndReturn
   */
  export type AuditLogSearchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogSearches.
     */
    data: XOR<AuditLogSearchUpdateManyMutationInput, AuditLogSearchUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogSearches to update
     */
    where?: AuditLogSearchWhereInput
    /**
     * Limit how many AuditLogSearches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLogSearch upsert
   */
  export type AuditLogSearchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLogSearch to update in case it exists.
     */
    where: AuditLogSearchWhereUniqueInput
    /**
     * In case the AuditLogSearch found by the `where` argument doesn't exist, create a new AuditLogSearch with this data.
     */
    create: XOR<AuditLogSearchCreateInput, AuditLogSearchUncheckedCreateInput>
    /**
     * In case the AuditLogSearch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogSearchUpdateInput, AuditLogSearchUncheckedUpdateInput>
  }

  /**
   * AuditLogSearch delete
   */
  export type AuditLogSearchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
    /**
     * Filter which AuditLogSearch to delete.
     */
    where: AuditLogSearchWhereUniqueInput
  }

  /**
   * AuditLogSearch deleteMany
   */
  export type AuditLogSearchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogSearches to delete
     */
    where?: AuditLogSearchWhereInput
    /**
     * Limit how many AuditLogSearches to delete.
     */
    limit?: number
  }

  /**
   * AuditLogSearch.company
   */
  export type AuditLogSearch$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * AuditLogSearch without action
   */
  export type AuditLogSearchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogSearch
     */
    select?: AuditLogSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogSearch
     */
    omit?: AuditLogSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogSearchInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    updatedAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    key?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    key?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "updatedAt", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly key: FieldRef<"Settings", 'String'>
    readonly value: FieldRef<"Settings", 'Json'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model ThreatEvent
   */

  export type AggregateThreatEvent = {
    _count: ThreatEventCountAggregateOutputType | null
    _min: ThreatEventMinAggregateOutputType | null
    _max: ThreatEventMaxAggregateOutputType | null
  }

  export type ThreatEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    threatType: $Enums.ThreatType | null
    severity: $Enums.ThreatSeverity | null
    ipAddress: string | null
    userAgent: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type ThreatEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    threatType: $Enums.ThreatType | null
    severity: $Enums.ThreatSeverity | null
    ipAddress: string | null
    userAgent: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
  }

  export type ThreatEventCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    threatType: number
    severity: number
    ipAddress: number
    userAgent: number
    details: number
    isResolved: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    _all: number
  }


  export type ThreatEventMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    threatType?: true
    severity?: true
    ipAddress?: true
    userAgent?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type ThreatEventMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    threatType?: true
    severity?: true
    ipAddress?: true
    userAgent?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
  }

  export type ThreatEventCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    threatType?: true
    severity?: true
    ipAddress?: true
    userAgent?: true
    details?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    _all?: true
  }

  export type ThreatEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreatEvent to aggregate.
     */
    where?: ThreatEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEvents to fetch.
     */
    orderBy?: ThreatEventOrderByWithRelationInput | ThreatEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreatEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreatEvents
    **/
    _count?: true | ThreatEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreatEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreatEventMaxAggregateInputType
  }

  export type GetThreatEventAggregateType<T extends ThreatEventAggregateArgs> = {
        [P in keyof T & keyof AggregateThreatEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreatEvent[P]>
      : GetScalarType<T[P], AggregateThreatEvent[P]>
  }




  export type ThreatEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreatEventWhereInput
    orderBy?: ThreatEventOrderByWithAggregationInput | ThreatEventOrderByWithAggregationInput[]
    by: ThreatEventScalarFieldEnum[] | ThreatEventScalarFieldEnum
    having?: ThreatEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreatEventCountAggregateInputType | true
    _min?: ThreatEventMinAggregateInputType
    _max?: ThreatEventMaxAggregateInputType
  }

  export type ThreatEventGroupByOutputType = {
    id: string
    userId: string | null
    companyId: string | null
    threatType: $Enums.ThreatType
    severity: $Enums.ThreatSeverity
    ipAddress: string | null
    userAgent: string | null
    details: JsonValue | null
    isResolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    _count: ThreatEventCountAggregateOutputType | null
    _min: ThreatEventMinAggregateOutputType | null
    _max: ThreatEventMaxAggregateOutputType | null
  }

  type GetThreatEventGroupByPayload<T extends ThreatEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreatEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreatEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreatEventGroupByOutputType[P]>
            : GetScalarType<T[P], ThreatEventGroupByOutputType[P]>
        }
      >
    >


  export type ThreatEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    threatType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    details?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    user?: boolean | ThreatEvent$userArgs<ExtArgs>
    company?: boolean | ThreatEvent$companyArgs<ExtArgs>
  }, ExtArgs["result"]["threatEvent"]>

  export type ThreatEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    threatType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    details?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    user?: boolean | ThreatEvent$userArgs<ExtArgs>
    company?: boolean | ThreatEvent$companyArgs<ExtArgs>
  }, ExtArgs["result"]["threatEvent"]>

  export type ThreatEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    threatType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    details?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    user?: boolean | ThreatEvent$userArgs<ExtArgs>
    company?: boolean | ThreatEvent$companyArgs<ExtArgs>
  }, ExtArgs["result"]["threatEvent"]>

  export type ThreatEventSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    threatType?: boolean
    severity?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    details?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
  }

  export type ThreatEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "threatType" | "severity" | "ipAddress" | "userAgent" | "details" | "isResolved" | "resolvedAt" | "resolvedBy" | "createdAt", ExtArgs["result"]["threatEvent"]>
  export type ThreatEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ThreatEvent$userArgs<ExtArgs>
    company?: boolean | ThreatEvent$companyArgs<ExtArgs>
  }
  export type ThreatEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ThreatEvent$userArgs<ExtArgs>
    company?: boolean | ThreatEvent$companyArgs<ExtArgs>
  }
  export type ThreatEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ThreatEvent$userArgs<ExtArgs>
    company?: boolean | ThreatEvent$companyArgs<ExtArgs>
  }

  export type $ThreatEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThreatEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      companyId: string | null
      threatType: $Enums.ThreatType
      severity: $Enums.ThreatSeverity
      ipAddress: string | null
      userAgent: string | null
      details: Prisma.JsonValue | null
      isResolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["threatEvent"]>
    composites: {}
  }

  type ThreatEventGetPayload<S extends boolean | null | undefined | ThreatEventDefaultArgs> = $Result.GetResult<Prisma.$ThreatEventPayload, S>

  type ThreatEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThreatEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThreatEventCountAggregateInputType | true
    }

  export interface ThreatEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThreatEvent'], meta: { name: 'ThreatEvent' } }
    /**
     * Find zero or one ThreatEvent that matches the filter.
     * @param {ThreatEventFindUniqueArgs} args - Arguments to find a ThreatEvent
     * @example
     * // Get one ThreatEvent
     * const threatEvent = await prisma.threatEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreatEventFindUniqueArgs>(args: SelectSubset<T, ThreatEventFindUniqueArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThreatEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreatEventFindUniqueOrThrowArgs} args - Arguments to find a ThreatEvent
     * @example
     * // Get one ThreatEvent
     * const threatEvent = await prisma.threatEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreatEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreatEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreatEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEventFindFirstArgs} args - Arguments to find a ThreatEvent
     * @example
     * // Get one ThreatEvent
     * const threatEvent = await prisma.threatEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreatEventFindFirstArgs>(args?: SelectSubset<T, ThreatEventFindFirstArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreatEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEventFindFirstOrThrowArgs} args - Arguments to find a ThreatEvent
     * @example
     * // Get one ThreatEvent
     * const threatEvent = await prisma.threatEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreatEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreatEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThreatEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreatEvents
     * const threatEvents = await prisma.threatEvent.findMany()
     * 
     * // Get first 10 ThreatEvents
     * const threatEvents = await prisma.threatEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threatEventWithIdOnly = await prisma.threatEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreatEventFindManyArgs>(args?: SelectSubset<T, ThreatEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThreatEvent.
     * @param {ThreatEventCreateArgs} args - Arguments to create a ThreatEvent.
     * @example
     * // Create one ThreatEvent
     * const ThreatEvent = await prisma.threatEvent.create({
     *   data: {
     *     // ... data to create a ThreatEvent
     *   }
     * })
     * 
     */
    create<T extends ThreatEventCreateArgs>(args: SelectSubset<T, ThreatEventCreateArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThreatEvents.
     * @param {ThreatEventCreateManyArgs} args - Arguments to create many ThreatEvents.
     * @example
     * // Create many ThreatEvents
     * const threatEvent = await prisma.threatEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreatEventCreateManyArgs>(args?: SelectSubset<T, ThreatEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThreatEvents and returns the data saved in the database.
     * @param {ThreatEventCreateManyAndReturnArgs} args - Arguments to create many ThreatEvents.
     * @example
     * // Create many ThreatEvents
     * const threatEvent = await prisma.threatEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThreatEvents and only return the `id`
     * const threatEventWithIdOnly = await prisma.threatEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreatEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreatEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThreatEvent.
     * @param {ThreatEventDeleteArgs} args - Arguments to delete one ThreatEvent.
     * @example
     * // Delete one ThreatEvent
     * const ThreatEvent = await prisma.threatEvent.delete({
     *   where: {
     *     // ... filter to delete one ThreatEvent
     *   }
     * })
     * 
     */
    delete<T extends ThreatEventDeleteArgs>(args: SelectSubset<T, ThreatEventDeleteArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThreatEvent.
     * @param {ThreatEventUpdateArgs} args - Arguments to update one ThreatEvent.
     * @example
     * // Update one ThreatEvent
     * const threatEvent = await prisma.threatEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreatEventUpdateArgs>(args: SelectSubset<T, ThreatEventUpdateArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThreatEvents.
     * @param {ThreatEventDeleteManyArgs} args - Arguments to filter ThreatEvents to delete.
     * @example
     * // Delete a few ThreatEvents
     * const { count } = await prisma.threatEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreatEventDeleteManyArgs>(args?: SelectSubset<T, ThreatEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreatEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreatEvents
     * const threatEvent = await prisma.threatEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreatEventUpdateManyArgs>(args: SelectSubset<T, ThreatEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreatEvents and returns the data updated in the database.
     * @param {ThreatEventUpdateManyAndReturnArgs} args - Arguments to update many ThreatEvents.
     * @example
     * // Update many ThreatEvents
     * const threatEvent = await prisma.threatEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThreatEvents and only return the `id`
     * const threatEventWithIdOnly = await prisma.threatEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThreatEventUpdateManyAndReturnArgs>(args: SelectSubset<T, ThreatEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThreatEvent.
     * @param {ThreatEventUpsertArgs} args - Arguments to update or create a ThreatEvent.
     * @example
     * // Update or create a ThreatEvent
     * const threatEvent = await prisma.threatEvent.upsert({
     *   create: {
     *     // ... data to create a ThreatEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreatEvent we want to update
     *   }
     * })
     */
    upsert<T extends ThreatEventUpsertArgs>(args: SelectSubset<T, ThreatEventUpsertArgs<ExtArgs>>): Prisma__ThreatEventClient<$Result.GetResult<Prisma.$ThreatEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThreatEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEventCountArgs} args - Arguments to filter ThreatEvents to count.
     * @example
     * // Count the number of ThreatEvents
     * const count = await prisma.threatEvent.count({
     *   where: {
     *     // ... the filter for the ThreatEvents we want to count
     *   }
     * })
    **/
    count<T extends ThreatEventCountArgs>(
      args?: Subset<T, ThreatEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreatEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreatEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreatEventAggregateArgs>(args: Subset<T, ThreatEventAggregateArgs>): Prisma.PrismaPromise<GetThreatEventAggregateType<T>>

    /**
     * Group by ThreatEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreatEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreatEventGroupByArgs['orderBy'] }
        : { orderBy?: ThreatEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreatEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreatEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThreatEvent model
   */
  readonly fields: ThreatEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreatEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreatEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ThreatEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, ThreatEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends ThreatEvent$companyArgs<ExtArgs> = {}>(args?: Subset<T, ThreatEvent$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThreatEvent model
   */
  interface ThreatEventFieldRefs {
    readonly id: FieldRef<"ThreatEvent", 'String'>
    readonly userId: FieldRef<"ThreatEvent", 'String'>
    readonly companyId: FieldRef<"ThreatEvent", 'String'>
    readonly threatType: FieldRef<"ThreatEvent", 'ThreatType'>
    readonly severity: FieldRef<"ThreatEvent", 'ThreatSeverity'>
    readonly ipAddress: FieldRef<"ThreatEvent", 'String'>
    readonly userAgent: FieldRef<"ThreatEvent", 'String'>
    readonly details: FieldRef<"ThreatEvent", 'Json'>
    readonly isResolved: FieldRef<"ThreatEvent", 'Boolean'>
    readonly resolvedAt: FieldRef<"ThreatEvent", 'DateTime'>
    readonly resolvedBy: FieldRef<"ThreatEvent", 'String'>
    readonly createdAt: FieldRef<"ThreatEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ThreatEvent findUnique
   */
  export type ThreatEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEvent to fetch.
     */
    where: ThreatEventWhereUniqueInput
  }

  /**
   * ThreatEvent findUniqueOrThrow
   */
  export type ThreatEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEvent to fetch.
     */
    where: ThreatEventWhereUniqueInput
  }

  /**
   * ThreatEvent findFirst
   */
  export type ThreatEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEvent to fetch.
     */
    where?: ThreatEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEvents to fetch.
     */
    orderBy?: ThreatEventOrderByWithRelationInput | ThreatEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreatEvents.
     */
    cursor?: ThreatEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreatEvents.
     */
    distinct?: ThreatEventScalarFieldEnum | ThreatEventScalarFieldEnum[]
  }

  /**
   * ThreatEvent findFirstOrThrow
   */
  export type ThreatEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEvent to fetch.
     */
    where?: ThreatEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEvents to fetch.
     */
    orderBy?: ThreatEventOrderByWithRelationInput | ThreatEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreatEvents.
     */
    cursor?: ThreatEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreatEvents.
     */
    distinct?: ThreatEventScalarFieldEnum | ThreatEventScalarFieldEnum[]
  }

  /**
   * ThreatEvent findMany
   */
  export type ThreatEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * Filter, which ThreatEvents to fetch.
     */
    where?: ThreatEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatEvents to fetch.
     */
    orderBy?: ThreatEventOrderByWithRelationInput | ThreatEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreatEvents.
     */
    cursor?: ThreatEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatEvents.
     */
    skip?: number
    distinct?: ThreatEventScalarFieldEnum | ThreatEventScalarFieldEnum[]
  }

  /**
   * ThreatEvent create
   */
  export type ThreatEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ThreatEvent.
     */
    data: XOR<ThreatEventCreateInput, ThreatEventUncheckedCreateInput>
  }

  /**
   * ThreatEvent createMany
   */
  export type ThreatEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThreatEvents.
     */
    data: ThreatEventCreateManyInput | ThreatEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThreatEvent createManyAndReturn
   */
  export type ThreatEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * The data used to create many ThreatEvents.
     */
    data: ThreatEventCreateManyInput | ThreatEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThreatEvent update
   */
  export type ThreatEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ThreatEvent.
     */
    data: XOR<ThreatEventUpdateInput, ThreatEventUncheckedUpdateInput>
    /**
     * Choose, which ThreatEvent to update.
     */
    where: ThreatEventWhereUniqueInput
  }

  /**
   * ThreatEvent updateMany
   */
  export type ThreatEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThreatEvents.
     */
    data: XOR<ThreatEventUpdateManyMutationInput, ThreatEventUncheckedUpdateManyInput>
    /**
     * Filter which ThreatEvents to update
     */
    where?: ThreatEventWhereInput
    /**
     * Limit how many ThreatEvents to update.
     */
    limit?: number
  }

  /**
   * ThreatEvent updateManyAndReturn
   */
  export type ThreatEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * The data used to update ThreatEvents.
     */
    data: XOR<ThreatEventUpdateManyMutationInput, ThreatEventUncheckedUpdateManyInput>
    /**
     * Filter which ThreatEvents to update
     */
    where?: ThreatEventWhereInput
    /**
     * Limit how many ThreatEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThreatEvent upsert
   */
  export type ThreatEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ThreatEvent to update in case it exists.
     */
    where: ThreatEventWhereUniqueInput
    /**
     * In case the ThreatEvent found by the `where` argument doesn't exist, create a new ThreatEvent with this data.
     */
    create: XOR<ThreatEventCreateInput, ThreatEventUncheckedCreateInput>
    /**
     * In case the ThreatEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreatEventUpdateInput, ThreatEventUncheckedUpdateInput>
  }

  /**
   * ThreatEvent delete
   */
  export type ThreatEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
    /**
     * Filter which ThreatEvent to delete.
     */
    where: ThreatEventWhereUniqueInput
  }

  /**
   * ThreatEvent deleteMany
   */
  export type ThreatEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreatEvents to delete
     */
    where?: ThreatEventWhereInput
    /**
     * Limit how many ThreatEvents to delete.
     */
    limit?: number
  }

  /**
   * ThreatEvent.user
   */
  export type ThreatEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ThreatEvent.company
   */
  export type ThreatEvent$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * ThreatEvent without action
   */
  export type ThreatEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatEvent
     */
    select?: ThreatEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatEvent
     */
    omit?: ThreatEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreatEventInclude<ExtArgs> | null
  }


  /**
   * Model RateLimit
   */

  export type AggregateRateLimit = {
    _count: RateLimitCountAggregateOutputType | null
    _avg: RateLimitAvgAggregateOutputType | null
    _sum: RateLimitSumAggregateOutputType | null
    _min: RateLimitMinAggregateOutputType | null
    _max: RateLimitMaxAggregateOutputType | null
  }

  export type RateLimitAvgAggregateOutputType = {
    count: number | null
  }

  export type RateLimitSumAggregateOutputType = {
    count: number | null
  }

  export type RateLimitMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    identifierType: $Enums.RateLimitType | null
    action: string | null
    count: number | null
    windowStart: Date | null
    windowEnd: Date | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RateLimitMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    identifierType: $Enums.RateLimitType | null
    action: string | null
    count: number | null
    windowStart: Date | null
    windowEnd: Date | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RateLimitCountAggregateOutputType = {
    id: number
    identifier: number
    identifierType: number
    action: number
    count: number
    windowStart: number
    windowEnd: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RateLimitAvgAggregateInputType = {
    count?: true
  }

  export type RateLimitSumAggregateInputType = {
    count?: true
  }

  export type RateLimitMinAggregateInputType = {
    id?: true
    identifier?: true
    identifierType?: true
    action?: true
    count?: true
    windowStart?: true
    windowEnd?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RateLimitMaxAggregateInputType = {
    id?: true
    identifier?: true
    identifierType?: true
    action?: true
    count?: true
    windowStart?: true
    windowEnd?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RateLimitCountAggregateInputType = {
    id?: true
    identifier?: true
    identifierType?: true
    action?: true
    count?: true
    windowStart?: true
    windowEnd?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RateLimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimit to aggregate.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateLimits
    **/
    _count?: true | RateLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateLimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateLimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateLimitMaxAggregateInputType
  }

  export type GetRateLimitAggregateType<T extends RateLimitAggregateArgs> = {
        [P in keyof T & keyof AggregateRateLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimit[P]>
      : GetScalarType<T[P], AggregateRateLimit[P]>
  }




  export type RateLimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateLimitWhereInput
    orderBy?: RateLimitOrderByWithAggregationInput | RateLimitOrderByWithAggregationInput[]
    by: RateLimitScalarFieldEnum[] | RateLimitScalarFieldEnum
    having?: RateLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateLimitCountAggregateInputType | true
    _avg?: RateLimitAvgAggregateInputType
    _sum?: RateLimitSumAggregateInputType
    _min?: RateLimitMinAggregateInputType
    _max?: RateLimitMaxAggregateInputType
  }

  export type RateLimitGroupByOutputType = {
    id: string
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    count: number
    windowStart: Date
    windowEnd: Date
    companyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RateLimitCountAggregateOutputType | null
    _avg: RateLimitAvgAggregateOutputType | null
    _sum: RateLimitSumAggregateOutputType | null
    _min: RateLimitMinAggregateOutputType | null
    _max: RateLimitMaxAggregateOutputType | null
  }

  type GetRateLimitGroupByPayload<T extends RateLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateLimitGroupByOutputType[P]>
            : GetScalarType<T[P], RateLimitGroupByOutputType[P]>
        }
      >
    >


  export type RateLimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    identifierType?: boolean
    action?: boolean
    count?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | RateLimit$companyArgs<ExtArgs>
  }, ExtArgs["result"]["rateLimit"]>

  export type RateLimitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    identifierType?: boolean
    action?: boolean
    count?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | RateLimit$companyArgs<ExtArgs>
  }, ExtArgs["result"]["rateLimit"]>

  export type RateLimitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    identifierType?: boolean
    action?: boolean
    count?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | RateLimit$companyArgs<ExtArgs>
  }, ExtArgs["result"]["rateLimit"]>

  export type RateLimitSelectScalar = {
    id?: boolean
    identifier?: boolean
    identifierType?: boolean
    action?: boolean
    count?: boolean
    windowStart?: boolean
    windowEnd?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RateLimitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "identifierType" | "action" | "count" | "windowStart" | "windowEnd" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["rateLimit"]>
  export type RateLimitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | RateLimit$companyArgs<ExtArgs>
  }
  export type RateLimitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | RateLimit$companyArgs<ExtArgs>
  }
  export type RateLimitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | RateLimit$companyArgs<ExtArgs>
  }

  export type $RateLimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RateLimit"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      identifierType: $Enums.RateLimitType
      action: string
      count: number
      windowStart: Date
      windowEnd: Date
      companyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rateLimit"]>
    composites: {}
  }

  type RateLimitGetPayload<S extends boolean | null | undefined | RateLimitDefaultArgs> = $Result.GetResult<Prisma.$RateLimitPayload, S>

  type RateLimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RateLimitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RateLimitCountAggregateInputType | true
    }

  export interface RateLimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RateLimit'], meta: { name: 'RateLimit' } }
    /**
     * Find zero or one RateLimit that matches the filter.
     * @param {RateLimitFindUniqueArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitFindUniqueArgs>(args: SelectSubset<T, RateLimitFindUniqueArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RateLimit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RateLimitFindUniqueOrThrowArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitFindUniqueOrThrowArgs>(args: SelectSubset<T, RateLimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RateLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitFindFirstArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitFindFirstArgs>(args?: SelectSubset<T, RateLimitFindFirstArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RateLimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitFindFirstOrThrowArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitFindFirstOrThrowArgs>(args?: SelectSubset<T, RateLimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RateLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimits
     * const rateLimits = await prisma.rateLimit.findMany()
     * 
     * // Get first 10 RateLimits
     * const rateLimits = await prisma.rateLimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateLimitWithIdOnly = await prisma.rateLimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RateLimitFindManyArgs>(args?: SelectSubset<T, RateLimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RateLimit.
     * @param {RateLimitCreateArgs} args - Arguments to create a RateLimit.
     * @example
     * // Create one RateLimit
     * const RateLimit = await prisma.rateLimit.create({
     *   data: {
     *     // ... data to create a RateLimit
     *   }
     * })
     * 
     */
    create<T extends RateLimitCreateArgs>(args: SelectSubset<T, RateLimitCreateArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RateLimits.
     * @param {RateLimitCreateManyArgs} args - Arguments to create many RateLimits.
     * @example
     * // Create many RateLimits
     * const rateLimit = await prisma.rateLimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RateLimitCreateManyArgs>(args?: SelectSubset<T, RateLimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RateLimits and returns the data saved in the database.
     * @param {RateLimitCreateManyAndReturnArgs} args - Arguments to create many RateLimits.
     * @example
     * // Create many RateLimits
     * const rateLimit = await prisma.rateLimit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RateLimits and only return the `id`
     * const rateLimitWithIdOnly = await prisma.rateLimit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RateLimitCreateManyAndReturnArgs>(args?: SelectSubset<T, RateLimitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RateLimit.
     * @param {RateLimitDeleteArgs} args - Arguments to delete one RateLimit.
     * @example
     * // Delete one RateLimit
     * const RateLimit = await prisma.rateLimit.delete({
     *   where: {
     *     // ... filter to delete one RateLimit
     *   }
     * })
     * 
     */
    delete<T extends RateLimitDeleteArgs>(args: SelectSubset<T, RateLimitDeleteArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RateLimit.
     * @param {RateLimitUpdateArgs} args - Arguments to update one RateLimit.
     * @example
     * // Update one RateLimit
     * const rateLimit = await prisma.rateLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RateLimitUpdateArgs>(args: SelectSubset<T, RateLimitUpdateArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RateLimits.
     * @param {RateLimitDeleteManyArgs} args - Arguments to filter RateLimits to delete.
     * @example
     * // Delete a few RateLimits
     * const { count } = await prisma.rateLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RateLimitDeleteManyArgs>(args?: SelectSubset<T, RateLimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimits
     * const rateLimit = await prisma.rateLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RateLimitUpdateManyArgs>(args: SelectSubset<T, RateLimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateLimits and returns the data updated in the database.
     * @param {RateLimitUpdateManyAndReturnArgs} args - Arguments to update many RateLimits.
     * @example
     * // Update many RateLimits
     * const rateLimit = await prisma.rateLimit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RateLimits and only return the `id`
     * const rateLimitWithIdOnly = await prisma.rateLimit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RateLimitUpdateManyAndReturnArgs>(args: SelectSubset<T, RateLimitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RateLimit.
     * @param {RateLimitUpsertArgs} args - Arguments to update or create a RateLimit.
     * @example
     * // Update or create a RateLimit
     * const rateLimit = await prisma.rateLimit.upsert({
     *   create: {
     *     // ... data to create a RateLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimit we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitUpsertArgs>(args: SelectSubset<T, RateLimitUpsertArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RateLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitCountArgs} args - Arguments to filter RateLimits to count.
     * @example
     * // Count the number of RateLimits
     * const count = await prisma.rateLimit.count({
     *   where: {
     *     // ... the filter for the RateLimits we want to count
     *   }
     * })
    **/
    count<T extends RateLimitCountArgs>(
      args?: Subset<T, RateLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateLimitAggregateArgs>(args: Subset<T, RateLimitAggregateArgs>): Prisma.PrismaPromise<GetRateLimitAggregateType<T>>

    /**
     * Group by RateLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RateLimit model
   */
  readonly fields: RateLimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends RateLimit$companyArgs<ExtArgs> = {}>(args?: Subset<T, RateLimit$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RateLimit model
   */
  interface RateLimitFieldRefs {
    readonly id: FieldRef<"RateLimit", 'String'>
    readonly identifier: FieldRef<"RateLimit", 'String'>
    readonly identifierType: FieldRef<"RateLimit", 'RateLimitType'>
    readonly action: FieldRef<"RateLimit", 'String'>
    readonly count: FieldRef<"RateLimit", 'Int'>
    readonly windowStart: FieldRef<"RateLimit", 'DateTime'>
    readonly windowEnd: FieldRef<"RateLimit", 'DateTime'>
    readonly companyId: FieldRef<"RateLimit", 'String'>
    readonly createdAt: FieldRef<"RateLimit", 'DateTime'>
    readonly updatedAt: FieldRef<"RateLimit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RateLimit findUnique
   */
  export type RateLimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit findUniqueOrThrow
   */
  export type RateLimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit findFirst
   */
  export type RateLimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimits.
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimits.
     */
    distinct?: RateLimitScalarFieldEnum | RateLimitScalarFieldEnum[]
  }

  /**
   * RateLimit findFirstOrThrow
   */
  export type RateLimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimits.
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimits.
     */
    distinct?: RateLimitScalarFieldEnum | RateLimitScalarFieldEnum[]
  }

  /**
   * RateLimit findMany
   */
  export type RateLimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * Filter, which RateLimits to fetch.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateLimits.
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    distinct?: RateLimitScalarFieldEnum | RateLimitScalarFieldEnum[]
  }

  /**
   * RateLimit create
   */
  export type RateLimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * The data needed to create a RateLimit.
     */
    data: XOR<RateLimitCreateInput, RateLimitUncheckedCreateInput>
  }

  /**
   * RateLimit createMany
   */
  export type RateLimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RateLimits.
     */
    data: RateLimitCreateManyInput | RateLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimit createManyAndReturn
   */
  export type RateLimitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * The data used to create many RateLimits.
     */
    data: RateLimitCreateManyInput | RateLimitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RateLimit update
   */
  export type RateLimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * The data needed to update a RateLimit.
     */
    data: XOR<RateLimitUpdateInput, RateLimitUncheckedUpdateInput>
    /**
     * Choose, which RateLimit to update.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit updateMany
   */
  export type RateLimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RateLimits.
     */
    data: XOR<RateLimitUpdateManyMutationInput, RateLimitUncheckedUpdateManyInput>
    /**
     * Filter which RateLimits to update
     */
    where?: RateLimitWhereInput
    /**
     * Limit how many RateLimits to update.
     */
    limit?: number
  }

  /**
   * RateLimit updateManyAndReturn
   */
  export type RateLimitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * The data used to update RateLimits.
     */
    data: XOR<RateLimitUpdateManyMutationInput, RateLimitUncheckedUpdateManyInput>
    /**
     * Filter which RateLimits to update
     */
    where?: RateLimitWhereInput
    /**
     * Limit how many RateLimits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RateLimit upsert
   */
  export type RateLimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * The filter to search for the RateLimit to update in case it exists.
     */
    where: RateLimitWhereUniqueInput
    /**
     * In case the RateLimit found by the `where` argument doesn't exist, create a new RateLimit with this data.
     */
    create: XOR<RateLimitCreateInput, RateLimitUncheckedCreateInput>
    /**
     * In case the RateLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitUpdateInput, RateLimitUncheckedUpdateInput>
  }

  /**
   * RateLimit delete
   */
  export type RateLimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
    /**
     * Filter which RateLimit to delete.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit deleteMany
   */
  export type RateLimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimits to delete
     */
    where?: RateLimitWhereInput
    /**
     * Limit how many RateLimits to delete.
     */
    limit?: number
  }

  /**
   * RateLimit.company
   */
  export type RateLimit$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * RateLimit without action
   */
  export type RateLimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RateLimit
     */
    omit?: RateLimitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isSystem" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Role$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Role$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly createdById: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.createdBy
   */
  export type Role$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string | null
    category: string
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name" | "description" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string | null
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly key: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model MfaCredential
   */

  export type AggregateMfaCredential = {
    _count: MfaCredentialCountAggregateOutputType | null
    _avg: MfaCredentialAvgAggregateOutputType | null
    _sum: MfaCredentialSumAggregateOutputType | null
    _min: MfaCredentialMinAggregateOutputType | null
    _max: MfaCredentialMaxAggregateOutputType | null
  }

  export type MfaCredentialAvgAggregateOutputType = {
    counter: number | null
  }

  export type MfaCredentialSumAggregateOutputType = {
    counter: bigint | null
  }

  export type MfaCredentialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: bigint | null
    deviceType: string | null
    backedUp: boolean | null
    transports: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type MfaCredentialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: bigint | null
    deviceType: string | null
    backedUp: boolean | null
    transports: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type MfaCredentialCountAggregateOutputType = {
    id: number
    userId: number
    credentialId: number
    publicKey: number
    counter: number
    deviceType: number
    backedUp: number
    transports: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type MfaCredentialAvgAggregateInputType = {
    counter?: true
  }

  export type MfaCredentialSumAggregateInputType = {
    counter?: true
  }

  export type MfaCredentialMinAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    deviceType?: true
    backedUp?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type MfaCredentialMaxAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    deviceType?: true
    backedUp?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type MfaCredentialCountAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    deviceType?: true
    backedUp?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type MfaCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MfaCredential to aggregate.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MfaCredentials
    **/
    _count?: true | MfaCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MfaCredentialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MfaCredentialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MfaCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MfaCredentialMaxAggregateInputType
  }

  export type GetMfaCredentialAggregateType<T extends MfaCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateMfaCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMfaCredential[P]>
      : GetScalarType<T[P], AggregateMfaCredential[P]>
  }




  export type MfaCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MfaCredentialWhereInput
    orderBy?: MfaCredentialOrderByWithAggregationInput | MfaCredentialOrderByWithAggregationInput[]
    by: MfaCredentialScalarFieldEnum[] | MfaCredentialScalarFieldEnum
    having?: MfaCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MfaCredentialCountAggregateInputType | true
    _avg?: MfaCredentialAvgAggregateInputType
    _sum?: MfaCredentialSumAggregateInputType
    _min?: MfaCredentialMinAggregateInputType
    _max?: MfaCredentialMaxAggregateInputType
  }

  export type MfaCredentialGroupByOutputType = {
    id: string
    userId: string
    credentialId: string
    publicKey: string
    counter: bigint
    deviceType: string | null
    backedUp: boolean
    transports: string | null
    createdAt: Date
    lastUsedAt: Date | null
    _count: MfaCredentialCountAggregateOutputType | null
    _avg: MfaCredentialAvgAggregateOutputType | null
    _sum: MfaCredentialSumAggregateOutputType | null
    _min: MfaCredentialMinAggregateOutputType | null
    _max: MfaCredentialMaxAggregateOutputType | null
  }

  type GetMfaCredentialGroupByPayload<T extends MfaCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MfaCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MfaCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MfaCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], MfaCredentialGroupByOutputType[P]>
        }
      >
    >


  export type MfaCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaCredential"]>

  export type MfaCredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaCredential"]>

  export type MfaCredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaCredential"]>

  export type MfaCredentialSelectScalar = {
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type MfaCredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "credentialId" | "publicKey" | "counter" | "deviceType" | "backedUp" | "transports" | "createdAt" | "lastUsedAt", ExtArgs["result"]["mfaCredential"]>
  export type MfaCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MfaCredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MfaCredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MfaCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MfaCredential"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      credentialId: string
      publicKey: string
      counter: bigint
      deviceType: string | null
      backedUp: boolean
      transports: string | null
      createdAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["mfaCredential"]>
    composites: {}
  }

  type MfaCredentialGetPayload<S extends boolean | null | undefined | MfaCredentialDefaultArgs> = $Result.GetResult<Prisma.$MfaCredentialPayload, S>

  type MfaCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MfaCredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MfaCredentialCountAggregateInputType | true
    }

  export interface MfaCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MfaCredential'], meta: { name: 'MfaCredential' } }
    /**
     * Find zero or one MfaCredential that matches the filter.
     * @param {MfaCredentialFindUniqueArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MfaCredentialFindUniqueArgs>(args: SelectSubset<T, MfaCredentialFindUniqueArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MfaCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MfaCredentialFindUniqueOrThrowArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MfaCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, MfaCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MfaCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialFindFirstArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MfaCredentialFindFirstArgs>(args?: SelectSubset<T, MfaCredentialFindFirstArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MfaCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialFindFirstOrThrowArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MfaCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, MfaCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MfaCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MfaCredentials
     * const mfaCredentials = await prisma.mfaCredential.findMany()
     * 
     * // Get first 10 MfaCredentials
     * const mfaCredentials = await prisma.mfaCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mfaCredentialWithIdOnly = await prisma.mfaCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MfaCredentialFindManyArgs>(args?: SelectSubset<T, MfaCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MfaCredential.
     * @param {MfaCredentialCreateArgs} args - Arguments to create a MfaCredential.
     * @example
     * // Create one MfaCredential
     * const MfaCredential = await prisma.mfaCredential.create({
     *   data: {
     *     // ... data to create a MfaCredential
     *   }
     * })
     * 
     */
    create<T extends MfaCredentialCreateArgs>(args: SelectSubset<T, MfaCredentialCreateArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MfaCredentials.
     * @param {MfaCredentialCreateManyArgs} args - Arguments to create many MfaCredentials.
     * @example
     * // Create many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MfaCredentialCreateManyArgs>(args?: SelectSubset<T, MfaCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MfaCredentials and returns the data saved in the database.
     * @param {MfaCredentialCreateManyAndReturnArgs} args - Arguments to create many MfaCredentials.
     * @example
     * // Create many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MfaCredentials and only return the `id`
     * const mfaCredentialWithIdOnly = await prisma.mfaCredential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MfaCredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, MfaCredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MfaCredential.
     * @param {MfaCredentialDeleteArgs} args - Arguments to delete one MfaCredential.
     * @example
     * // Delete one MfaCredential
     * const MfaCredential = await prisma.mfaCredential.delete({
     *   where: {
     *     // ... filter to delete one MfaCredential
     *   }
     * })
     * 
     */
    delete<T extends MfaCredentialDeleteArgs>(args: SelectSubset<T, MfaCredentialDeleteArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MfaCredential.
     * @param {MfaCredentialUpdateArgs} args - Arguments to update one MfaCredential.
     * @example
     * // Update one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MfaCredentialUpdateArgs>(args: SelectSubset<T, MfaCredentialUpdateArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MfaCredentials.
     * @param {MfaCredentialDeleteManyArgs} args - Arguments to filter MfaCredentials to delete.
     * @example
     * // Delete a few MfaCredentials
     * const { count } = await prisma.mfaCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MfaCredentialDeleteManyArgs>(args?: SelectSubset<T, MfaCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MfaCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MfaCredentialUpdateManyArgs>(args: SelectSubset<T, MfaCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MfaCredentials and returns the data updated in the database.
     * @param {MfaCredentialUpdateManyAndReturnArgs} args - Arguments to update many MfaCredentials.
     * @example
     * // Update many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MfaCredentials and only return the `id`
     * const mfaCredentialWithIdOnly = await prisma.mfaCredential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MfaCredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, MfaCredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MfaCredential.
     * @param {MfaCredentialUpsertArgs} args - Arguments to update or create a MfaCredential.
     * @example
     * // Update or create a MfaCredential
     * const mfaCredential = await prisma.mfaCredential.upsert({
     *   create: {
     *     // ... data to create a MfaCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MfaCredential we want to update
     *   }
     * })
     */
    upsert<T extends MfaCredentialUpsertArgs>(args: SelectSubset<T, MfaCredentialUpsertArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MfaCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialCountArgs} args - Arguments to filter MfaCredentials to count.
     * @example
     * // Count the number of MfaCredentials
     * const count = await prisma.mfaCredential.count({
     *   where: {
     *     // ... the filter for the MfaCredentials we want to count
     *   }
     * })
    **/
    count<T extends MfaCredentialCountArgs>(
      args?: Subset<T, MfaCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MfaCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MfaCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MfaCredentialAggregateArgs>(args: Subset<T, MfaCredentialAggregateArgs>): Prisma.PrismaPromise<GetMfaCredentialAggregateType<T>>

    /**
     * Group by MfaCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MfaCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MfaCredentialGroupByArgs['orderBy'] }
        : { orderBy?: MfaCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MfaCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMfaCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MfaCredential model
   */
  readonly fields: MfaCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MfaCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MfaCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MfaCredential model
   */
  interface MfaCredentialFieldRefs {
    readonly id: FieldRef<"MfaCredential", 'String'>
    readonly userId: FieldRef<"MfaCredential", 'String'>
    readonly credentialId: FieldRef<"MfaCredential", 'String'>
    readonly publicKey: FieldRef<"MfaCredential", 'String'>
    readonly counter: FieldRef<"MfaCredential", 'BigInt'>
    readonly deviceType: FieldRef<"MfaCredential", 'String'>
    readonly backedUp: FieldRef<"MfaCredential", 'Boolean'>
    readonly transports: FieldRef<"MfaCredential", 'String'>
    readonly createdAt: FieldRef<"MfaCredential", 'DateTime'>
    readonly lastUsedAt: FieldRef<"MfaCredential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MfaCredential findUnique
   */
  export type MfaCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential findUniqueOrThrow
   */
  export type MfaCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential findFirst
   */
  export type MfaCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MfaCredentials.
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MfaCredentials.
     */
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * MfaCredential findFirstOrThrow
   */
  export type MfaCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MfaCredentials.
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MfaCredentials.
     */
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * MfaCredential findMany
   */
  export type MfaCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredentials to fetch.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MfaCredentials.
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * MfaCredential create
   */
  export type MfaCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a MfaCredential.
     */
    data: XOR<MfaCredentialCreateInput, MfaCredentialUncheckedCreateInput>
  }

  /**
   * MfaCredential createMany
   */
  export type MfaCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MfaCredentials.
     */
    data: MfaCredentialCreateManyInput | MfaCredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MfaCredential createManyAndReturn
   */
  export type MfaCredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * The data used to create many MfaCredentials.
     */
    data: MfaCredentialCreateManyInput | MfaCredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MfaCredential update
   */
  export type MfaCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a MfaCredential.
     */
    data: XOR<MfaCredentialUpdateInput, MfaCredentialUncheckedUpdateInput>
    /**
     * Choose, which MfaCredential to update.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential updateMany
   */
  export type MfaCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MfaCredentials.
     */
    data: XOR<MfaCredentialUpdateManyMutationInput, MfaCredentialUncheckedUpdateManyInput>
    /**
     * Filter which MfaCredentials to update
     */
    where?: MfaCredentialWhereInput
    /**
     * Limit how many MfaCredentials to update.
     */
    limit?: number
  }

  /**
   * MfaCredential updateManyAndReturn
   */
  export type MfaCredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * The data used to update MfaCredentials.
     */
    data: XOR<MfaCredentialUpdateManyMutationInput, MfaCredentialUncheckedUpdateManyInput>
    /**
     * Filter which MfaCredentials to update
     */
    where?: MfaCredentialWhereInput
    /**
     * Limit how many MfaCredentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MfaCredential upsert
   */
  export type MfaCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the MfaCredential to update in case it exists.
     */
    where: MfaCredentialWhereUniqueInput
    /**
     * In case the MfaCredential found by the `where` argument doesn't exist, create a new MfaCredential with this data.
     */
    create: XOR<MfaCredentialCreateInput, MfaCredentialUncheckedCreateInput>
    /**
     * In case the MfaCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MfaCredentialUpdateInput, MfaCredentialUncheckedUpdateInput>
  }

  /**
   * MfaCredential delete
   */
  export type MfaCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter which MfaCredential to delete.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential deleteMany
   */
  export type MfaCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MfaCredentials to delete
     */
    where?: MfaCredentialWhereInput
    /**
     * Limit how many MfaCredentials to delete.
     */
    limit?: number
  }

  /**
   * MfaCredential without action
   */
  export type MfaCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
  }


  /**
   * Model RecoveryCode
   */

  export type AggregateRecoveryCode = {
    _count: RecoveryCodeCountAggregateOutputType | null
    _min: RecoveryCodeMinAggregateOutputType | null
    _max: RecoveryCodeMaxAggregateOutputType | null
  }

  export type RecoveryCodeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type RecoveryCodeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type RecoveryCodeCountAggregateOutputType = {
    id: number
    userId: number
    codeHash: number
    used: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type RecoveryCodeMinAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type RecoveryCodeMaxAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type RecoveryCodeCountAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    used?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type RecoveryCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryCode to aggregate.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryCodes
    **/
    _count?: true | RecoveryCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryCodeMaxAggregateInputType
  }

  export type GetRecoveryCodeAggregateType<T extends RecoveryCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryCode[P]>
      : GetScalarType<T[P], AggregateRecoveryCode[P]>
  }




  export type RecoveryCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryCodeWhereInput
    orderBy?: RecoveryCodeOrderByWithAggregationInput | RecoveryCodeOrderByWithAggregationInput[]
    by: RecoveryCodeScalarFieldEnum[] | RecoveryCodeScalarFieldEnum
    having?: RecoveryCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryCodeCountAggregateInputType | true
    _min?: RecoveryCodeMinAggregateInputType
    _max?: RecoveryCodeMaxAggregateInputType
  }

  export type RecoveryCodeGroupByOutputType = {
    id: string
    userId: string
    codeHash: string
    used: boolean
    usedAt: Date | null
    createdAt: Date
    _count: RecoveryCodeCountAggregateOutputType | null
    _min: RecoveryCodeMinAggregateOutputType | null
    _max: RecoveryCodeMaxAggregateOutputType | null
  }

  type GetRecoveryCodeGroupByPayload<T extends RecoveryCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryCodeGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryCodeGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryCode"]>

  export type RecoveryCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryCode"]>

  export type RecoveryCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryCode"]>

  export type RecoveryCodeSelectScalar = {
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type RecoveryCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "codeHash" | "used" | "usedAt" | "createdAt", ExtArgs["result"]["recoveryCode"]>
  export type RecoveryCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RecoveryCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RecoveryCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RecoveryCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      codeHash: string
      used: boolean
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["recoveryCode"]>
    composites: {}
  }

  type RecoveryCodeGetPayload<S extends boolean | null | undefined | RecoveryCodeDefaultArgs> = $Result.GetResult<Prisma.$RecoveryCodePayload, S>

  type RecoveryCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecoveryCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecoveryCodeCountAggregateInputType | true
    }

  export interface RecoveryCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryCode'], meta: { name: 'RecoveryCode' } }
    /**
     * Find zero or one RecoveryCode that matches the filter.
     * @param {RecoveryCodeFindUniqueArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryCodeFindUniqueArgs>(args: SelectSubset<T, RecoveryCodeFindUniqueArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecoveryCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecoveryCodeFindUniqueOrThrowArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeFindFirstArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryCodeFindFirstArgs>(args?: SelectSubset<T, RecoveryCodeFindFirstArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeFindFirstOrThrowArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecoveryCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryCodes
     * const recoveryCodes = await prisma.recoveryCode.findMany()
     * 
     * // Get first 10 RecoveryCodes
     * const recoveryCodes = await prisma.recoveryCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recoveryCodeWithIdOnly = await prisma.recoveryCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecoveryCodeFindManyArgs>(args?: SelectSubset<T, RecoveryCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecoveryCode.
     * @param {RecoveryCodeCreateArgs} args - Arguments to create a RecoveryCode.
     * @example
     * // Create one RecoveryCode
     * const RecoveryCode = await prisma.recoveryCode.create({
     *   data: {
     *     // ... data to create a RecoveryCode
     *   }
     * })
     * 
     */
    create<T extends RecoveryCodeCreateArgs>(args: SelectSubset<T, RecoveryCodeCreateArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecoveryCodes.
     * @param {RecoveryCodeCreateManyArgs} args - Arguments to create many RecoveryCodes.
     * @example
     * // Create many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryCodeCreateManyArgs>(args?: SelectSubset<T, RecoveryCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecoveryCodes and returns the data saved in the database.
     * @param {RecoveryCodeCreateManyAndReturnArgs} args - Arguments to create many RecoveryCodes.
     * @example
     * // Create many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecoveryCodes and only return the `id`
     * const recoveryCodeWithIdOnly = await prisma.recoveryCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecoveryCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecoveryCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecoveryCode.
     * @param {RecoveryCodeDeleteArgs} args - Arguments to delete one RecoveryCode.
     * @example
     * // Delete one RecoveryCode
     * const RecoveryCode = await prisma.recoveryCode.delete({
     *   where: {
     *     // ... filter to delete one RecoveryCode
     *   }
     * })
     * 
     */
    delete<T extends RecoveryCodeDeleteArgs>(args: SelectSubset<T, RecoveryCodeDeleteArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecoveryCode.
     * @param {RecoveryCodeUpdateArgs} args - Arguments to update one RecoveryCode.
     * @example
     * // Update one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryCodeUpdateArgs>(args: SelectSubset<T, RecoveryCodeUpdateArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecoveryCodes.
     * @param {RecoveryCodeDeleteManyArgs} args - Arguments to filter RecoveryCodes to delete.
     * @example
     * // Delete a few RecoveryCodes
     * const { count } = await prisma.recoveryCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryCodeDeleteManyArgs>(args?: SelectSubset<T, RecoveryCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryCodeUpdateManyArgs>(args: SelectSubset<T, RecoveryCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryCodes and returns the data updated in the database.
     * @param {RecoveryCodeUpdateManyAndReturnArgs} args - Arguments to update many RecoveryCodes.
     * @example
     * // Update many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecoveryCodes and only return the `id`
     * const recoveryCodeWithIdOnly = await prisma.recoveryCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecoveryCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, RecoveryCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecoveryCode.
     * @param {RecoveryCodeUpsertArgs} args - Arguments to update or create a RecoveryCode.
     * @example
     * // Update or create a RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.upsert({
     *   create: {
     *     // ... data to create a RecoveryCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryCode we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryCodeUpsertArgs>(args: SelectSubset<T, RecoveryCodeUpsertArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecoveryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeCountArgs} args - Arguments to filter RecoveryCodes to count.
     * @example
     * // Count the number of RecoveryCodes
     * const count = await prisma.recoveryCode.count({
     *   where: {
     *     // ... the filter for the RecoveryCodes we want to count
     *   }
     * })
    **/
    count<T extends RecoveryCodeCountArgs>(
      args?: Subset<T, RecoveryCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryCodeAggregateArgs>(args: Subset<T, RecoveryCodeAggregateArgs>): Prisma.PrismaPromise<GetRecoveryCodeAggregateType<T>>

    /**
     * Group by RecoveryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryCodeGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryCode model
   */
  readonly fields: RecoveryCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryCode model
   */
  interface RecoveryCodeFieldRefs {
    readonly id: FieldRef<"RecoveryCode", 'String'>
    readonly userId: FieldRef<"RecoveryCode", 'String'>
    readonly codeHash: FieldRef<"RecoveryCode", 'String'>
    readonly used: FieldRef<"RecoveryCode", 'Boolean'>
    readonly usedAt: FieldRef<"RecoveryCode", 'DateTime'>
    readonly createdAt: FieldRef<"RecoveryCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryCode findUnique
   */
  export type RecoveryCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode findUniqueOrThrow
   */
  export type RecoveryCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode findFirst
   */
  export type RecoveryCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryCodes.
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryCodes.
     */
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * RecoveryCode findFirstOrThrow
   */
  export type RecoveryCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryCodes.
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryCodes.
     */
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * RecoveryCode findMany
   */
  export type RecoveryCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCodes to fetch.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryCodes.
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * RecoveryCode create
   */
  export type RecoveryCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryCode.
     */
    data: XOR<RecoveryCodeCreateInput, RecoveryCodeUncheckedCreateInput>
  }

  /**
   * RecoveryCode createMany
   */
  export type RecoveryCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryCodes.
     */
    data: RecoveryCodeCreateManyInput | RecoveryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecoveryCode createManyAndReturn
   */
  export type RecoveryCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * The data used to create many RecoveryCodes.
     */
    data: RecoveryCodeCreateManyInput | RecoveryCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryCode update
   */
  export type RecoveryCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryCode.
     */
    data: XOR<RecoveryCodeUpdateInput, RecoveryCodeUncheckedUpdateInput>
    /**
     * Choose, which RecoveryCode to update.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode updateMany
   */
  export type RecoveryCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryCodes.
     */
    data: XOR<RecoveryCodeUpdateManyMutationInput, RecoveryCodeUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryCodes to update
     */
    where?: RecoveryCodeWhereInput
    /**
     * Limit how many RecoveryCodes to update.
     */
    limit?: number
  }

  /**
   * RecoveryCode updateManyAndReturn
   */
  export type RecoveryCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * The data used to update RecoveryCodes.
     */
    data: XOR<RecoveryCodeUpdateManyMutationInput, RecoveryCodeUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryCodes to update
     */
    where?: RecoveryCodeWhereInput
    /**
     * Limit how many RecoveryCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryCode upsert
   */
  export type RecoveryCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryCode to update in case it exists.
     */
    where: RecoveryCodeWhereUniqueInput
    /**
     * In case the RecoveryCode found by the `where` argument doesn't exist, create a new RecoveryCode with this data.
     */
    create: XOR<RecoveryCodeCreateInput, RecoveryCodeUncheckedCreateInput>
    /**
     * In case the RecoveryCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryCodeUpdateInput, RecoveryCodeUncheckedUpdateInput>
  }

  /**
   * RecoveryCode delete
   */
  export type RecoveryCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter which RecoveryCode to delete.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode deleteMany
   */
  export type RecoveryCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryCodes to delete
     */
    where?: RecoveryCodeWhereInput
    /**
     * Limit how many RecoveryCodes to delete.
     */
    limit?: number
  }

  /**
   * RecoveryCode without action
   */
  export type RecoveryCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
  }


  /**
   * Model SavedSearch
   */

  export type AggregateSavedSearch = {
    _count: SavedSearchCountAggregateOutputType | null
    _min: SavedSearchMinAggregateOutputType | null
    _max: SavedSearchMaxAggregateOutputType | null
  }

  export type SavedSearchMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    query: string | null
    filter: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SavedSearchMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    query: string | null
    filter: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SavedSearchCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    query: number
    folderIds: number
    tagIds: number
    filter: number
    searchFields: number
    createdAt: number
    updatedAt: number
    lastUsedAt: number
    _all: number
  }


  export type SavedSearchMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    query?: true
    filter?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SavedSearchMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    query?: true
    filter?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SavedSearchCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    query?: true
    folderIds?: true
    tagIds?: true
    filter?: true
    searchFields?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type SavedSearchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedSearch to aggregate.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedSearches
    **/
    _count?: true | SavedSearchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedSearchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedSearchMaxAggregateInputType
  }

  export type GetSavedSearchAggregateType<T extends SavedSearchAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedSearch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedSearch[P]>
      : GetScalarType<T[P], AggregateSavedSearch[P]>
  }




  export type SavedSearchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedSearchWhereInput
    orderBy?: SavedSearchOrderByWithAggregationInput | SavedSearchOrderByWithAggregationInput[]
    by: SavedSearchScalarFieldEnum[] | SavedSearchScalarFieldEnum
    having?: SavedSearchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedSearchCountAggregateInputType | true
    _min?: SavedSearchMinAggregateInputType
    _max?: SavedSearchMaxAggregateInputType
  }

  export type SavedSearchGroupByOutputType = {
    id: string
    userId: string
    name: string
    query: string | null
    folderIds: string[]
    tagIds: string[]
    filter: string | null
    searchFields: string[]
    createdAt: Date
    updatedAt: Date
    lastUsedAt: Date | null
    _count: SavedSearchCountAggregateOutputType | null
    _min: SavedSearchMinAggregateOutputType | null
    _max: SavedSearchMaxAggregateOutputType | null
  }

  type GetSavedSearchGroupByPayload<T extends SavedSearchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedSearchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedSearchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedSearchGroupByOutputType[P]>
            : GetScalarType<T[P], SavedSearchGroupByOutputType[P]>
        }
      >
    >


  export type SavedSearchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }

  export type SavedSearchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "query" | "folderIds" | "tagIds" | "filter" | "searchFields" | "createdAt" | "updatedAt" | "lastUsedAt", ExtArgs["result"]["savedSearch"]>
  export type SavedSearchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedSearchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedSearchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavedSearchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedSearch"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      query: string | null
      folderIds: string[]
      tagIds: string[]
      filter: string | null
      searchFields: string[]
      createdAt: Date
      updatedAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["savedSearch"]>
    composites: {}
  }

  type SavedSearchGetPayload<S extends boolean | null | undefined | SavedSearchDefaultArgs> = $Result.GetResult<Prisma.$SavedSearchPayload, S>

  type SavedSearchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedSearchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedSearchCountAggregateInputType | true
    }

  export interface SavedSearchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedSearch'], meta: { name: 'SavedSearch' } }
    /**
     * Find zero or one SavedSearch that matches the filter.
     * @param {SavedSearchFindUniqueArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedSearchFindUniqueArgs>(args: SelectSubset<T, SavedSearchFindUniqueArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedSearch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedSearchFindUniqueOrThrowArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedSearchFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedSearchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedSearch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindFirstArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedSearchFindFirstArgs>(args?: SelectSubset<T, SavedSearchFindFirstArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedSearch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindFirstOrThrowArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedSearchFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedSearchFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedSearches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedSearches
     * const savedSearches = await prisma.savedSearch.findMany()
     * 
     * // Get first 10 SavedSearches
     * const savedSearches = await prisma.savedSearch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedSearchFindManyArgs>(args?: SelectSubset<T, SavedSearchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedSearch.
     * @param {SavedSearchCreateArgs} args - Arguments to create a SavedSearch.
     * @example
     * // Create one SavedSearch
     * const SavedSearch = await prisma.savedSearch.create({
     *   data: {
     *     // ... data to create a SavedSearch
     *   }
     * })
     * 
     */
    create<T extends SavedSearchCreateArgs>(args: SelectSubset<T, SavedSearchCreateArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedSearches.
     * @param {SavedSearchCreateManyArgs} args - Arguments to create many SavedSearches.
     * @example
     * // Create many SavedSearches
     * const savedSearch = await prisma.savedSearch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedSearchCreateManyArgs>(args?: SelectSubset<T, SavedSearchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedSearches and returns the data saved in the database.
     * @param {SavedSearchCreateManyAndReturnArgs} args - Arguments to create many SavedSearches.
     * @example
     * // Create many SavedSearches
     * const savedSearch = await prisma.savedSearch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedSearches and only return the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedSearchCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedSearchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedSearch.
     * @param {SavedSearchDeleteArgs} args - Arguments to delete one SavedSearch.
     * @example
     * // Delete one SavedSearch
     * const SavedSearch = await prisma.savedSearch.delete({
     *   where: {
     *     // ... filter to delete one SavedSearch
     *   }
     * })
     * 
     */
    delete<T extends SavedSearchDeleteArgs>(args: SelectSubset<T, SavedSearchDeleteArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedSearch.
     * @param {SavedSearchUpdateArgs} args - Arguments to update one SavedSearch.
     * @example
     * // Update one SavedSearch
     * const savedSearch = await prisma.savedSearch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedSearchUpdateArgs>(args: SelectSubset<T, SavedSearchUpdateArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedSearches.
     * @param {SavedSearchDeleteManyArgs} args - Arguments to filter SavedSearches to delete.
     * @example
     * // Delete a few SavedSearches
     * const { count } = await prisma.savedSearch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedSearchDeleteManyArgs>(args?: SelectSubset<T, SavedSearchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedSearches
     * const savedSearch = await prisma.savedSearch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedSearchUpdateManyArgs>(args: SelectSubset<T, SavedSearchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedSearches and returns the data updated in the database.
     * @param {SavedSearchUpdateManyAndReturnArgs} args - Arguments to update many SavedSearches.
     * @example
     * // Update many SavedSearches
     * const savedSearch = await prisma.savedSearch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedSearches and only return the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedSearchUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedSearchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedSearch.
     * @param {SavedSearchUpsertArgs} args - Arguments to update or create a SavedSearch.
     * @example
     * // Update or create a SavedSearch
     * const savedSearch = await prisma.savedSearch.upsert({
     *   create: {
     *     // ... data to create a SavedSearch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedSearch we want to update
     *   }
     * })
     */
    upsert<T extends SavedSearchUpsertArgs>(args: SelectSubset<T, SavedSearchUpsertArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchCountArgs} args - Arguments to filter SavedSearches to count.
     * @example
     * // Count the number of SavedSearches
     * const count = await prisma.savedSearch.count({
     *   where: {
     *     // ... the filter for the SavedSearches we want to count
     *   }
     * })
    **/
    count<T extends SavedSearchCountArgs>(
      args?: Subset<T, SavedSearchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedSearchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedSearchAggregateArgs>(args: Subset<T, SavedSearchAggregateArgs>): Prisma.PrismaPromise<GetSavedSearchAggregateType<T>>

    /**
     * Group by SavedSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedSearchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedSearchGroupByArgs['orderBy'] }
        : { orderBy?: SavedSearchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedSearchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedSearchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedSearch model
   */
  readonly fields: SavedSearchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedSearch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedSearchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedSearch model
   */
  interface SavedSearchFieldRefs {
    readonly id: FieldRef<"SavedSearch", 'String'>
    readonly userId: FieldRef<"SavedSearch", 'String'>
    readonly name: FieldRef<"SavedSearch", 'String'>
    readonly query: FieldRef<"SavedSearch", 'String'>
    readonly folderIds: FieldRef<"SavedSearch", 'String[]'>
    readonly tagIds: FieldRef<"SavedSearch", 'String[]'>
    readonly filter: FieldRef<"SavedSearch", 'String'>
    readonly searchFields: FieldRef<"SavedSearch", 'String[]'>
    readonly createdAt: FieldRef<"SavedSearch", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedSearch", 'DateTime'>
    readonly lastUsedAt: FieldRef<"SavedSearch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedSearch findUnique
   */
  export type SavedSearchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch findUniqueOrThrow
   */
  export type SavedSearchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch findFirst
   */
  export type SavedSearchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedSearches.
     */
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch findFirstOrThrow
   */
  export type SavedSearchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedSearches.
     */
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch findMany
   */
  export type SavedSearchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearches to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch create
   */
  export type SavedSearchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedSearch.
     */
    data: XOR<SavedSearchCreateInput, SavedSearchUncheckedCreateInput>
  }

  /**
   * SavedSearch createMany
   */
  export type SavedSearchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedSearches.
     */
    data: SavedSearchCreateManyInput | SavedSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedSearch createManyAndReturn
   */
  export type SavedSearchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * The data used to create many SavedSearches.
     */
    data: SavedSearchCreateManyInput | SavedSearchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedSearch update
   */
  export type SavedSearchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedSearch.
     */
    data: XOR<SavedSearchUpdateInput, SavedSearchUncheckedUpdateInput>
    /**
     * Choose, which SavedSearch to update.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch updateMany
   */
  export type SavedSearchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedSearches.
     */
    data: XOR<SavedSearchUpdateManyMutationInput, SavedSearchUncheckedUpdateManyInput>
    /**
     * Filter which SavedSearches to update
     */
    where?: SavedSearchWhereInput
    /**
     * Limit how many SavedSearches to update.
     */
    limit?: number
  }

  /**
   * SavedSearch updateManyAndReturn
   */
  export type SavedSearchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * The data used to update SavedSearches.
     */
    data: XOR<SavedSearchUpdateManyMutationInput, SavedSearchUncheckedUpdateManyInput>
    /**
     * Filter which SavedSearches to update
     */
    where?: SavedSearchWhereInput
    /**
     * Limit how many SavedSearches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedSearch upsert
   */
  export type SavedSearchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedSearch to update in case it exists.
     */
    where: SavedSearchWhereUniqueInput
    /**
     * In case the SavedSearch found by the `where` argument doesn't exist, create a new SavedSearch with this data.
     */
    create: XOR<SavedSearchCreateInput, SavedSearchUncheckedCreateInput>
    /**
     * In case the SavedSearch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedSearchUpdateInput, SavedSearchUncheckedUpdateInput>
  }

  /**
   * SavedSearch delete
   */
  export type SavedSearchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter which SavedSearch to delete.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch deleteMany
   */
  export type SavedSearchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedSearches to delete
     */
    where?: SavedSearchWhereInput
    /**
     * Limit how many SavedSearches to delete.
     */
    limit?: number
  }

  /**
   * SavedSearch without action
   */
  export type SavedSearchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
  }


  /**
   * Model SearchHistory
   */

  export type AggregateSearchHistory = {
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  export type SearchHistoryAvgAggregateOutputType = {
    resultCount: number | null
  }

  export type SearchHistorySumAggregateOutputType = {
    resultCount: number | null
  }

  export type SearchHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    query: string | null
    filter: string | null
    resultCount: number | null
    createdAt: Date | null
  }

  export type SearchHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    query: string | null
    filter: string | null
    resultCount: number | null
    createdAt: Date | null
  }

  export type SearchHistoryCountAggregateOutputType = {
    id: number
    userId: number
    query: number
    folderIds: number
    tagIds: number
    filter: number
    searchFields: number
    resultCount: number
    createdAt: number
    _all: number
  }


  export type SearchHistoryAvgAggregateInputType = {
    resultCount?: true
  }

  export type SearchHistorySumAggregateInputType = {
    resultCount?: true
  }

  export type SearchHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    filter?: true
    resultCount?: true
    createdAt?: true
  }

  export type SearchHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    filter?: true
    resultCount?: true
    createdAt?: true
  }

  export type SearchHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    folderIds?: true
    tagIds?: true
    filter?: true
    searchFields?: true
    resultCount?: true
    createdAt?: true
    _all?: true
  }

  export type SearchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistory to aggregate.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchHistories
    **/
    _count?: true | SearchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type GetSearchHistoryAggregateType<T extends SearchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchHistory[P]>
      : GetScalarType<T[P], AggregateSearchHistory[P]>
  }




  export type SearchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithAggregationInput | SearchHistoryOrderByWithAggregationInput[]
    by: SearchHistoryScalarFieldEnum[] | SearchHistoryScalarFieldEnum
    having?: SearchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchHistoryCountAggregateInputType | true
    _avg?: SearchHistoryAvgAggregateInputType
    _sum?: SearchHistorySumAggregateInputType
    _min?: SearchHistoryMinAggregateInputType
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type SearchHistoryGroupByOutputType = {
    id: string
    userId: string
    query: string | null
    folderIds: string[]
    tagIds: string[]
    filter: string | null
    searchFields: string[]
    resultCount: number | null
    createdAt: Date
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  type GetSearchHistoryGroupByPayload<T extends SearchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SearchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
  }

  export type SearchHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "query" | "folderIds" | "tagIds" | "filter" | "searchFields" | "resultCount" | "createdAt", ExtArgs["result"]["searchHistory"]>
  export type SearchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      query: string | null
      folderIds: string[]
      tagIds: string[]
      filter: string | null
      searchFields: string[]
      resultCount: number | null
      createdAt: Date
    }, ExtArgs["result"]["searchHistory"]>
    composites: {}
  }

  type SearchHistoryGetPayload<S extends boolean | null | undefined | SearchHistoryDefaultArgs> = $Result.GetResult<Prisma.$SearchHistoryPayload, S>

  type SearchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchHistoryCountAggregateInputType | true
    }

  export interface SearchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchHistory'], meta: { name: 'SearchHistory' } }
    /**
     * Find zero or one SearchHistory that matches the filter.
     * @param {SearchHistoryFindUniqueArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchHistoryFindUniqueArgs>(args: SelectSubset<T, SearchHistoryFindUniqueArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchHistoryFindUniqueOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchHistoryFindFirstArgs>(args?: SelectSubset<T, SearchHistoryFindFirstArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany()
     * 
     * // Get first 10 SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchHistoryFindManyArgs>(args?: SelectSubset<T, SearchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchHistory.
     * @param {SearchHistoryCreateArgs} args - Arguments to create a SearchHistory.
     * @example
     * // Create one SearchHistory
     * const SearchHistory = await prisma.searchHistory.create({
     *   data: {
     *     // ... data to create a SearchHistory
     *   }
     * })
     * 
     */
    create<T extends SearchHistoryCreateArgs>(args: SelectSubset<T, SearchHistoryCreateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchHistories.
     * @param {SearchHistoryCreateManyArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchHistoryCreateManyArgs>(args?: SelectSubset<T, SearchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchHistories and returns the data saved in the database.
     * @param {SearchHistoryCreateManyAndReturnArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchHistory.
     * @param {SearchHistoryDeleteArgs} args - Arguments to delete one SearchHistory.
     * @example
     * // Delete one SearchHistory
     * const SearchHistory = await prisma.searchHistory.delete({
     *   where: {
     *     // ... filter to delete one SearchHistory
     *   }
     * })
     * 
     */
    delete<T extends SearchHistoryDeleteArgs>(args: SelectSubset<T, SearchHistoryDeleteArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchHistory.
     * @param {SearchHistoryUpdateArgs} args - Arguments to update one SearchHistory.
     * @example
     * // Update one SearchHistory
     * const searchHistory = await prisma.searchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchHistoryUpdateArgs>(args: SelectSubset<T, SearchHistoryUpdateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchHistories.
     * @param {SearchHistoryDeleteManyArgs} args - Arguments to filter SearchHistories to delete.
     * @example
     * // Delete a few SearchHistories
     * const { count } = await prisma.searchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchHistoryDeleteManyArgs>(args?: SelectSubset<T, SearchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchHistoryUpdateManyArgs>(args: SelectSubset<T, SearchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories and returns the data updated in the database.
     * @param {SearchHistoryUpdateManyAndReturnArgs} args - Arguments to update many SearchHistories.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchHistory.
     * @param {SearchHistoryUpsertArgs} args - Arguments to update or create a SearchHistory.
     * @example
     * // Update or create a SearchHistory
     * const searchHistory = await prisma.searchHistory.upsert({
     *   create: {
     *     // ... data to create a SearchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchHistory we want to update
     *   }
     * })
     */
    upsert<T extends SearchHistoryUpsertArgs>(args: SelectSubset<T, SearchHistoryUpsertArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryCountArgs} args - Arguments to filter SearchHistories to count.
     * @example
     * // Count the number of SearchHistories
     * const count = await prisma.searchHistory.count({
     *   where: {
     *     // ... the filter for the SearchHistories we want to count
     *   }
     * })
    **/
    count<T extends SearchHistoryCountArgs>(
      args?: Subset<T, SearchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchHistoryAggregateArgs>(args: Subset<T, SearchHistoryAggregateArgs>): Prisma.PrismaPromise<GetSearchHistoryAggregateType<T>>

    /**
     * Group by SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SearchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchHistory model
   */
  readonly fields: SearchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchHistory model
   */
  interface SearchHistoryFieldRefs {
    readonly id: FieldRef<"SearchHistory", 'String'>
    readonly userId: FieldRef<"SearchHistory", 'String'>
    readonly query: FieldRef<"SearchHistory", 'String'>
    readonly folderIds: FieldRef<"SearchHistory", 'String[]'>
    readonly tagIds: FieldRef<"SearchHistory", 'String[]'>
    readonly filter: FieldRef<"SearchHistory", 'String'>
    readonly searchFields: FieldRef<"SearchHistory", 'String[]'>
    readonly resultCount: FieldRef<"SearchHistory", 'Int'>
    readonly createdAt: FieldRef<"SearchHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchHistory findUnique
   */
  export type SearchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findUniqueOrThrow
   */
  export type SearchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findFirst
   */
  export type SearchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findFirstOrThrow
   */
  export type SearchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findMany
   */
  export type SearchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistories to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory create
   */
  export type SearchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchHistory.
     */
    data: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
  }

  /**
   * SearchHistory createMany
   */
  export type SearchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchHistory createManyAndReturn
   */
  export type SearchHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory update
   */
  export type SearchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchHistory.
     */
    data: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
    /**
     * Choose, which SearchHistory to update.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory updateMany
   */
  export type SearchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to update.
     */
    limit?: number
  }

  /**
   * SearchHistory updateManyAndReturn
   */
  export type SearchHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory upsert
   */
  export type SearchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchHistory to update in case it exists.
     */
    where: SearchHistoryWhereUniqueInput
    /**
     * In case the SearchHistory found by the `where` argument doesn't exist, create a new SearchHistory with this data.
     */
    create: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
    /**
     * In case the SearchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
  }

  /**
   * SearchHistory delete
   */
  export type SearchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter which SearchHistory to delete.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory deleteMany
   */
  export type SearchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistories to delete
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to delete.
     */
    limit?: number
  }

  /**
   * SearchHistory without action
   */
  export type SearchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PasswordTemplate
   */

  export type AggregatePasswordTemplate = {
    _count: PasswordTemplateCountAggregateOutputType | null
    _avg: PasswordTemplateAvgAggregateOutputType | null
    _sum: PasswordTemplateSumAggregateOutputType | null
    _min: PasswordTemplateMinAggregateOutputType | null
    _max: PasswordTemplateMaxAggregateOutputType | null
  }

  export type PasswordTemplateAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type PasswordTemplateSumAggregateOutputType = {
    usageCount: number | null
  }

  export type PasswordTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    service: string | null
    icon: string | null
    category: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    ownerId: string | null
    companyId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    service: string | null
    icon: string | null
    category: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    ownerId: string | null
    companyId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    service: number
    icon: number
    category: number
    isSystem: number
    isPublic: number
    ownerId: number
    companyId: number
    defaultFields: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordTemplateAvgAggregateInputType = {
    usageCount?: true
  }

  export type PasswordTemplateSumAggregateInputType = {
    usageCount?: true
  }

  export type PasswordTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service?: true
    icon?: true
    category?: true
    isSystem?: true
    isPublic?: true
    ownerId?: true
    companyId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service?: true
    icon?: true
    category?: true
    isSystem?: true
    isPublic?: true
    ownerId?: true
    companyId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service?: true
    icon?: true
    category?: true
    isSystem?: true
    isPublic?: true
    ownerId?: true
    companyId?: true
    defaultFields?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTemplate to aggregate.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordTemplates
    **/
    _count?: true | PasswordTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordTemplateMaxAggregateInputType
  }

  export type GetPasswordTemplateAggregateType<T extends PasswordTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordTemplate[P]>
      : GetScalarType<T[P], AggregatePasswordTemplate[P]>
  }




  export type PasswordTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTemplateWhereInput
    orderBy?: PasswordTemplateOrderByWithAggregationInput | PasswordTemplateOrderByWithAggregationInput[]
    by: PasswordTemplateScalarFieldEnum[] | PasswordTemplateScalarFieldEnum
    having?: PasswordTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordTemplateCountAggregateInputType | true
    _avg?: PasswordTemplateAvgAggregateInputType
    _sum?: PasswordTemplateSumAggregateInputType
    _min?: PasswordTemplateMinAggregateInputType
    _max?: PasswordTemplateMaxAggregateInputType
  }

  export type PasswordTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    service: string | null
    icon: string | null
    category: string | null
    isSystem: boolean
    isPublic: boolean
    ownerId: string | null
    companyId: string | null
    defaultFields: JsonValue
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: PasswordTemplateCountAggregateOutputType | null
    _avg: PasswordTemplateAvgAggregateOutputType | null
    _sum: PasswordTemplateSumAggregateOutputType | null
    _min: PasswordTemplateMinAggregateOutputType | null
    _max: PasswordTemplateMaxAggregateOutputType | null
  }

  type GetPasswordTemplateGroupByPayload<T extends PasswordTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordTemplateGroupByOutputType[P]>
        }
      >
    >


  export type PasswordTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTemplate"]>

  export type PasswordTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTemplate"]>

  export type PasswordTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTemplate"]>

  export type PasswordTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "service" | "icon" | "category" | "isSystem" | "isPublic" | "ownerId" | "companyId" | "defaultFields" | "usageCount" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordTemplate"]>
  export type PasswordTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }
  export type PasswordTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }
  export type PasswordTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }

  export type $PasswordTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordTemplate"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      service: string | null
      icon: string | null
      category: string | null
      isSystem: boolean
      isPublic: boolean
      ownerId: string | null
      companyId: string | null
      defaultFields: Prisma.JsonValue
      usageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordTemplate"]>
    composites: {}
  }

  type PasswordTemplateGetPayload<S extends boolean | null | undefined | PasswordTemplateDefaultArgs> = $Result.GetResult<Prisma.$PasswordTemplatePayload, S>

  type PasswordTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordTemplateCountAggregateInputType | true
    }

  export interface PasswordTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordTemplate'], meta: { name: 'PasswordTemplate' } }
    /**
     * Find zero or one PasswordTemplate that matches the filter.
     * @param {PasswordTemplateFindUniqueArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordTemplateFindUniqueArgs>(args: SelectSubset<T, PasswordTemplateFindUniqueArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordTemplateFindUniqueOrThrowArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateFindFirstArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordTemplateFindFirstArgs>(args?: SelectSubset<T, PasswordTemplateFindFirstArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateFindFirstOrThrowArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordTemplates
     * const passwordTemplates = await prisma.passwordTemplate.findMany()
     * 
     * // Get first 10 PasswordTemplates
     * const passwordTemplates = await prisma.passwordTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordTemplateWithIdOnly = await prisma.passwordTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordTemplateFindManyArgs>(args?: SelectSubset<T, PasswordTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordTemplate.
     * @param {PasswordTemplateCreateArgs} args - Arguments to create a PasswordTemplate.
     * @example
     * // Create one PasswordTemplate
     * const PasswordTemplate = await prisma.passwordTemplate.create({
     *   data: {
     *     // ... data to create a PasswordTemplate
     *   }
     * })
     * 
     */
    create<T extends PasswordTemplateCreateArgs>(args: SelectSubset<T, PasswordTemplateCreateArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordTemplates.
     * @param {PasswordTemplateCreateManyArgs} args - Arguments to create many PasswordTemplates.
     * @example
     * // Create many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordTemplateCreateManyArgs>(args?: SelectSubset<T, PasswordTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordTemplates and returns the data saved in the database.
     * @param {PasswordTemplateCreateManyAndReturnArgs} args - Arguments to create many PasswordTemplates.
     * @example
     * // Create many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordTemplates and only return the `id`
     * const passwordTemplateWithIdOnly = await prisma.passwordTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordTemplate.
     * @param {PasswordTemplateDeleteArgs} args - Arguments to delete one PasswordTemplate.
     * @example
     * // Delete one PasswordTemplate
     * const PasswordTemplate = await prisma.passwordTemplate.delete({
     *   where: {
     *     // ... filter to delete one PasswordTemplate
     *   }
     * })
     * 
     */
    delete<T extends PasswordTemplateDeleteArgs>(args: SelectSubset<T, PasswordTemplateDeleteArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordTemplate.
     * @param {PasswordTemplateUpdateArgs} args - Arguments to update one PasswordTemplate.
     * @example
     * // Update one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordTemplateUpdateArgs>(args: SelectSubset<T, PasswordTemplateUpdateArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordTemplates.
     * @param {PasswordTemplateDeleteManyArgs} args - Arguments to filter PasswordTemplates to delete.
     * @example
     * // Delete a few PasswordTemplates
     * const { count } = await prisma.passwordTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordTemplateDeleteManyArgs>(args?: SelectSubset<T, PasswordTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordTemplateUpdateManyArgs>(args: SelectSubset<T, PasswordTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTemplates and returns the data updated in the database.
     * @param {PasswordTemplateUpdateManyAndReturnArgs} args - Arguments to update many PasswordTemplates.
     * @example
     * // Update many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordTemplates and only return the `id`
     * const passwordTemplateWithIdOnly = await prisma.passwordTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordTemplate.
     * @param {PasswordTemplateUpsertArgs} args - Arguments to update or create a PasswordTemplate.
     * @example
     * // Update or create a PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.upsert({
     *   create: {
     *     // ... data to create a PasswordTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordTemplate we want to update
     *   }
     * })
     */
    upsert<T extends PasswordTemplateUpsertArgs>(args: SelectSubset<T, PasswordTemplateUpsertArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateCountArgs} args - Arguments to filter PasswordTemplates to count.
     * @example
     * // Count the number of PasswordTemplates
     * const count = await prisma.passwordTemplate.count({
     *   where: {
     *     // ... the filter for the PasswordTemplates we want to count
     *   }
     * })
    **/
    count<T extends PasswordTemplateCountArgs>(
      args?: Subset<T, PasswordTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordTemplateAggregateArgs>(args: Subset<T, PasswordTemplateAggregateArgs>): Prisma.PrismaPromise<GetPasswordTemplateAggregateType<T>>

    /**
     * Group by PasswordTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordTemplateGroupByArgs['orderBy'] }
        : { orderBy?: PasswordTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordTemplate model
   */
  readonly fields: PasswordTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends PasswordTemplate$ownerArgs<ExtArgs> = {}>(args?: Subset<T, PasswordTemplate$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends PasswordTemplate$companyArgs<ExtArgs> = {}>(args?: Subset<T, PasswordTemplate$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordTemplate model
   */
  interface PasswordTemplateFieldRefs {
    readonly id: FieldRef<"PasswordTemplate", 'String'>
    readonly name: FieldRef<"PasswordTemplate", 'String'>
    readonly description: FieldRef<"PasswordTemplate", 'String'>
    readonly service: FieldRef<"PasswordTemplate", 'String'>
    readonly icon: FieldRef<"PasswordTemplate", 'String'>
    readonly category: FieldRef<"PasswordTemplate", 'String'>
    readonly isSystem: FieldRef<"PasswordTemplate", 'Boolean'>
    readonly isPublic: FieldRef<"PasswordTemplate", 'Boolean'>
    readonly ownerId: FieldRef<"PasswordTemplate", 'String'>
    readonly companyId: FieldRef<"PasswordTemplate", 'String'>
    readonly defaultFields: FieldRef<"PasswordTemplate", 'Json'>
    readonly usageCount: FieldRef<"PasswordTemplate", 'Int'>
    readonly createdAt: FieldRef<"PasswordTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordTemplate findUnique
   */
  export type PasswordTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate findUniqueOrThrow
   */
  export type PasswordTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate findFirst
   */
  export type PasswordTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTemplates.
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTemplates.
     */
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * PasswordTemplate findFirstOrThrow
   */
  export type PasswordTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTemplates.
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTemplates.
     */
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * PasswordTemplate findMany
   */
  export type PasswordTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplates to fetch.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordTemplates.
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * PasswordTemplate create
   */
  export type PasswordTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordTemplate.
     */
    data: XOR<PasswordTemplateCreateInput, PasswordTemplateUncheckedCreateInput>
  }

  /**
   * PasswordTemplate createMany
   */
  export type PasswordTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordTemplates.
     */
    data: PasswordTemplateCreateManyInput | PasswordTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordTemplate createManyAndReturn
   */
  export type PasswordTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordTemplates.
     */
    data: PasswordTemplateCreateManyInput | PasswordTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTemplate update
   */
  export type PasswordTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordTemplate.
     */
    data: XOR<PasswordTemplateUpdateInput, PasswordTemplateUncheckedUpdateInput>
    /**
     * Choose, which PasswordTemplate to update.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate updateMany
   */
  export type PasswordTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordTemplates.
     */
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTemplates to update
     */
    where?: PasswordTemplateWhereInput
    /**
     * Limit how many PasswordTemplates to update.
     */
    limit?: number
  }

  /**
   * PasswordTemplate updateManyAndReturn
   */
  export type PasswordTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * The data used to update PasswordTemplates.
     */
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTemplates to update
     */
    where?: PasswordTemplateWhereInput
    /**
     * Limit how many PasswordTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTemplate upsert
   */
  export type PasswordTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordTemplate to update in case it exists.
     */
    where: PasswordTemplateWhereUniqueInput
    /**
     * In case the PasswordTemplate found by the `where` argument doesn't exist, create a new PasswordTemplate with this data.
     */
    create: XOR<PasswordTemplateCreateInput, PasswordTemplateUncheckedCreateInput>
    /**
     * In case the PasswordTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordTemplateUpdateInput, PasswordTemplateUncheckedUpdateInput>
  }

  /**
   * PasswordTemplate delete
   */
  export type PasswordTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter which PasswordTemplate to delete.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate deleteMany
   */
  export type PasswordTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTemplates to delete
     */
    where?: PasswordTemplateWhereInput
    /**
     * Limit how many PasswordTemplates to delete.
     */
    limit?: number
  }

  /**
   * PasswordTemplate.owner
   */
  export type PasswordTemplate$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PasswordTemplate.company
   */
  export type PasswordTemplate$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * PasswordTemplate without action
   */
  export type PasswordTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
  }


  /**
   * Model EmailVerificationToken
   */

  export type AggregateEmailVerificationToken = {
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  export type EmailVerificationTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    email: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type EmailVerificationTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    createdAt?: true
  }

  export type EmailVerificationTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    createdAt?: true
  }

  export type EmailVerificationTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type EmailVerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationToken to aggregate.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerificationTokens
    **/
    _count?: true | EmailVerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type GetEmailVerificationTokenAggregateType<T extends EmailVerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
      : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
  }




  export type EmailVerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput
    orderBy?: EmailVerificationTokenOrderByWithAggregationInput | EmailVerificationTokenOrderByWithAggregationInput[]
    by: EmailVerificationTokenScalarFieldEnum[] | EmailVerificationTokenScalarFieldEnum
    having?: EmailVerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailVerificationTokenCountAggregateInputType | true
    _min?: EmailVerificationTokenMinAggregateInputType
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type EmailVerificationTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    email: string
    expiresAt: Date
    createdAt: Date
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  type GetEmailVerificationTokenGroupByPayload<T extends EmailVerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type EmailVerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "email" | "expiresAt" | "createdAt", ExtArgs["result"]["emailVerificationToken"]>
  export type EmailVerificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailVerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerificationToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      email: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["emailVerificationToken"]>
    composites: {}
  }

  type EmailVerificationTokenGetPayload<S extends boolean | null | undefined | EmailVerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationTokenPayload, S>

  type EmailVerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailVerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailVerificationTokenCountAggregateInputType | true
    }

  export interface EmailVerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerificationToken'], meta: { name: 'EmailVerificationToken' } }
    /**
     * Find zero or one EmailVerificationToken that matches the filter.
     * @param {EmailVerificationTokenFindUniqueArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationTokenFindUniqueArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailVerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationTokenFindFirstArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailVerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
     * 
     * // Get first 10 EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationTokenFindManyArgs>(args?: SelectSubset<T, EmailVerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailVerificationToken.
     * @param {EmailVerificationTokenCreateArgs} args - Arguments to create a EmailVerificationToken.
     * @example
     * // Create one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.create({
     *   data: {
     *     // ... data to create a EmailVerificationToken
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationTokenCreateArgs>(args: SelectSubset<T, EmailVerificationTokenCreateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailVerificationTokens.
     * @param {EmailVerificationTokenCreateManyArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationTokenCreateManyArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailVerificationTokens and returns the data saved in the database.
     * @param {EmailVerificationTokenCreateManyAndReturnArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailVerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailVerificationToken.
     * @param {EmailVerificationTokenDeleteArgs} args - Arguments to delete one EmailVerificationToken.
     * @example
     * // Delete one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.delete({
     *   where: {
     *     // ... filter to delete one EmailVerificationToken
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationTokenDeleteArgs>(args: SelectSubset<T, EmailVerificationTokenDeleteArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpdateArgs} args - Arguments to update one EmailVerificationToken.
     * @example
     * // Update one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationTokenUpdateArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailVerificationTokens.
     * @param {EmailVerificationTokenDeleteManyArgs} args - Arguments to filter EmailVerificationTokens to delete.
     * @example
     * // Delete a few EmailVerificationTokens
     * const { count } = await prisma.emailVerificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationTokenDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationTokenUpdateManyArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens and returns the data updated in the database.
     * @param {EmailVerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many EmailVerificationTokens.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailVerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpsertArgs} args - Arguments to update or create a EmailVerificationToken.
     * @example
     * // Update or create a EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.upsert({
     *   create: {
     *     // ... data to create a EmailVerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationTokenUpsertArgs>(args: SelectSubset<T, EmailVerificationTokenUpsertArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenCountArgs} args - Arguments to filter EmailVerificationTokens to count.
     * @example
     * // Count the number of EmailVerificationTokens
     * const count = await prisma.emailVerificationToken.count({
     *   where: {
     *     // ... the filter for the EmailVerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationTokenCountArgs>(
      args?: Subset<T, EmailVerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationTokenAggregateArgs>(args: Subset<T, EmailVerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationTokenAggregateType<T>>

    /**
     * Group by EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerificationToken model
   */
  readonly fields: EmailVerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerificationToken model
   */
  interface EmailVerificationTokenFieldRefs {
    readonly id: FieldRef<"EmailVerificationToken", 'String'>
    readonly token: FieldRef<"EmailVerificationToken", 'String'>
    readonly userId: FieldRef<"EmailVerificationToken", 'String'>
    readonly email: FieldRef<"EmailVerificationToken", 'String'>
    readonly expiresAt: FieldRef<"EmailVerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"EmailVerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerificationToken findUnique
   */
  export type EmailVerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findUniqueOrThrow
   */
  export type EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findFirst
   */
  export type EmailVerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken findFirstOrThrow
   */
  export type EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken findMany
   */
  export type EmailVerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationTokens to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken create
   */
  export type EmailVerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
  }

  /**
   * EmailVerificationToken createMany
   */
  export type EmailVerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerificationToken createManyAndReturn
   */
  export type EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken update
   */
  export type EmailVerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which EmailVerificationToken to update.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken updateMany
   */
  export type EmailVerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number
  }

  /**
   * EmailVerificationToken updateManyAndReturn
   */
  export type EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken upsert
   */
  export type EmailVerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailVerificationToken to update in case it exists.
     */
    where: EmailVerificationTokenWhereUniqueInput
    /**
     * In case the EmailVerificationToken found by the `where` argument doesn't exist, create a new EmailVerificationToken with this data.
     */
    create: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
    /**
     * In case the EmailVerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
  }

  /**
   * EmailVerificationToken delete
   */
  export type EmailVerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter which EmailVerificationToken to delete.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken deleteMany
   */
  export type EmailVerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationTokens to delete
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * EmailVerificationToken without action
   */
  export type EmailVerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    email: number
    expiresAt: number
    used: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    email: string
    expiresAt: Date
    used: boolean
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "email" | "expiresAt" | "used" | "usedAt" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      email: string
      expiresAt: Date
      used: boolean
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly used: FieldRef<"PasswordResetToken", 'Boolean'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model SecurityQuestion
   */

  export type AggregateSecurityQuestion = {
    _count: SecurityQuestionCountAggregateOutputType | null
    _min: SecurityQuestionMinAggregateOutputType | null
    _max: SecurityQuestionMaxAggregateOutputType | null
  }

  export type SecurityQuestionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    answerHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityQuestionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    answerHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityQuestionCountAggregateOutputType = {
    id: number
    userId: number
    question: number
    answerHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityQuestionMinAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityQuestionMaxAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityQuestionCountAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityQuestion to aggregate.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityQuestions
    **/
    _count?: true | SecurityQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityQuestionMaxAggregateInputType
  }

  export type GetSecurityQuestionAggregateType<T extends SecurityQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityQuestion[P]>
      : GetScalarType<T[P], AggregateSecurityQuestion[P]>
  }




  export type SecurityQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityQuestionWhereInput
    orderBy?: SecurityQuestionOrderByWithAggregationInput | SecurityQuestionOrderByWithAggregationInput[]
    by: SecurityQuestionScalarFieldEnum[] | SecurityQuestionScalarFieldEnum
    having?: SecurityQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityQuestionCountAggregateInputType | true
    _min?: SecurityQuestionMinAggregateInputType
    _max?: SecurityQuestionMaxAggregateInputType
  }

  export type SecurityQuestionGroupByOutputType = {
    id: string
    userId: string
    question: string
    answerHash: string
    createdAt: Date
    updatedAt: Date
    _count: SecurityQuestionCountAggregateOutputType | null
    _min: SecurityQuestionMinAggregateOutputType | null
    _max: SecurityQuestionMaxAggregateOutputType | null
  }

  type GetSecurityQuestionGroupByPayload<T extends SecurityQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityQuestionGroupByOutputType[P]>
        }
      >
    >


  export type SecurityQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityQuestion"]>

  export type SecurityQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityQuestion"]>

  export type SecurityQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityQuestion"]>

  export type SecurityQuestionSelectScalar = {
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecurityQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "question" | "answerHash" | "createdAt" | "updatedAt", ExtArgs["result"]["securityQuestion"]>
  export type SecurityQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SecurityQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SecurityQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SecurityQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityQuestion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      question: string
      answerHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["securityQuestion"]>
    composites: {}
  }

  type SecurityQuestionGetPayload<S extends boolean | null | undefined | SecurityQuestionDefaultArgs> = $Result.GetResult<Prisma.$SecurityQuestionPayload, S>

  type SecurityQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityQuestionCountAggregateInputType | true
    }

  export interface SecurityQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityQuestion'], meta: { name: 'SecurityQuestion' } }
    /**
     * Find zero or one SecurityQuestion that matches the filter.
     * @param {SecurityQuestionFindUniqueArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityQuestionFindUniqueArgs>(args: SelectSubset<T, SecurityQuestionFindUniqueArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityQuestionFindUniqueOrThrowArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionFindFirstArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityQuestionFindFirstArgs>(args?: SelectSubset<T, SecurityQuestionFindFirstArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionFindFirstOrThrowArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityQuestions
     * const securityQuestions = await prisma.securityQuestion.findMany()
     * 
     * // Get first 10 SecurityQuestions
     * const securityQuestions = await prisma.securityQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityQuestionWithIdOnly = await prisma.securityQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityQuestionFindManyArgs>(args?: SelectSubset<T, SecurityQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityQuestion.
     * @param {SecurityQuestionCreateArgs} args - Arguments to create a SecurityQuestion.
     * @example
     * // Create one SecurityQuestion
     * const SecurityQuestion = await prisma.securityQuestion.create({
     *   data: {
     *     // ... data to create a SecurityQuestion
     *   }
     * })
     * 
     */
    create<T extends SecurityQuestionCreateArgs>(args: SelectSubset<T, SecurityQuestionCreateArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityQuestions.
     * @param {SecurityQuestionCreateManyArgs} args - Arguments to create many SecurityQuestions.
     * @example
     * // Create many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityQuestionCreateManyArgs>(args?: SelectSubset<T, SecurityQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityQuestions and returns the data saved in the database.
     * @param {SecurityQuestionCreateManyAndReturnArgs} args - Arguments to create many SecurityQuestions.
     * @example
     * // Create many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityQuestions and only return the `id`
     * const securityQuestionWithIdOnly = await prisma.securityQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityQuestion.
     * @param {SecurityQuestionDeleteArgs} args - Arguments to delete one SecurityQuestion.
     * @example
     * // Delete one SecurityQuestion
     * const SecurityQuestion = await prisma.securityQuestion.delete({
     *   where: {
     *     // ... filter to delete one SecurityQuestion
     *   }
     * })
     * 
     */
    delete<T extends SecurityQuestionDeleteArgs>(args: SelectSubset<T, SecurityQuestionDeleteArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityQuestion.
     * @param {SecurityQuestionUpdateArgs} args - Arguments to update one SecurityQuestion.
     * @example
     * // Update one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityQuestionUpdateArgs>(args: SelectSubset<T, SecurityQuestionUpdateArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityQuestions.
     * @param {SecurityQuestionDeleteManyArgs} args - Arguments to filter SecurityQuestions to delete.
     * @example
     * // Delete a few SecurityQuestions
     * const { count } = await prisma.securityQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityQuestionDeleteManyArgs>(args?: SelectSubset<T, SecurityQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityQuestionUpdateManyArgs>(args: SelectSubset<T, SecurityQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityQuestions and returns the data updated in the database.
     * @param {SecurityQuestionUpdateManyAndReturnArgs} args - Arguments to update many SecurityQuestions.
     * @example
     * // Update many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityQuestions and only return the `id`
     * const securityQuestionWithIdOnly = await prisma.securityQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityQuestion.
     * @param {SecurityQuestionUpsertArgs} args - Arguments to update or create a SecurityQuestion.
     * @example
     * // Update or create a SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.upsert({
     *   create: {
     *     // ... data to create a SecurityQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityQuestion we want to update
     *   }
     * })
     */
    upsert<T extends SecurityQuestionUpsertArgs>(args: SelectSubset<T, SecurityQuestionUpsertArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionCountArgs} args - Arguments to filter SecurityQuestions to count.
     * @example
     * // Count the number of SecurityQuestions
     * const count = await prisma.securityQuestion.count({
     *   where: {
     *     // ... the filter for the SecurityQuestions we want to count
     *   }
     * })
    **/
    count<T extends SecurityQuestionCountArgs>(
      args?: Subset<T, SecurityQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityQuestionAggregateArgs>(args: Subset<T, SecurityQuestionAggregateArgs>): Prisma.PrismaPromise<GetSecurityQuestionAggregateType<T>>

    /**
     * Group by SecurityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityQuestionGroupByArgs['orderBy'] }
        : { orderBy?: SecurityQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityQuestion model
   */
  readonly fields: SecurityQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityQuestion model
   */
  interface SecurityQuestionFieldRefs {
    readonly id: FieldRef<"SecurityQuestion", 'String'>
    readonly userId: FieldRef<"SecurityQuestion", 'String'>
    readonly question: FieldRef<"SecurityQuestion", 'String'>
    readonly answerHash: FieldRef<"SecurityQuestion", 'String'>
    readonly createdAt: FieldRef<"SecurityQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"SecurityQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityQuestion findUnique
   */
  export type SecurityQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion findUniqueOrThrow
   */
  export type SecurityQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion findFirst
   */
  export type SecurityQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityQuestions.
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityQuestions.
     */
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * SecurityQuestion findFirstOrThrow
   */
  export type SecurityQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityQuestions.
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityQuestions.
     */
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * SecurityQuestion findMany
   */
  export type SecurityQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestions to fetch.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityQuestions.
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * SecurityQuestion create
   */
  export type SecurityQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityQuestion.
     */
    data: XOR<SecurityQuestionCreateInput, SecurityQuestionUncheckedCreateInput>
  }

  /**
   * SecurityQuestion createMany
   */
  export type SecurityQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityQuestions.
     */
    data: SecurityQuestionCreateManyInput | SecurityQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityQuestion createManyAndReturn
   */
  export type SecurityQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityQuestions.
     */
    data: SecurityQuestionCreateManyInput | SecurityQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityQuestion update
   */
  export type SecurityQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityQuestion.
     */
    data: XOR<SecurityQuestionUpdateInput, SecurityQuestionUncheckedUpdateInput>
    /**
     * Choose, which SecurityQuestion to update.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion updateMany
   */
  export type SecurityQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityQuestions.
     */
    data: XOR<SecurityQuestionUpdateManyMutationInput, SecurityQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SecurityQuestions to update
     */
    where?: SecurityQuestionWhereInput
    /**
     * Limit how many SecurityQuestions to update.
     */
    limit?: number
  }

  /**
   * SecurityQuestion updateManyAndReturn
   */
  export type SecurityQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * The data used to update SecurityQuestions.
     */
    data: XOR<SecurityQuestionUpdateManyMutationInput, SecurityQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SecurityQuestions to update
     */
    where?: SecurityQuestionWhereInput
    /**
     * Limit how many SecurityQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityQuestion upsert
   */
  export type SecurityQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityQuestion to update in case it exists.
     */
    where: SecurityQuestionWhereUniqueInput
    /**
     * In case the SecurityQuestion found by the `where` argument doesn't exist, create a new SecurityQuestion with this data.
     */
    create: XOR<SecurityQuestionCreateInput, SecurityQuestionUncheckedCreateInput>
    /**
     * In case the SecurityQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityQuestionUpdateInput, SecurityQuestionUncheckedUpdateInput>
  }

  /**
   * SecurityQuestion delete
   */
  export type SecurityQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter which SecurityQuestion to delete.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion deleteMany
   */
  export type SecurityQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityQuestions to delete
     */
    where?: SecurityQuestionWhereInput
    /**
     * Limit how many SecurityQuestions to delete.
     */
    limit?: number
  }

  /**
   * SecurityQuestion without action
   */
  export type SecurityQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
  }


  /**
   * Model IpWhitelist
   */

  export type AggregateIpWhitelist = {
    _count: IpWhitelistCountAggregateOutputType | null
    _min: IpWhitelistMinAggregateOutputType | null
    _max: IpWhitelistMaxAggregateOutputType | null
  }

  export type IpWhitelistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    ipAddress: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type IpWhitelistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    ipAddress: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type IpWhitelistCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    ipAddress: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type IpWhitelistMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    ipAddress?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type IpWhitelistMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    ipAddress?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type IpWhitelistCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    ipAddress?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type IpWhitelistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpWhitelist to aggregate.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IpWhitelists
    **/
    _count?: true | IpWhitelistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IpWhitelistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IpWhitelistMaxAggregateInputType
  }

  export type GetIpWhitelistAggregateType<T extends IpWhitelistAggregateArgs> = {
        [P in keyof T & keyof AggregateIpWhitelist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIpWhitelist[P]>
      : GetScalarType<T[P], AggregateIpWhitelist[P]>
  }




  export type IpWhitelistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IpWhitelistWhereInput
    orderBy?: IpWhitelistOrderByWithAggregationInput | IpWhitelistOrderByWithAggregationInput[]
    by: IpWhitelistScalarFieldEnum[] | IpWhitelistScalarFieldEnum
    having?: IpWhitelistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IpWhitelistCountAggregateInputType | true
    _min?: IpWhitelistMinAggregateInputType
    _max?: IpWhitelistMaxAggregateInputType
  }

  export type IpWhitelistGroupByOutputType = {
    id: string
    userId: string | null
    companyId: string | null
    ipAddress: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: IpWhitelistCountAggregateOutputType | null
    _min: IpWhitelistMinAggregateOutputType | null
    _max: IpWhitelistMaxAggregateOutputType | null
  }

  type GetIpWhitelistGroupByPayload<T extends IpWhitelistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IpWhitelistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IpWhitelistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IpWhitelistGroupByOutputType[P]>
            : GetScalarType<T[P], IpWhitelistGroupByOutputType[P]>
        }
      >
    >


  export type IpWhitelistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    user?: boolean | IpWhitelist$userArgs<ExtArgs>
    company?: boolean | IpWhitelist$companyArgs<ExtArgs>
    creator?: boolean | IpWhitelist$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["ipWhitelist"]>

  export type IpWhitelistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    user?: boolean | IpWhitelist$userArgs<ExtArgs>
    company?: boolean | IpWhitelist$companyArgs<ExtArgs>
    creator?: boolean | IpWhitelist$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["ipWhitelist"]>

  export type IpWhitelistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    user?: boolean | IpWhitelist$userArgs<ExtArgs>
    company?: boolean | IpWhitelist$companyArgs<ExtArgs>
    creator?: boolean | IpWhitelist$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["ipWhitelist"]>

  export type IpWhitelistSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    ipAddress?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type IpWhitelistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "ipAddress" | "description" | "isActive" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["ipWhitelist"]>
  export type IpWhitelistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | IpWhitelist$userArgs<ExtArgs>
    company?: boolean | IpWhitelist$companyArgs<ExtArgs>
    creator?: boolean | IpWhitelist$creatorArgs<ExtArgs>
  }
  export type IpWhitelistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | IpWhitelist$userArgs<ExtArgs>
    company?: boolean | IpWhitelist$companyArgs<ExtArgs>
    creator?: boolean | IpWhitelist$creatorArgs<ExtArgs>
  }
  export type IpWhitelistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | IpWhitelist$userArgs<ExtArgs>
    company?: boolean | IpWhitelist$companyArgs<ExtArgs>
    creator?: boolean | IpWhitelist$creatorArgs<ExtArgs>
  }

  export type $IpWhitelistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IpWhitelist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      companyId: string | null
      ipAddress: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["ipWhitelist"]>
    composites: {}
  }

  type IpWhitelistGetPayload<S extends boolean | null | undefined | IpWhitelistDefaultArgs> = $Result.GetResult<Prisma.$IpWhitelistPayload, S>

  type IpWhitelistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IpWhitelistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IpWhitelistCountAggregateInputType | true
    }

  export interface IpWhitelistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IpWhitelist'], meta: { name: 'IpWhitelist' } }
    /**
     * Find zero or one IpWhitelist that matches the filter.
     * @param {IpWhitelistFindUniqueArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IpWhitelistFindUniqueArgs>(args: SelectSubset<T, IpWhitelistFindUniqueArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IpWhitelist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IpWhitelistFindUniqueOrThrowArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IpWhitelistFindUniqueOrThrowArgs>(args: SelectSubset<T, IpWhitelistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpWhitelist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistFindFirstArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IpWhitelistFindFirstArgs>(args?: SelectSubset<T, IpWhitelistFindFirstArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IpWhitelist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistFindFirstOrThrowArgs} args - Arguments to find a IpWhitelist
     * @example
     * // Get one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IpWhitelistFindFirstOrThrowArgs>(args?: SelectSubset<T, IpWhitelistFindFirstOrThrowArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IpWhitelists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IpWhitelists
     * const ipWhitelists = await prisma.ipWhitelist.findMany()
     * 
     * // Get first 10 IpWhitelists
     * const ipWhitelists = await prisma.ipWhitelist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ipWhitelistWithIdOnly = await prisma.ipWhitelist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IpWhitelistFindManyArgs>(args?: SelectSubset<T, IpWhitelistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IpWhitelist.
     * @param {IpWhitelistCreateArgs} args - Arguments to create a IpWhitelist.
     * @example
     * // Create one IpWhitelist
     * const IpWhitelist = await prisma.ipWhitelist.create({
     *   data: {
     *     // ... data to create a IpWhitelist
     *   }
     * })
     * 
     */
    create<T extends IpWhitelistCreateArgs>(args: SelectSubset<T, IpWhitelistCreateArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IpWhitelists.
     * @param {IpWhitelistCreateManyArgs} args - Arguments to create many IpWhitelists.
     * @example
     * // Create many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IpWhitelistCreateManyArgs>(args?: SelectSubset<T, IpWhitelistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IpWhitelists and returns the data saved in the database.
     * @param {IpWhitelistCreateManyAndReturnArgs} args - Arguments to create many IpWhitelists.
     * @example
     * // Create many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IpWhitelists and only return the `id`
     * const ipWhitelistWithIdOnly = await prisma.ipWhitelist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IpWhitelistCreateManyAndReturnArgs>(args?: SelectSubset<T, IpWhitelistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IpWhitelist.
     * @param {IpWhitelistDeleteArgs} args - Arguments to delete one IpWhitelist.
     * @example
     * // Delete one IpWhitelist
     * const IpWhitelist = await prisma.ipWhitelist.delete({
     *   where: {
     *     // ... filter to delete one IpWhitelist
     *   }
     * })
     * 
     */
    delete<T extends IpWhitelistDeleteArgs>(args: SelectSubset<T, IpWhitelistDeleteArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IpWhitelist.
     * @param {IpWhitelistUpdateArgs} args - Arguments to update one IpWhitelist.
     * @example
     * // Update one IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IpWhitelistUpdateArgs>(args: SelectSubset<T, IpWhitelistUpdateArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IpWhitelists.
     * @param {IpWhitelistDeleteManyArgs} args - Arguments to filter IpWhitelists to delete.
     * @example
     * // Delete a few IpWhitelists
     * const { count } = await prisma.ipWhitelist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IpWhitelistDeleteManyArgs>(args?: SelectSubset<T, IpWhitelistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpWhitelists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IpWhitelistUpdateManyArgs>(args: SelectSubset<T, IpWhitelistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IpWhitelists and returns the data updated in the database.
     * @param {IpWhitelistUpdateManyAndReturnArgs} args - Arguments to update many IpWhitelists.
     * @example
     * // Update many IpWhitelists
     * const ipWhitelist = await prisma.ipWhitelist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IpWhitelists and only return the `id`
     * const ipWhitelistWithIdOnly = await prisma.ipWhitelist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IpWhitelistUpdateManyAndReturnArgs>(args: SelectSubset<T, IpWhitelistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IpWhitelist.
     * @param {IpWhitelistUpsertArgs} args - Arguments to update or create a IpWhitelist.
     * @example
     * // Update or create a IpWhitelist
     * const ipWhitelist = await prisma.ipWhitelist.upsert({
     *   create: {
     *     // ... data to create a IpWhitelist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IpWhitelist we want to update
     *   }
     * })
     */
    upsert<T extends IpWhitelistUpsertArgs>(args: SelectSubset<T, IpWhitelistUpsertArgs<ExtArgs>>): Prisma__IpWhitelistClient<$Result.GetResult<Prisma.$IpWhitelistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IpWhitelists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistCountArgs} args - Arguments to filter IpWhitelists to count.
     * @example
     * // Count the number of IpWhitelists
     * const count = await prisma.ipWhitelist.count({
     *   where: {
     *     // ... the filter for the IpWhitelists we want to count
     *   }
     * })
    **/
    count<T extends IpWhitelistCountArgs>(
      args?: Subset<T, IpWhitelistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IpWhitelistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IpWhitelist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IpWhitelistAggregateArgs>(args: Subset<T, IpWhitelistAggregateArgs>): Prisma.PrismaPromise<GetIpWhitelistAggregateType<T>>

    /**
     * Group by IpWhitelist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpWhitelistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IpWhitelistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IpWhitelistGroupByArgs['orderBy'] }
        : { orderBy?: IpWhitelistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IpWhitelistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIpWhitelistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IpWhitelist model
   */
  readonly fields: IpWhitelistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IpWhitelist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IpWhitelistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends IpWhitelist$userArgs<ExtArgs> = {}>(args?: Subset<T, IpWhitelist$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends IpWhitelist$companyArgs<ExtArgs> = {}>(args?: Subset<T, IpWhitelist$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends IpWhitelist$creatorArgs<ExtArgs> = {}>(args?: Subset<T, IpWhitelist$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IpWhitelist model
   */
  interface IpWhitelistFieldRefs {
    readonly id: FieldRef<"IpWhitelist", 'String'>
    readonly userId: FieldRef<"IpWhitelist", 'String'>
    readonly companyId: FieldRef<"IpWhitelist", 'String'>
    readonly ipAddress: FieldRef<"IpWhitelist", 'String'>
    readonly description: FieldRef<"IpWhitelist", 'String'>
    readonly isActive: FieldRef<"IpWhitelist", 'Boolean'>
    readonly createdAt: FieldRef<"IpWhitelist", 'DateTime'>
    readonly updatedAt: FieldRef<"IpWhitelist", 'DateTime'>
    readonly createdById: FieldRef<"IpWhitelist", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IpWhitelist findUnique
   */
  export type IpWhitelistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist findUniqueOrThrow
   */
  export type IpWhitelistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist findFirst
   */
  export type IpWhitelistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpWhitelists.
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpWhitelists.
     */
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * IpWhitelist findFirstOrThrow
   */
  export type IpWhitelistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * Filter, which IpWhitelist to fetch.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IpWhitelists.
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IpWhitelists.
     */
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * IpWhitelist findMany
   */
  export type IpWhitelistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * Filter, which IpWhitelists to fetch.
     */
    where?: IpWhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IpWhitelists to fetch.
     */
    orderBy?: IpWhitelistOrderByWithRelationInput | IpWhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IpWhitelists.
     */
    cursor?: IpWhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IpWhitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IpWhitelists.
     */
    skip?: number
    distinct?: IpWhitelistScalarFieldEnum | IpWhitelistScalarFieldEnum[]
  }

  /**
   * IpWhitelist create
   */
  export type IpWhitelistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * The data needed to create a IpWhitelist.
     */
    data: XOR<IpWhitelistCreateInput, IpWhitelistUncheckedCreateInput>
  }

  /**
   * IpWhitelist createMany
   */
  export type IpWhitelistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IpWhitelists.
     */
    data: IpWhitelistCreateManyInput | IpWhitelistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IpWhitelist createManyAndReturn
   */
  export type IpWhitelistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * The data used to create many IpWhitelists.
     */
    data: IpWhitelistCreateManyInput | IpWhitelistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IpWhitelist update
   */
  export type IpWhitelistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * The data needed to update a IpWhitelist.
     */
    data: XOR<IpWhitelistUpdateInput, IpWhitelistUncheckedUpdateInput>
    /**
     * Choose, which IpWhitelist to update.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist updateMany
   */
  export type IpWhitelistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IpWhitelists.
     */
    data: XOR<IpWhitelistUpdateManyMutationInput, IpWhitelistUncheckedUpdateManyInput>
    /**
     * Filter which IpWhitelists to update
     */
    where?: IpWhitelistWhereInput
    /**
     * Limit how many IpWhitelists to update.
     */
    limit?: number
  }

  /**
   * IpWhitelist updateManyAndReturn
   */
  export type IpWhitelistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * The data used to update IpWhitelists.
     */
    data: XOR<IpWhitelistUpdateManyMutationInput, IpWhitelistUncheckedUpdateManyInput>
    /**
     * Filter which IpWhitelists to update
     */
    where?: IpWhitelistWhereInput
    /**
     * Limit how many IpWhitelists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IpWhitelist upsert
   */
  export type IpWhitelistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * The filter to search for the IpWhitelist to update in case it exists.
     */
    where: IpWhitelistWhereUniqueInput
    /**
     * In case the IpWhitelist found by the `where` argument doesn't exist, create a new IpWhitelist with this data.
     */
    create: XOR<IpWhitelistCreateInput, IpWhitelistUncheckedCreateInput>
    /**
     * In case the IpWhitelist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IpWhitelistUpdateInput, IpWhitelistUncheckedUpdateInput>
  }

  /**
   * IpWhitelist delete
   */
  export type IpWhitelistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
    /**
     * Filter which IpWhitelist to delete.
     */
    where: IpWhitelistWhereUniqueInput
  }

  /**
   * IpWhitelist deleteMany
   */
  export type IpWhitelistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IpWhitelists to delete
     */
    where?: IpWhitelistWhereInput
    /**
     * Limit how many IpWhitelists to delete.
     */
    limit?: number
  }

  /**
   * IpWhitelist.user
   */
  export type IpWhitelist$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * IpWhitelist.company
   */
  export type IpWhitelist$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * IpWhitelist.creator
   */
  export type IpWhitelist$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * IpWhitelist without action
   */
  export type IpWhitelistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IpWhitelist
     */
    select?: IpWhitelistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IpWhitelist
     */
    omit?: IpWhitelistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IpWhitelistInclude<ExtArgs> | null
  }


  /**
   * Model GeographicRestriction
   */

  export type AggregateGeographicRestriction = {
    _count: GeographicRestrictionCountAggregateOutputType | null
    _min: GeographicRestrictionMinAggregateOutputType | null
    _max: GeographicRestrictionMaxAggregateOutputType | null
  }

  export type GeographicRestrictionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    countryCode: string | null
    action: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type GeographicRestrictionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    countryCode: string | null
    action: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type GeographicRestrictionCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    countryCode: number
    action: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type GeographicRestrictionMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    countryCode?: true
    action?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type GeographicRestrictionMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    countryCode?: true
    action?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type GeographicRestrictionCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    countryCode?: true
    action?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type GeographicRestrictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeographicRestriction to aggregate.
     */
    where?: GeographicRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeographicRestrictions to fetch.
     */
    orderBy?: GeographicRestrictionOrderByWithRelationInput | GeographicRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeographicRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeographicRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeographicRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeographicRestrictions
    **/
    _count?: true | GeographicRestrictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeographicRestrictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeographicRestrictionMaxAggregateInputType
  }

  export type GetGeographicRestrictionAggregateType<T extends GeographicRestrictionAggregateArgs> = {
        [P in keyof T & keyof AggregateGeographicRestriction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeographicRestriction[P]>
      : GetScalarType<T[P], AggregateGeographicRestriction[P]>
  }




  export type GeographicRestrictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeographicRestrictionWhereInput
    orderBy?: GeographicRestrictionOrderByWithAggregationInput | GeographicRestrictionOrderByWithAggregationInput[]
    by: GeographicRestrictionScalarFieldEnum[] | GeographicRestrictionScalarFieldEnum
    having?: GeographicRestrictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeographicRestrictionCountAggregateInputType | true
    _min?: GeographicRestrictionMinAggregateInputType
    _max?: GeographicRestrictionMaxAggregateInputType
  }

  export type GeographicRestrictionGroupByOutputType = {
    id: string
    userId: string | null
    companyId: string | null
    countryCode: string
    action: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: GeographicRestrictionCountAggregateOutputType | null
    _min: GeographicRestrictionMinAggregateOutputType | null
    _max: GeographicRestrictionMaxAggregateOutputType | null
  }

  type GetGeographicRestrictionGroupByPayload<T extends GeographicRestrictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeographicRestrictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeographicRestrictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeographicRestrictionGroupByOutputType[P]>
            : GetScalarType<T[P], GeographicRestrictionGroupByOutputType[P]>
        }
      >
    >


  export type GeographicRestrictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    countryCode?: boolean
    action?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    user?: boolean | GeographicRestriction$userArgs<ExtArgs>
    company?: boolean | GeographicRestriction$companyArgs<ExtArgs>
    creator?: boolean | GeographicRestriction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["geographicRestriction"]>

  export type GeographicRestrictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    countryCode?: boolean
    action?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    user?: boolean | GeographicRestriction$userArgs<ExtArgs>
    company?: boolean | GeographicRestriction$companyArgs<ExtArgs>
    creator?: boolean | GeographicRestriction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["geographicRestriction"]>

  export type GeographicRestrictionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    countryCode?: boolean
    action?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    user?: boolean | GeographicRestriction$userArgs<ExtArgs>
    company?: boolean | GeographicRestriction$companyArgs<ExtArgs>
    creator?: boolean | GeographicRestriction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["geographicRestriction"]>

  export type GeographicRestrictionSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    countryCode?: boolean
    action?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type GeographicRestrictionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "countryCode" | "action" | "isActive" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["geographicRestriction"]>
  export type GeographicRestrictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeographicRestriction$userArgs<ExtArgs>
    company?: boolean | GeographicRestriction$companyArgs<ExtArgs>
    creator?: boolean | GeographicRestriction$creatorArgs<ExtArgs>
  }
  export type GeographicRestrictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeographicRestriction$userArgs<ExtArgs>
    company?: boolean | GeographicRestriction$companyArgs<ExtArgs>
    creator?: boolean | GeographicRestriction$creatorArgs<ExtArgs>
  }
  export type GeographicRestrictionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeographicRestriction$userArgs<ExtArgs>
    company?: boolean | GeographicRestriction$companyArgs<ExtArgs>
    creator?: boolean | GeographicRestriction$creatorArgs<ExtArgs>
  }

  export type $GeographicRestrictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeographicRestriction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      companyId: string | null
      countryCode: string
      action: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["geographicRestriction"]>
    composites: {}
  }

  type GeographicRestrictionGetPayload<S extends boolean | null | undefined | GeographicRestrictionDefaultArgs> = $Result.GetResult<Prisma.$GeographicRestrictionPayload, S>

  type GeographicRestrictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeographicRestrictionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeographicRestrictionCountAggregateInputType | true
    }

  export interface GeographicRestrictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeographicRestriction'], meta: { name: 'GeographicRestriction' } }
    /**
     * Find zero or one GeographicRestriction that matches the filter.
     * @param {GeographicRestrictionFindUniqueArgs} args - Arguments to find a GeographicRestriction
     * @example
     * // Get one GeographicRestriction
     * const geographicRestriction = await prisma.geographicRestriction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeographicRestrictionFindUniqueArgs>(args: SelectSubset<T, GeographicRestrictionFindUniqueArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeographicRestriction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeographicRestrictionFindUniqueOrThrowArgs} args - Arguments to find a GeographicRestriction
     * @example
     * // Get one GeographicRestriction
     * const geographicRestriction = await prisma.geographicRestriction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeographicRestrictionFindUniqueOrThrowArgs>(args: SelectSubset<T, GeographicRestrictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeographicRestriction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeographicRestrictionFindFirstArgs} args - Arguments to find a GeographicRestriction
     * @example
     * // Get one GeographicRestriction
     * const geographicRestriction = await prisma.geographicRestriction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeographicRestrictionFindFirstArgs>(args?: SelectSubset<T, GeographicRestrictionFindFirstArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeographicRestriction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeographicRestrictionFindFirstOrThrowArgs} args - Arguments to find a GeographicRestriction
     * @example
     * // Get one GeographicRestriction
     * const geographicRestriction = await prisma.geographicRestriction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeographicRestrictionFindFirstOrThrowArgs>(args?: SelectSubset<T, GeographicRestrictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeographicRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeographicRestrictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeographicRestrictions
     * const geographicRestrictions = await prisma.geographicRestriction.findMany()
     * 
     * // Get first 10 GeographicRestrictions
     * const geographicRestrictions = await prisma.geographicRestriction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geographicRestrictionWithIdOnly = await prisma.geographicRestriction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeographicRestrictionFindManyArgs>(args?: SelectSubset<T, GeographicRestrictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeographicRestriction.
     * @param {GeographicRestrictionCreateArgs} args - Arguments to create a GeographicRestriction.
     * @example
     * // Create one GeographicRestriction
     * const GeographicRestriction = await prisma.geographicRestriction.create({
     *   data: {
     *     // ... data to create a GeographicRestriction
     *   }
     * })
     * 
     */
    create<T extends GeographicRestrictionCreateArgs>(args: SelectSubset<T, GeographicRestrictionCreateArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeographicRestrictions.
     * @param {GeographicRestrictionCreateManyArgs} args - Arguments to create many GeographicRestrictions.
     * @example
     * // Create many GeographicRestrictions
     * const geographicRestriction = await prisma.geographicRestriction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeographicRestrictionCreateManyArgs>(args?: SelectSubset<T, GeographicRestrictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeographicRestrictions and returns the data saved in the database.
     * @param {GeographicRestrictionCreateManyAndReturnArgs} args - Arguments to create many GeographicRestrictions.
     * @example
     * // Create many GeographicRestrictions
     * const geographicRestriction = await prisma.geographicRestriction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeographicRestrictions and only return the `id`
     * const geographicRestrictionWithIdOnly = await prisma.geographicRestriction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeographicRestrictionCreateManyAndReturnArgs>(args?: SelectSubset<T, GeographicRestrictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeographicRestriction.
     * @param {GeographicRestrictionDeleteArgs} args - Arguments to delete one GeographicRestriction.
     * @example
     * // Delete one GeographicRestriction
     * const GeographicRestriction = await prisma.geographicRestriction.delete({
     *   where: {
     *     // ... filter to delete one GeographicRestriction
     *   }
     * })
     * 
     */
    delete<T extends GeographicRestrictionDeleteArgs>(args: SelectSubset<T, GeographicRestrictionDeleteArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeographicRestriction.
     * @param {GeographicRestrictionUpdateArgs} args - Arguments to update one GeographicRestriction.
     * @example
     * // Update one GeographicRestriction
     * const geographicRestriction = await prisma.geographicRestriction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeographicRestrictionUpdateArgs>(args: SelectSubset<T, GeographicRestrictionUpdateArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeographicRestrictions.
     * @param {GeographicRestrictionDeleteManyArgs} args - Arguments to filter GeographicRestrictions to delete.
     * @example
     * // Delete a few GeographicRestrictions
     * const { count } = await prisma.geographicRestriction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeographicRestrictionDeleteManyArgs>(args?: SelectSubset<T, GeographicRestrictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeographicRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeographicRestrictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeographicRestrictions
     * const geographicRestriction = await prisma.geographicRestriction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeographicRestrictionUpdateManyArgs>(args: SelectSubset<T, GeographicRestrictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeographicRestrictions and returns the data updated in the database.
     * @param {GeographicRestrictionUpdateManyAndReturnArgs} args - Arguments to update many GeographicRestrictions.
     * @example
     * // Update many GeographicRestrictions
     * const geographicRestriction = await prisma.geographicRestriction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeographicRestrictions and only return the `id`
     * const geographicRestrictionWithIdOnly = await prisma.geographicRestriction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeographicRestrictionUpdateManyAndReturnArgs>(args: SelectSubset<T, GeographicRestrictionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeographicRestriction.
     * @param {GeographicRestrictionUpsertArgs} args - Arguments to update or create a GeographicRestriction.
     * @example
     * // Update or create a GeographicRestriction
     * const geographicRestriction = await prisma.geographicRestriction.upsert({
     *   create: {
     *     // ... data to create a GeographicRestriction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeographicRestriction we want to update
     *   }
     * })
     */
    upsert<T extends GeographicRestrictionUpsertArgs>(args: SelectSubset<T, GeographicRestrictionUpsertArgs<ExtArgs>>): Prisma__GeographicRestrictionClient<$Result.GetResult<Prisma.$GeographicRestrictionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeographicRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeographicRestrictionCountArgs} args - Arguments to filter GeographicRestrictions to count.
     * @example
     * // Count the number of GeographicRestrictions
     * const count = await prisma.geographicRestriction.count({
     *   where: {
     *     // ... the filter for the GeographicRestrictions we want to count
     *   }
     * })
    **/
    count<T extends GeographicRestrictionCountArgs>(
      args?: Subset<T, GeographicRestrictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeographicRestrictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeographicRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeographicRestrictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeographicRestrictionAggregateArgs>(args: Subset<T, GeographicRestrictionAggregateArgs>): Prisma.PrismaPromise<GetGeographicRestrictionAggregateType<T>>

    /**
     * Group by GeographicRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeographicRestrictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeographicRestrictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeographicRestrictionGroupByArgs['orderBy'] }
        : { orderBy?: GeographicRestrictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeographicRestrictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeographicRestrictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeographicRestriction model
   */
  readonly fields: GeographicRestrictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeographicRestriction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeographicRestrictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends GeographicRestriction$userArgs<ExtArgs> = {}>(args?: Subset<T, GeographicRestriction$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends GeographicRestriction$companyArgs<ExtArgs> = {}>(args?: Subset<T, GeographicRestriction$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends GeographicRestriction$creatorArgs<ExtArgs> = {}>(args?: Subset<T, GeographicRestriction$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeographicRestriction model
   */
  interface GeographicRestrictionFieldRefs {
    readonly id: FieldRef<"GeographicRestriction", 'String'>
    readonly userId: FieldRef<"GeographicRestriction", 'String'>
    readonly companyId: FieldRef<"GeographicRestriction", 'String'>
    readonly countryCode: FieldRef<"GeographicRestriction", 'String'>
    readonly action: FieldRef<"GeographicRestriction", 'String'>
    readonly isActive: FieldRef<"GeographicRestriction", 'Boolean'>
    readonly createdAt: FieldRef<"GeographicRestriction", 'DateTime'>
    readonly updatedAt: FieldRef<"GeographicRestriction", 'DateTime'>
    readonly createdById: FieldRef<"GeographicRestriction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GeographicRestriction findUnique
   */
  export type GeographicRestrictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which GeographicRestriction to fetch.
     */
    where: GeographicRestrictionWhereUniqueInput
  }

  /**
   * GeographicRestriction findUniqueOrThrow
   */
  export type GeographicRestrictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which GeographicRestriction to fetch.
     */
    where: GeographicRestrictionWhereUniqueInput
  }

  /**
   * GeographicRestriction findFirst
   */
  export type GeographicRestrictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which GeographicRestriction to fetch.
     */
    where?: GeographicRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeographicRestrictions to fetch.
     */
    orderBy?: GeographicRestrictionOrderByWithRelationInput | GeographicRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeographicRestrictions.
     */
    cursor?: GeographicRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeographicRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeographicRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeographicRestrictions.
     */
    distinct?: GeographicRestrictionScalarFieldEnum | GeographicRestrictionScalarFieldEnum[]
  }

  /**
   * GeographicRestriction findFirstOrThrow
   */
  export type GeographicRestrictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which GeographicRestriction to fetch.
     */
    where?: GeographicRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeographicRestrictions to fetch.
     */
    orderBy?: GeographicRestrictionOrderByWithRelationInput | GeographicRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeographicRestrictions.
     */
    cursor?: GeographicRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeographicRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeographicRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeographicRestrictions.
     */
    distinct?: GeographicRestrictionScalarFieldEnum | GeographicRestrictionScalarFieldEnum[]
  }

  /**
   * GeographicRestriction findMany
   */
  export type GeographicRestrictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which GeographicRestrictions to fetch.
     */
    where?: GeographicRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeographicRestrictions to fetch.
     */
    orderBy?: GeographicRestrictionOrderByWithRelationInput | GeographicRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeographicRestrictions.
     */
    cursor?: GeographicRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeographicRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeographicRestrictions.
     */
    skip?: number
    distinct?: GeographicRestrictionScalarFieldEnum | GeographicRestrictionScalarFieldEnum[]
  }

  /**
   * GeographicRestriction create
   */
  export type GeographicRestrictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to create a GeographicRestriction.
     */
    data: XOR<GeographicRestrictionCreateInput, GeographicRestrictionUncheckedCreateInput>
  }

  /**
   * GeographicRestriction createMany
   */
  export type GeographicRestrictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeographicRestrictions.
     */
    data: GeographicRestrictionCreateManyInput | GeographicRestrictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeographicRestriction createManyAndReturn
   */
  export type GeographicRestrictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * The data used to create many GeographicRestrictions.
     */
    data: GeographicRestrictionCreateManyInput | GeographicRestrictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeographicRestriction update
   */
  export type GeographicRestrictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to update a GeographicRestriction.
     */
    data: XOR<GeographicRestrictionUpdateInput, GeographicRestrictionUncheckedUpdateInput>
    /**
     * Choose, which GeographicRestriction to update.
     */
    where: GeographicRestrictionWhereUniqueInput
  }

  /**
   * GeographicRestriction updateMany
   */
  export type GeographicRestrictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeographicRestrictions.
     */
    data: XOR<GeographicRestrictionUpdateManyMutationInput, GeographicRestrictionUncheckedUpdateManyInput>
    /**
     * Filter which GeographicRestrictions to update
     */
    where?: GeographicRestrictionWhereInput
    /**
     * Limit how many GeographicRestrictions to update.
     */
    limit?: number
  }

  /**
   * GeographicRestriction updateManyAndReturn
   */
  export type GeographicRestrictionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * The data used to update GeographicRestrictions.
     */
    data: XOR<GeographicRestrictionUpdateManyMutationInput, GeographicRestrictionUncheckedUpdateManyInput>
    /**
     * Filter which GeographicRestrictions to update
     */
    where?: GeographicRestrictionWhereInput
    /**
     * Limit how many GeographicRestrictions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeographicRestriction upsert
   */
  export type GeographicRestrictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * The filter to search for the GeographicRestriction to update in case it exists.
     */
    where: GeographicRestrictionWhereUniqueInput
    /**
     * In case the GeographicRestriction found by the `where` argument doesn't exist, create a new GeographicRestriction with this data.
     */
    create: XOR<GeographicRestrictionCreateInput, GeographicRestrictionUncheckedCreateInput>
    /**
     * In case the GeographicRestriction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeographicRestrictionUpdateInput, GeographicRestrictionUncheckedUpdateInput>
  }

  /**
   * GeographicRestriction delete
   */
  export type GeographicRestrictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
    /**
     * Filter which GeographicRestriction to delete.
     */
    where: GeographicRestrictionWhereUniqueInput
  }

  /**
   * GeographicRestriction deleteMany
   */
  export type GeographicRestrictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeographicRestrictions to delete
     */
    where?: GeographicRestrictionWhereInput
    /**
     * Limit how many GeographicRestrictions to delete.
     */
    limit?: number
  }

  /**
   * GeographicRestriction.user
   */
  export type GeographicRestriction$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GeographicRestriction.company
   */
  export type GeographicRestriction$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * GeographicRestriction.creator
   */
  export type GeographicRestriction$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GeographicRestriction without action
   */
  export type GeographicRestrictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeographicRestriction
     */
    select?: GeographicRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeographicRestriction
     */
    omit?: GeographicRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeographicRestrictionInclude<ExtArgs> | null
  }


  /**
   * Model PasswordPolicy
   */

  export type AggregatePasswordPolicy = {
    _count: PasswordPolicyCountAggregateOutputType | null
    _avg: PasswordPolicyAvgAggregateOutputType | null
    _sum: PasswordPolicySumAggregateOutputType | null
    _min: PasswordPolicyMinAggregateOutputType | null
    _max: PasswordPolicyMaxAggregateOutputType | null
  }

  export type PasswordPolicyAvgAggregateOutputType = {
    minLength: number | null
    expirationDays: number | null
    preventReuseCount: number | null
    requireChangeAfterDays: number | null
  }

  export type PasswordPolicySumAggregateOutputType = {
    minLength: number | null
    expirationDays: number | null
    preventReuseCount: number | null
    requireChangeAfterDays: number | null
  }

  export type PasswordPolicyMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    minLength: number | null
    requireUppercase: boolean | null
    requireLowercase: boolean | null
    requireNumbers: boolean | null
    requireSpecial: boolean | null
    expirationDays: number | null
    preventReuseCount: number | null
    requireChangeOnFirstLogin: boolean | null
    requireChangeAfterDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordPolicyMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    minLength: number | null
    requireUppercase: boolean | null
    requireLowercase: boolean | null
    requireNumbers: boolean | null
    requireSpecial: boolean | null
    expirationDays: number | null
    preventReuseCount: number | null
    requireChangeOnFirstLogin: boolean | null
    requireChangeAfterDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordPolicyCountAggregateOutputType = {
    id: number
    companyId: number
    minLength: number
    requireUppercase: number
    requireLowercase: number
    requireNumbers: number
    requireSpecial: number
    expirationDays: number
    preventReuseCount: number
    requireChangeOnFirstLogin: number
    requireChangeAfterDays: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordPolicyAvgAggregateInputType = {
    minLength?: true
    expirationDays?: true
    preventReuseCount?: true
    requireChangeAfterDays?: true
  }

  export type PasswordPolicySumAggregateInputType = {
    minLength?: true
    expirationDays?: true
    preventReuseCount?: true
    requireChangeAfterDays?: true
  }

  export type PasswordPolicyMinAggregateInputType = {
    id?: true
    companyId?: true
    minLength?: true
    requireUppercase?: true
    requireLowercase?: true
    requireNumbers?: true
    requireSpecial?: true
    expirationDays?: true
    preventReuseCount?: true
    requireChangeOnFirstLogin?: true
    requireChangeAfterDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordPolicyMaxAggregateInputType = {
    id?: true
    companyId?: true
    minLength?: true
    requireUppercase?: true
    requireLowercase?: true
    requireNumbers?: true
    requireSpecial?: true
    expirationDays?: true
    preventReuseCount?: true
    requireChangeOnFirstLogin?: true
    requireChangeAfterDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordPolicyCountAggregateInputType = {
    id?: true
    companyId?: true
    minLength?: true
    requireUppercase?: true
    requireLowercase?: true
    requireNumbers?: true
    requireSpecial?: true
    expirationDays?: true
    preventReuseCount?: true
    requireChangeOnFirstLogin?: true
    requireChangeAfterDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordPolicy to aggregate.
     */
    where?: PasswordPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordPolicies to fetch.
     */
    orderBy?: PasswordPolicyOrderByWithRelationInput | PasswordPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordPolicies
    **/
    _count?: true | PasswordPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordPolicyMaxAggregateInputType
  }

  export type GetPasswordPolicyAggregateType<T extends PasswordPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordPolicy[P]>
      : GetScalarType<T[P], AggregatePasswordPolicy[P]>
  }




  export type PasswordPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordPolicyWhereInput
    orderBy?: PasswordPolicyOrderByWithAggregationInput | PasswordPolicyOrderByWithAggregationInput[]
    by: PasswordPolicyScalarFieldEnum[] | PasswordPolicyScalarFieldEnum
    having?: PasswordPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordPolicyCountAggregateInputType | true
    _avg?: PasswordPolicyAvgAggregateInputType
    _sum?: PasswordPolicySumAggregateInputType
    _min?: PasswordPolicyMinAggregateInputType
    _max?: PasswordPolicyMaxAggregateInputType
  }

  export type PasswordPolicyGroupByOutputType = {
    id: string
    companyId: string
    minLength: number
    requireUppercase: boolean
    requireLowercase: boolean
    requireNumbers: boolean
    requireSpecial: boolean
    expirationDays: number | null
    preventReuseCount: number
    requireChangeOnFirstLogin: boolean
    requireChangeAfterDays: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PasswordPolicyCountAggregateOutputType | null
    _avg: PasswordPolicyAvgAggregateOutputType | null
    _sum: PasswordPolicySumAggregateOutputType | null
    _min: PasswordPolicyMinAggregateOutputType | null
    _max: PasswordPolicyMaxAggregateOutputType | null
  }

  type GetPasswordPolicyGroupByPayload<T extends PasswordPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PasswordPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    minLength?: boolean
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: boolean
    preventReuseCount?: boolean
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordPolicy"]>

  export type PasswordPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    minLength?: boolean
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: boolean
    preventReuseCount?: boolean
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordPolicy"]>

  export type PasswordPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    minLength?: boolean
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: boolean
    preventReuseCount?: boolean
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordPolicy"]>

  export type PasswordPolicySelectScalar = {
    id?: boolean
    companyId?: boolean
    minLength?: boolean
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: boolean
    preventReuseCount?: boolean
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "minLength" | "requireUppercase" | "requireLowercase" | "requireNumbers" | "requireSpecial" | "expirationDays" | "preventReuseCount" | "requireChangeOnFirstLogin" | "requireChangeAfterDays" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordPolicy"]>
  export type PasswordPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PasswordPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PasswordPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PasswordPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordPolicy"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      minLength: number
      requireUppercase: boolean
      requireLowercase: boolean
      requireNumbers: boolean
      requireSpecial: boolean
      expirationDays: number | null
      preventReuseCount: number
      requireChangeOnFirstLogin: boolean
      requireChangeAfterDays: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordPolicy"]>
    composites: {}
  }

  type PasswordPolicyGetPayload<S extends boolean | null | undefined | PasswordPolicyDefaultArgs> = $Result.GetResult<Prisma.$PasswordPolicyPayload, S>

  type PasswordPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordPolicyCountAggregateInputType | true
    }

  export interface PasswordPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordPolicy'], meta: { name: 'PasswordPolicy' } }
    /**
     * Find zero or one PasswordPolicy that matches the filter.
     * @param {PasswordPolicyFindUniqueArgs} args - Arguments to find a PasswordPolicy
     * @example
     * // Get one PasswordPolicy
     * const passwordPolicy = await prisma.passwordPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordPolicyFindUniqueArgs>(args: SelectSubset<T, PasswordPolicyFindUniqueArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordPolicyFindUniqueOrThrowArgs} args - Arguments to find a PasswordPolicy
     * @example
     * // Get one PasswordPolicy
     * const passwordPolicy = await prisma.passwordPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordPolicyFindFirstArgs} args - Arguments to find a PasswordPolicy
     * @example
     * // Get one PasswordPolicy
     * const passwordPolicy = await prisma.passwordPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordPolicyFindFirstArgs>(args?: SelectSubset<T, PasswordPolicyFindFirstArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordPolicyFindFirstOrThrowArgs} args - Arguments to find a PasswordPolicy
     * @example
     * // Get one PasswordPolicy
     * const passwordPolicy = await prisma.passwordPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordPolicies
     * const passwordPolicies = await prisma.passwordPolicy.findMany()
     * 
     * // Get first 10 PasswordPolicies
     * const passwordPolicies = await prisma.passwordPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordPolicyWithIdOnly = await prisma.passwordPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordPolicyFindManyArgs>(args?: SelectSubset<T, PasswordPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordPolicy.
     * @param {PasswordPolicyCreateArgs} args - Arguments to create a PasswordPolicy.
     * @example
     * // Create one PasswordPolicy
     * const PasswordPolicy = await prisma.passwordPolicy.create({
     *   data: {
     *     // ... data to create a PasswordPolicy
     *   }
     * })
     * 
     */
    create<T extends PasswordPolicyCreateArgs>(args: SelectSubset<T, PasswordPolicyCreateArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordPolicies.
     * @param {PasswordPolicyCreateManyArgs} args - Arguments to create many PasswordPolicies.
     * @example
     * // Create many PasswordPolicies
     * const passwordPolicy = await prisma.passwordPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordPolicyCreateManyArgs>(args?: SelectSubset<T, PasswordPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordPolicies and returns the data saved in the database.
     * @param {PasswordPolicyCreateManyAndReturnArgs} args - Arguments to create many PasswordPolicies.
     * @example
     * // Create many PasswordPolicies
     * const passwordPolicy = await prisma.passwordPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordPolicies and only return the `id`
     * const passwordPolicyWithIdOnly = await prisma.passwordPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordPolicy.
     * @param {PasswordPolicyDeleteArgs} args - Arguments to delete one PasswordPolicy.
     * @example
     * // Delete one PasswordPolicy
     * const PasswordPolicy = await prisma.passwordPolicy.delete({
     *   where: {
     *     // ... filter to delete one PasswordPolicy
     *   }
     * })
     * 
     */
    delete<T extends PasswordPolicyDeleteArgs>(args: SelectSubset<T, PasswordPolicyDeleteArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordPolicy.
     * @param {PasswordPolicyUpdateArgs} args - Arguments to update one PasswordPolicy.
     * @example
     * // Update one PasswordPolicy
     * const passwordPolicy = await prisma.passwordPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordPolicyUpdateArgs>(args: SelectSubset<T, PasswordPolicyUpdateArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordPolicies.
     * @param {PasswordPolicyDeleteManyArgs} args - Arguments to filter PasswordPolicies to delete.
     * @example
     * // Delete a few PasswordPolicies
     * const { count } = await prisma.passwordPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordPolicyDeleteManyArgs>(args?: SelectSubset<T, PasswordPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordPolicies
     * const passwordPolicy = await prisma.passwordPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordPolicyUpdateManyArgs>(args: SelectSubset<T, PasswordPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordPolicies and returns the data updated in the database.
     * @param {PasswordPolicyUpdateManyAndReturnArgs} args - Arguments to update many PasswordPolicies.
     * @example
     * // Update many PasswordPolicies
     * const passwordPolicy = await prisma.passwordPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordPolicies and only return the `id`
     * const passwordPolicyWithIdOnly = await prisma.passwordPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordPolicy.
     * @param {PasswordPolicyUpsertArgs} args - Arguments to update or create a PasswordPolicy.
     * @example
     * // Update or create a PasswordPolicy
     * const passwordPolicy = await prisma.passwordPolicy.upsert({
     *   create: {
     *     // ... data to create a PasswordPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PasswordPolicyUpsertArgs>(args: SelectSubset<T, PasswordPolicyUpsertArgs<ExtArgs>>): Prisma__PasswordPolicyClient<$Result.GetResult<Prisma.$PasswordPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordPolicyCountArgs} args - Arguments to filter PasswordPolicies to count.
     * @example
     * // Count the number of PasswordPolicies
     * const count = await prisma.passwordPolicy.count({
     *   where: {
     *     // ... the filter for the PasswordPolicies we want to count
     *   }
     * })
    **/
    count<T extends PasswordPolicyCountArgs>(
      args?: Subset<T, PasswordPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordPolicyAggregateArgs>(args: Subset<T, PasswordPolicyAggregateArgs>): Prisma.PrismaPromise<GetPasswordPolicyAggregateType<T>>

    /**
     * Group by PasswordPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PasswordPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordPolicy model
   */
  readonly fields: PasswordPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordPolicy model
   */
  interface PasswordPolicyFieldRefs {
    readonly id: FieldRef<"PasswordPolicy", 'String'>
    readonly companyId: FieldRef<"PasswordPolicy", 'String'>
    readonly minLength: FieldRef<"PasswordPolicy", 'Int'>
    readonly requireUppercase: FieldRef<"PasswordPolicy", 'Boolean'>
    readonly requireLowercase: FieldRef<"PasswordPolicy", 'Boolean'>
    readonly requireNumbers: FieldRef<"PasswordPolicy", 'Boolean'>
    readonly requireSpecial: FieldRef<"PasswordPolicy", 'Boolean'>
    readonly expirationDays: FieldRef<"PasswordPolicy", 'Int'>
    readonly preventReuseCount: FieldRef<"PasswordPolicy", 'Int'>
    readonly requireChangeOnFirstLogin: FieldRef<"PasswordPolicy", 'Boolean'>
    readonly requireChangeAfterDays: FieldRef<"PasswordPolicy", 'Int'>
    readonly isActive: FieldRef<"PasswordPolicy", 'Boolean'>
    readonly createdAt: FieldRef<"PasswordPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordPolicy findUnique
   */
  export type PasswordPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordPolicy to fetch.
     */
    where: PasswordPolicyWhereUniqueInput
  }

  /**
   * PasswordPolicy findUniqueOrThrow
   */
  export type PasswordPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordPolicy to fetch.
     */
    where: PasswordPolicyWhereUniqueInput
  }

  /**
   * PasswordPolicy findFirst
   */
  export type PasswordPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordPolicy to fetch.
     */
    where?: PasswordPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordPolicies to fetch.
     */
    orderBy?: PasswordPolicyOrderByWithRelationInput | PasswordPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordPolicies.
     */
    cursor?: PasswordPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordPolicies.
     */
    distinct?: PasswordPolicyScalarFieldEnum | PasswordPolicyScalarFieldEnum[]
  }

  /**
   * PasswordPolicy findFirstOrThrow
   */
  export type PasswordPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordPolicy to fetch.
     */
    where?: PasswordPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordPolicies to fetch.
     */
    orderBy?: PasswordPolicyOrderByWithRelationInput | PasswordPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordPolicies.
     */
    cursor?: PasswordPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordPolicies.
     */
    distinct?: PasswordPolicyScalarFieldEnum | PasswordPolicyScalarFieldEnum[]
  }

  /**
   * PasswordPolicy findMany
   */
  export type PasswordPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordPolicies to fetch.
     */
    where?: PasswordPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordPolicies to fetch.
     */
    orderBy?: PasswordPolicyOrderByWithRelationInput | PasswordPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordPolicies.
     */
    cursor?: PasswordPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordPolicies.
     */
    skip?: number
    distinct?: PasswordPolicyScalarFieldEnum | PasswordPolicyScalarFieldEnum[]
  }

  /**
   * PasswordPolicy create
   */
  export type PasswordPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordPolicy.
     */
    data: XOR<PasswordPolicyCreateInput, PasswordPolicyUncheckedCreateInput>
  }

  /**
   * PasswordPolicy createMany
   */
  export type PasswordPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordPolicies.
     */
    data: PasswordPolicyCreateManyInput | PasswordPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordPolicy createManyAndReturn
   */
  export type PasswordPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordPolicies.
     */
    data: PasswordPolicyCreateManyInput | PasswordPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordPolicy update
   */
  export type PasswordPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordPolicy.
     */
    data: XOR<PasswordPolicyUpdateInput, PasswordPolicyUncheckedUpdateInput>
    /**
     * Choose, which PasswordPolicy to update.
     */
    where: PasswordPolicyWhereUniqueInput
  }

  /**
   * PasswordPolicy updateMany
   */
  export type PasswordPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordPolicies.
     */
    data: XOR<PasswordPolicyUpdateManyMutationInput, PasswordPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PasswordPolicies to update
     */
    where?: PasswordPolicyWhereInput
    /**
     * Limit how many PasswordPolicies to update.
     */
    limit?: number
  }

  /**
   * PasswordPolicy updateManyAndReturn
   */
  export type PasswordPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * The data used to update PasswordPolicies.
     */
    data: XOR<PasswordPolicyUpdateManyMutationInput, PasswordPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PasswordPolicies to update
     */
    where?: PasswordPolicyWhereInput
    /**
     * Limit how many PasswordPolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordPolicy upsert
   */
  export type PasswordPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordPolicy to update in case it exists.
     */
    where: PasswordPolicyWhereUniqueInput
    /**
     * In case the PasswordPolicy found by the `where` argument doesn't exist, create a new PasswordPolicy with this data.
     */
    create: XOR<PasswordPolicyCreateInput, PasswordPolicyUncheckedCreateInput>
    /**
     * In case the PasswordPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordPolicyUpdateInput, PasswordPolicyUncheckedUpdateInput>
  }

  /**
   * PasswordPolicy delete
   */
  export type PasswordPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
    /**
     * Filter which PasswordPolicy to delete.
     */
    where: PasswordPolicyWhereUniqueInput
  }

  /**
   * PasswordPolicy deleteMany
   */
  export type PasswordPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordPolicies to delete
     */
    where?: PasswordPolicyWhereInput
    /**
     * Limit how many PasswordPolicies to delete.
     */
    limit?: number
  }

  /**
   * PasswordPolicy without action
   */
  export type PasswordPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordPolicy
     */
    select?: PasswordPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordPolicy
     */
    omit?: PasswordPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordPolicyInclude<ExtArgs> | null
  }


  /**
   * Model DataRetentionPolicy
   */

  export type AggregateDataRetentionPolicy = {
    _count: DataRetentionPolicyCountAggregateOutputType | null
    _avg: DataRetentionPolicyAvgAggregateOutputType | null
    _sum: DataRetentionPolicySumAggregateOutputType | null
    _min: DataRetentionPolicyMinAggregateOutputType | null
    _max: DataRetentionPolicyMaxAggregateOutputType | null
  }

  export type DataRetentionPolicyAvgAggregateOutputType = {
    auditLogRetentionDays: number | null
    passwordHistoryRetentionDays: number | null
    sessionRetentionDays: number | null
    deletedDataRetentionDays: number | null
  }

  export type DataRetentionPolicySumAggregateOutputType = {
    auditLogRetentionDays: number | null
    passwordHistoryRetentionDays: number | null
    sessionRetentionDays: number | null
    deletedDataRetentionDays: number | null
  }

  export type DataRetentionPolicyMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    auditLogRetentionDays: number | null
    passwordHistoryRetentionDays: number | null
    sessionRetentionDays: number | null
    deletedDataRetentionDays: number | null
    autoDeleteEnabled: boolean | null
    lastCleanupAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataRetentionPolicyMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    auditLogRetentionDays: number | null
    passwordHistoryRetentionDays: number | null
    sessionRetentionDays: number | null
    deletedDataRetentionDays: number | null
    autoDeleteEnabled: boolean | null
    lastCleanupAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataRetentionPolicyCountAggregateOutputType = {
    id: number
    companyId: number
    auditLogRetentionDays: number
    passwordHistoryRetentionDays: number
    sessionRetentionDays: number
    deletedDataRetentionDays: number
    autoDeleteEnabled: number
    lastCleanupAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataRetentionPolicyAvgAggregateInputType = {
    auditLogRetentionDays?: true
    passwordHistoryRetentionDays?: true
    sessionRetentionDays?: true
    deletedDataRetentionDays?: true
  }

  export type DataRetentionPolicySumAggregateInputType = {
    auditLogRetentionDays?: true
    passwordHistoryRetentionDays?: true
    sessionRetentionDays?: true
    deletedDataRetentionDays?: true
  }

  export type DataRetentionPolicyMinAggregateInputType = {
    id?: true
    companyId?: true
    auditLogRetentionDays?: true
    passwordHistoryRetentionDays?: true
    sessionRetentionDays?: true
    deletedDataRetentionDays?: true
    autoDeleteEnabled?: true
    lastCleanupAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataRetentionPolicyMaxAggregateInputType = {
    id?: true
    companyId?: true
    auditLogRetentionDays?: true
    passwordHistoryRetentionDays?: true
    sessionRetentionDays?: true
    deletedDataRetentionDays?: true
    autoDeleteEnabled?: true
    lastCleanupAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataRetentionPolicyCountAggregateInputType = {
    id?: true
    companyId?: true
    auditLogRetentionDays?: true
    passwordHistoryRetentionDays?: true
    sessionRetentionDays?: true
    deletedDataRetentionDays?: true
    autoDeleteEnabled?: true
    lastCleanupAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataRetentionPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionPolicy to aggregate.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRetentionPolicies
    **/
    _count?: true | DataRetentionPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRetentionPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRetentionPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRetentionPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRetentionPolicyMaxAggregateInputType
  }

  export type GetDataRetentionPolicyAggregateType<T extends DataRetentionPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRetentionPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRetentionPolicy[P]>
      : GetScalarType<T[P], AggregateDataRetentionPolicy[P]>
  }




  export type DataRetentionPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRetentionPolicyWhereInput
    orderBy?: DataRetentionPolicyOrderByWithAggregationInput | DataRetentionPolicyOrderByWithAggregationInput[]
    by: DataRetentionPolicyScalarFieldEnum[] | DataRetentionPolicyScalarFieldEnum
    having?: DataRetentionPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRetentionPolicyCountAggregateInputType | true
    _avg?: DataRetentionPolicyAvgAggregateInputType
    _sum?: DataRetentionPolicySumAggregateInputType
    _min?: DataRetentionPolicyMinAggregateInputType
    _max?: DataRetentionPolicyMaxAggregateInputType
  }

  export type DataRetentionPolicyGroupByOutputType = {
    id: string
    companyId: string
    auditLogRetentionDays: number | null
    passwordHistoryRetentionDays: number | null
    sessionRetentionDays: number | null
    deletedDataRetentionDays: number | null
    autoDeleteEnabled: boolean
    lastCleanupAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DataRetentionPolicyCountAggregateOutputType | null
    _avg: DataRetentionPolicyAvgAggregateOutputType | null
    _sum: DataRetentionPolicySumAggregateOutputType | null
    _min: DataRetentionPolicyMinAggregateOutputType | null
    _max: DataRetentionPolicyMaxAggregateOutputType | null
  }

  type GetDataRetentionPolicyGroupByPayload<T extends DataRetentionPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRetentionPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRetentionPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRetentionPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], DataRetentionPolicyGroupByOutputType[P]>
        }
      >
    >


  export type DataRetentionPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    auditLogRetentionDays?: boolean
    passwordHistoryRetentionDays?: boolean
    sessionRetentionDays?: boolean
    deletedDataRetentionDays?: boolean
    autoDeleteEnabled?: boolean
    lastCleanupAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRetentionPolicy"]>

  export type DataRetentionPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    auditLogRetentionDays?: boolean
    passwordHistoryRetentionDays?: boolean
    sessionRetentionDays?: boolean
    deletedDataRetentionDays?: boolean
    autoDeleteEnabled?: boolean
    lastCleanupAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRetentionPolicy"]>

  export type DataRetentionPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    auditLogRetentionDays?: boolean
    passwordHistoryRetentionDays?: boolean
    sessionRetentionDays?: boolean
    deletedDataRetentionDays?: boolean
    autoDeleteEnabled?: boolean
    lastCleanupAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRetentionPolicy"]>

  export type DataRetentionPolicySelectScalar = {
    id?: boolean
    companyId?: boolean
    auditLogRetentionDays?: boolean
    passwordHistoryRetentionDays?: boolean
    sessionRetentionDays?: boolean
    deletedDataRetentionDays?: boolean
    autoDeleteEnabled?: boolean
    lastCleanupAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataRetentionPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "auditLogRetentionDays" | "passwordHistoryRetentionDays" | "sessionRetentionDays" | "deletedDataRetentionDays" | "autoDeleteEnabled" | "lastCleanupAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["dataRetentionPolicy"]>
  export type DataRetentionPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DataRetentionPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DataRetentionPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DataRetentionPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRetentionPolicy"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      auditLogRetentionDays: number | null
      passwordHistoryRetentionDays: number | null
      sessionRetentionDays: number | null
      deletedDataRetentionDays: number | null
      autoDeleteEnabled: boolean
      lastCleanupAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataRetentionPolicy"]>
    composites: {}
  }

  type DataRetentionPolicyGetPayload<S extends boolean | null | undefined | DataRetentionPolicyDefaultArgs> = $Result.GetResult<Prisma.$DataRetentionPolicyPayload, S>

  type DataRetentionPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataRetentionPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataRetentionPolicyCountAggregateInputType | true
    }

  export interface DataRetentionPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRetentionPolicy'], meta: { name: 'DataRetentionPolicy' } }
    /**
     * Find zero or one DataRetentionPolicy that matches the filter.
     * @param {DataRetentionPolicyFindUniqueArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRetentionPolicyFindUniqueArgs>(args: SelectSubset<T, DataRetentionPolicyFindUniqueArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataRetentionPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataRetentionPolicyFindUniqueOrThrowArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRetentionPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRetentionPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindFirstArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRetentionPolicyFindFirstArgs>(args?: SelectSubset<T, DataRetentionPolicyFindFirstArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRetentionPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindFirstOrThrowArgs} args - Arguments to find a DataRetentionPolicy
     * @example
     * // Get one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRetentionPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRetentionPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRetentionPolicies
     * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany()
     * 
     * // Get first 10 DataRetentionPolicies
     * const dataRetentionPolicies = await prisma.dataRetentionPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRetentionPolicyWithIdOnly = await prisma.dataRetentionPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataRetentionPolicyFindManyArgs>(args?: SelectSubset<T, DataRetentionPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataRetentionPolicy.
     * @param {DataRetentionPolicyCreateArgs} args - Arguments to create a DataRetentionPolicy.
     * @example
     * // Create one DataRetentionPolicy
     * const DataRetentionPolicy = await prisma.dataRetentionPolicy.create({
     *   data: {
     *     // ... data to create a DataRetentionPolicy
     *   }
     * })
     * 
     */
    create<T extends DataRetentionPolicyCreateArgs>(args: SelectSubset<T, DataRetentionPolicyCreateArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataRetentionPolicies.
     * @param {DataRetentionPolicyCreateManyArgs} args - Arguments to create many DataRetentionPolicies.
     * @example
     * // Create many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRetentionPolicyCreateManyArgs>(args?: SelectSubset<T, DataRetentionPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataRetentionPolicies and returns the data saved in the database.
     * @param {DataRetentionPolicyCreateManyAndReturnArgs} args - Arguments to create many DataRetentionPolicies.
     * @example
     * // Create many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataRetentionPolicies and only return the `id`
     * const dataRetentionPolicyWithIdOnly = await prisma.dataRetentionPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataRetentionPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataRetentionPolicy.
     * @param {DataRetentionPolicyDeleteArgs} args - Arguments to delete one DataRetentionPolicy.
     * @example
     * // Delete one DataRetentionPolicy
     * const DataRetentionPolicy = await prisma.dataRetentionPolicy.delete({
     *   where: {
     *     // ... filter to delete one DataRetentionPolicy
     *   }
     * })
     * 
     */
    delete<T extends DataRetentionPolicyDeleteArgs>(args: SelectSubset<T, DataRetentionPolicyDeleteArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataRetentionPolicy.
     * @param {DataRetentionPolicyUpdateArgs} args - Arguments to update one DataRetentionPolicy.
     * @example
     * // Update one DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRetentionPolicyUpdateArgs>(args: SelectSubset<T, DataRetentionPolicyUpdateArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataRetentionPolicies.
     * @param {DataRetentionPolicyDeleteManyArgs} args - Arguments to filter DataRetentionPolicies to delete.
     * @example
     * // Delete a few DataRetentionPolicies
     * const { count } = await prisma.dataRetentionPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRetentionPolicyDeleteManyArgs>(args?: SelectSubset<T, DataRetentionPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRetentionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRetentionPolicyUpdateManyArgs>(args: SelectSubset<T, DataRetentionPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRetentionPolicies and returns the data updated in the database.
     * @param {DataRetentionPolicyUpdateManyAndReturnArgs} args - Arguments to update many DataRetentionPolicies.
     * @example
     * // Update many DataRetentionPolicies
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataRetentionPolicies and only return the `id`
     * const dataRetentionPolicyWithIdOnly = await prisma.dataRetentionPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataRetentionPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, DataRetentionPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataRetentionPolicy.
     * @param {DataRetentionPolicyUpsertArgs} args - Arguments to update or create a DataRetentionPolicy.
     * @example
     * // Update or create a DataRetentionPolicy
     * const dataRetentionPolicy = await prisma.dataRetentionPolicy.upsert({
     *   create: {
     *     // ... data to create a DataRetentionPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRetentionPolicy we want to update
     *   }
     * })
     */
    upsert<T extends DataRetentionPolicyUpsertArgs>(args: SelectSubset<T, DataRetentionPolicyUpsertArgs<ExtArgs>>): Prisma__DataRetentionPolicyClient<$Result.GetResult<Prisma.$DataRetentionPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataRetentionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyCountArgs} args - Arguments to filter DataRetentionPolicies to count.
     * @example
     * // Count the number of DataRetentionPolicies
     * const count = await prisma.dataRetentionPolicy.count({
     *   where: {
     *     // ... the filter for the DataRetentionPolicies we want to count
     *   }
     * })
    **/
    count<T extends DataRetentionPolicyCountArgs>(
      args?: Subset<T, DataRetentionPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRetentionPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRetentionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRetentionPolicyAggregateArgs>(args: Subset<T, DataRetentionPolicyAggregateArgs>): Prisma.PrismaPromise<GetDataRetentionPolicyAggregateType<T>>

    /**
     * Group by DataRetentionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRetentionPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRetentionPolicyGroupByArgs['orderBy'] }
        : { orderBy?: DataRetentionPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRetentionPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRetentionPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRetentionPolicy model
   */
  readonly fields: DataRetentionPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRetentionPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRetentionPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRetentionPolicy model
   */
  interface DataRetentionPolicyFieldRefs {
    readonly id: FieldRef<"DataRetentionPolicy", 'String'>
    readonly companyId: FieldRef<"DataRetentionPolicy", 'String'>
    readonly auditLogRetentionDays: FieldRef<"DataRetentionPolicy", 'Int'>
    readonly passwordHistoryRetentionDays: FieldRef<"DataRetentionPolicy", 'Int'>
    readonly sessionRetentionDays: FieldRef<"DataRetentionPolicy", 'Int'>
    readonly deletedDataRetentionDays: FieldRef<"DataRetentionPolicy", 'Int'>
    readonly autoDeleteEnabled: FieldRef<"DataRetentionPolicy", 'Boolean'>
    readonly lastCleanupAt: FieldRef<"DataRetentionPolicy", 'DateTime'>
    readonly isActive: FieldRef<"DataRetentionPolicy", 'Boolean'>
    readonly createdAt: FieldRef<"DataRetentionPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"DataRetentionPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataRetentionPolicy findUnique
   */
  export type DataRetentionPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy findUniqueOrThrow
   */
  export type DataRetentionPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy findFirst
   */
  export type DataRetentionPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionPolicies.
     */
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy findFirstOrThrow
   */
  export type DataRetentionPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicy to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionPolicies.
     */
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy findMany
   */
  export type DataRetentionPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which DataRetentionPolicies to fetch.
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionPolicies to fetch.
     */
    orderBy?: DataRetentionPolicyOrderByWithRelationInput | DataRetentionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRetentionPolicies.
     */
    cursor?: DataRetentionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionPolicies.
     */
    skip?: number
    distinct?: DataRetentionPolicyScalarFieldEnum | DataRetentionPolicyScalarFieldEnum[]
  }

  /**
   * DataRetentionPolicy create
   */
  export type DataRetentionPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a DataRetentionPolicy.
     */
    data: XOR<DataRetentionPolicyCreateInput, DataRetentionPolicyUncheckedCreateInput>
  }

  /**
   * DataRetentionPolicy createMany
   */
  export type DataRetentionPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRetentionPolicies.
     */
    data: DataRetentionPolicyCreateManyInput | DataRetentionPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRetentionPolicy createManyAndReturn
   */
  export type DataRetentionPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many DataRetentionPolicies.
     */
    data: DataRetentionPolicyCreateManyInput | DataRetentionPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataRetentionPolicy update
   */
  export type DataRetentionPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a DataRetentionPolicy.
     */
    data: XOR<DataRetentionPolicyUpdateInput, DataRetentionPolicyUncheckedUpdateInput>
    /**
     * Choose, which DataRetentionPolicy to update.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy updateMany
   */
  export type DataRetentionPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRetentionPolicies.
     */
    data: XOR<DataRetentionPolicyUpdateManyMutationInput, DataRetentionPolicyUncheckedUpdateManyInput>
    /**
     * Filter which DataRetentionPolicies to update
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * Limit how many DataRetentionPolicies to update.
     */
    limit?: number
  }

  /**
   * DataRetentionPolicy updateManyAndReturn
   */
  export type DataRetentionPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * The data used to update DataRetentionPolicies.
     */
    data: XOR<DataRetentionPolicyUpdateManyMutationInput, DataRetentionPolicyUncheckedUpdateManyInput>
    /**
     * Filter which DataRetentionPolicies to update
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * Limit how many DataRetentionPolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataRetentionPolicy upsert
   */
  export type DataRetentionPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the DataRetentionPolicy to update in case it exists.
     */
    where: DataRetentionPolicyWhereUniqueInput
    /**
     * In case the DataRetentionPolicy found by the `where` argument doesn't exist, create a new DataRetentionPolicy with this data.
     */
    create: XOR<DataRetentionPolicyCreateInput, DataRetentionPolicyUncheckedCreateInput>
    /**
     * In case the DataRetentionPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRetentionPolicyUpdateInput, DataRetentionPolicyUncheckedUpdateInput>
  }

  /**
   * DataRetentionPolicy delete
   */
  export type DataRetentionPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
    /**
     * Filter which DataRetentionPolicy to delete.
     */
    where: DataRetentionPolicyWhereUniqueInput
  }

  /**
   * DataRetentionPolicy deleteMany
   */
  export type DataRetentionPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionPolicies to delete
     */
    where?: DataRetentionPolicyWhereInput
    /**
     * Limit how many DataRetentionPolicies to delete.
     */
    limit?: number
  }

  /**
   * DataRetentionPolicy without action
   */
  export type DataRetentionPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionPolicy
     */
    select?: DataRetentionPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRetentionPolicy
     */
    omit?: DataRetentionPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRetentionPolicyInclude<ExtArgs> | null
  }


  /**
   * Model DataExport
   */

  export type AggregateDataExport = {
    _count: DataExportCountAggregateOutputType | null
    _avg: DataExportAvgAggregateOutputType | null
    _sum: DataExportSumAggregateOutputType | null
    _min: DataExportMinAggregateOutputType | null
    _max: DataExportMaxAggregateOutputType | null
  }

  export type DataExportAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DataExportSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DataExportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    exportType: string | null
    status: string | null
    filePath: string | null
    fileSize: number | null
    expiresAt: Date | null
    requestedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
  }

  export type DataExportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    exportType: string | null
    status: string | null
    filePath: string | null
    fileSize: number | null
    expiresAt: Date | null
    requestedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
  }

  export type DataExportCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    exportType: number
    status: number
    filePath: number
    fileSize: number
    expiresAt: number
    requestedAt: number
    completedAt: number
    errorMessage: number
    _all: number
  }


  export type DataExportAvgAggregateInputType = {
    fileSize?: true
  }

  export type DataExportSumAggregateInputType = {
    fileSize?: true
  }

  export type DataExportMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    exportType?: true
    status?: true
    filePath?: true
    fileSize?: true
    expiresAt?: true
    requestedAt?: true
    completedAt?: true
    errorMessage?: true
  }

  export type DataExportMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    exportType?: true
    status?: true
    filePath?: true
    fileSize?: true
    expiresAt?: true
    requestedAt?: true
    completedAt?: true
    errorMessage?: true
  }

  export type DataExportCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    exportType?: true
    status?: true
    filePath?: true
    fileSize?: true
    expiresAt?: true
    requestedAt?: true
    completedAt?: true
    errorMessage?: true
    _all?: true
  }

  export type DataExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataExport to aggregate.
     */
    where?: DataExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExports to fetch.
     */
    orderBy?: DataExportOrderByWithRelationInput | DataExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataExports
    **/
    _count?: true | DataExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataExportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataExportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataExportMaxAggregateInputType
  }

  export type GetDataExportAggregateType<T extends DataExportAggregateArgs> = {
        [P in keyof T & keyof AggregateDataExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataExport[P]>
      : GetScalarType<T[P], AggregateDataExport[P]>
  }




  export type DataExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataExportWhereInput
    orderBy?: DataExportOrderByWithAggregationInput | DataExportOrderByWithAggregationInput[]
    by: DataExportScalarFieldEnum[] | DataExportScalarFieldEnum
    having?: DataExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataExportCountAggregateInputType | true
    _avg?: DataExportAvgAggregateInputType
    _sum?: DataExportSumAggregateInputType
    _min?: DataExportMinAggregateInputType
    _max?: DataExportMaxAggregateInputType
  }

  export type DataExportGroupByOutputType = {
    id: string
    userId: string
    companyId: string | null
    exportType: string
    status: string
    filePath: string | null
    fileSize: number | null
    expiresAt: Date | null
    requestedAt: Date
    completedAt: Date | null
    errorMessage: string | null
    _count: DataExportCountAggregateOutputType | null
    _avg: DataExportAvgAggregateOutputType | null
    _sum: DataExportSumAggregateOutputType | null
    _min: DataExportMinAggregateOutputType | null
    _max: DataExportMaxAggregateOutputType | null
  }

  type GetDataExportGroupByPayload<T extends DataExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataExportGroupByOutputType[P]>
            : GetScalarType<T[P], DataExportGroupByOutputType[P]>
        }
      >
    >


  export type DataExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    exportType?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataExport$companyArgs<ExtArgs>
  }, ExtArgs["result"]["dataExport"]>

  export type DataExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    exportType?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataExport$companyArgs<ExtArgs>
  }, ExtArgs["result"]["dataExport"]>

  export type DataExportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    exportType?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataExport$companyArgs<ExtArgs>
  }, ExtArgs["result"]["dataExport"]>

  export type DataExportSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    exportType?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    expiresAt?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
  }

  export type DataExportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "exportType" | "status" | "filePath" | "fileSize" | "expiresAt" | "requestedAt" | "completedAt" | "errorMessage", ExtArgs["result"]["dataExport"]>
  export type DataExportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataExport$companyArgs<ExtArgs>
  }
  export type DataExportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataExport$companyArgs<ExtArgs>
  }
  export type DataExportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataExport$companyArgs<ExtArgs>
  }

  export type $DataExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataExport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string | null
      exportType: string
      status: string
      filePath: string | null
      fileSize: number | null
      expiresAt: Date | null
      requestedAt: Date
      completedAt: Date | null
      errorMessage: string | null
    }, ExtArgs["result"]["dataExport"]>
    composites: {}
  }

  type DataExportGetPayload<S extends boolean | null | undefined | DataExportDefaultArgs> = $Result.GetResult<Prisma.$DataExportPayload, S>

  type DataExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataExportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataExportCountAggregateInputType | true
    }

  export interface DataExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataExport'], meta: { name: 'DataExport' } }
    /**
     * Find zero or one DataExport that matches the filter.
     * @param {DataExportFindUniqueArgs} args - Arguments to find a DataExport
     * @example
     * // Get one DataExport
     * const dataExport = await prisma.dataExport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataExportFindUniqueArgs>(args: SelectSubset<T, DataExportFindUniqueArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataExport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataExportFindUniqueOrThrowArgs} args - Arguments to find a DataExport
     * @example
     * // Get one DataExport
     * const dataExport = await prisma.dataExport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataExportFindUniqueOrThrowArgs>(args: SelectSubset<T, DataExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataExport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportFindFirstArgs} args - Arguments to find a DataExport
     * @example
     * // Get one DataExport
     * const dataExport = await prisma.dataExport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataExportFindFirstArgs>(args?: SelectSubset<T, DataExportFindFirstArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataExport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportFindFirstOrThrowArgs} args - Arguments to find a DataExport
     * @example
     * // Get one DataExport
     * const dataExport = await prisma.dataExport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataExportFindFirstOrThrowArgs>(args?: SelectSubset<T, DataExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataExports
     * const dataExports = await prisma.dataExport.findMany()
     * 
     * // Get first 10 DataExports
     * const dataExports = await prisma.dataExport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataExportWithIdOnly = await prisma.dataExport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataExportFindManyArgs>(args?: SelectSubset<T, DataExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataExport.
     * @param {DataExportCreateArgs} args - Arguments to create a DataExport.
     * @example
     * // Create one DataExport
     * const DataExport = await prisma.dataExport.create({
     *   data: {
     *     // ... data to create a DataExport
     *   }
     * })
     * 
     */
    create<T extends DataExportCreateArgs>(args: SelectSubset<T, DataExportCreateArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataExports.
     * @param {DataExportCreateManyArgs} args - Arguments to create many DataExports.
     * @example
     * // Create many DataExports
     * const dataExport = await prisma.dataExport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataExportCreateManyArgs>(args?: SelectSubset<T, DataExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataExports and returns the data saved in the database.
     * @param {DataExportCreateManyAndReturnArgs} args - Arguments to create many DataExports.
     * @example
     * // Create many DataExports
     * const dataExport = await prisma.dataExport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataExports and only return the `id`
     * const dataExportWithIdOnly = await prisma.dataExport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataExportCreateManyAndReturnArgs>(args?: SelectSubset<T, DataExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataExport.
     * @param {DataExportDeleteArgs} args - Arguments to delete one DataExport.
     * @example
     * // Delete one DataExport
     * const DataExport = await prisma.dataExport.delete({
     *   where: {
     *     // ... filter to delete one DataExport
     *   }
     * })
     * 
     */
    delete<T extends DataExportDeleteArgs>(args: SelectSubset<T, DataExportDeleteArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataExport.
     * @param {DataExportUpdateArgs} args - Arguments to update one DataExport.
     * @example
     * // Update one DataExport
     * const dataExport = await prisma.dataExport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataExportUpdateArgs>(args: SelectSubset<T, DataExportUpdateArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataExports.
     * @param {DataExportDeleteManyArgs} args - Arguments to filter DataExports to delete.
     * @example
     * // Delete a few DataExports
     * const { count } = await prisma.dataExport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataExportDeleteManyArgs>(args?: SelectSubset<T, DataExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataExports
     * const dataExport = await prisma.dataExport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataExportUpdateManyArgs>(args: SelectSubset<T, DataExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataExports and returns the data updated in the database.
     * @param {DataExportUpdateManyAndReturnArgs} args - Arguments to update many DataExports.
     * @example
     * // Update many DataExports
     * const dataExport = await prisma.dataExport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataExports and only return the `id`
     * const dataExportWithIdOnly = await prisma.dataExport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataExportUpdateManyAndReturnArgs>(args: SelectSubset<T, DataExportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataExport.
     * @param {DataExportUpsertArgs} args - Arguments to update or create a DataExport.
     * @example
     * // Update or create a DataExport
     * const dataExport = await prisma.dataExport.upsert({
     *   create: {
     *     // ... data to create a DataExport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataExport we want to update
     *   }
     * })
     */
    upsert<T extends DataExportUpsertArgs>(args: SelectSubset<T, DataExportUpsertArgs<ExtArgs>>): Prisma__DataExportClient<$Result.GetResult<Prisma.$DataExportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportCountArgs} args - Arguments to filter DataExports to count.
     * @example
     * // Count the number of DataExports
     * const count = await prisma.dataExport.count({
     *   where: {
     *     // ... the filter for the DataExports we want to count
     *   }
     * })
    **/
    count<T extends DataExportCountArgs>(
      args?: Subset<T, DataExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataExportAggregateArgs>(args: Subset<T, DataExportAggregateArgs>): Prisma.PrismaPromise<GetDataExportAggregateType<T>>

    /**
     * Group by DataExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataExportGroupByArgs['orderBy'] }
        : { orderBy?: DataExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataExport model
   */
  readonly fields: DataExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataExport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends DataExport$companyArgs<ExtArgs> = {}>(args?: Subset<T, DataExport$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataExport model
   */
  interface DataExportFieldRefs {
    readonly id: FieldRef<"DataExport", 'String'>
    readonly userId: FieldRef<"DataExport", 'String'>
    readonly companyId: FieldRef<"DataExport", 'String'>
    readonly exportType: FieldRef<"DataExport", 'String'>
    readonly status: FieldRef<"DataExport", 'String'>
    readonly filePath: FieldRef<"DataExport", 'String'>
    readonly fileSize: FieldRef<"DataExport", 'Int'>
    readonly expiresAt: FieldRef<"DataExport", 'DateTime'>
    readonly requestedAt: FieldRef<"DataExport", 'DateTime'>
    readonly completedAt: FieldRef<"DataExport", 'DateTime'>
    readonly errorMessage: FieldRef<"DataExport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DataExport findUnique
   */
  export type DataExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * Filter, which DataExport to fetch.
     */
    where: DataExportWhereUniqueInput
  }

  /**
   * DataExport findUniqueOrThrow
   */
  export type DataExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * Filter, which DataExport to fetch.
     */
    where: DataExportWhereUniqueInput
  }

  /**
   * DataExport findFirst
   */
  export type DataExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * Filter, which DataExport to fetch.
     */
    where?: DataExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExports to fetch.
     */
    orderBy?: DataExportOrderByWithRelationInput | DataExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataExports.
     */
    cursor?: DataExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataExports.
     */
    distinct?: DataExportScalarFieldEnum | DataExportScalarFieldEnum[]
  }

  /**
   * DataExport findFirstOrThrow
   */
  export type DataExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * Filter, which DataExport to fetch.
     */
    where?: DataExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExports to fetch.
     */
    orderBy?: DataExportOrderByWithRelationInput | DataExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataExports.
     */
    cursor?: DataExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataExports.
     */
    distinct?: DataExportScalarFieldEnum | DataExportScalarFieldEnum[]
  }

  /**
   * DataExport findMany
   */
  export type DataExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * Filter, which DataExports to fetch.
     */
    where?: DataExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExports to fetch.
     */
    orderBy?: DataExportOrderByWithRelationInput | DataExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataExports.
     */
    cursor?: DataExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExports.
     */
    skip?: number
    distinct?: DataExportScalarFieldEnum | DataExportScalarFieldEnum[]
  }

  /**
   * DataExport create
   */
  export type DataExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * The data needed to create a DataExport.
     */
    data: XOR<DataExportCreateInput, DataExportUncheckedCreateInput>
  }

  /**
   * DataExport createMany
   */
  export type DataExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataExports.
     */
    data: DataExportCreateManyInput | DataExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataExport createManyAndReturn
   */
  export type DataExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * The data used to create many DataExports.
     */
    data: DataExportCreateManyInput | DataExportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataExport update
   */
  export type DataExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * The data needed to update a DataExport.
     */
    data: XOR<DataExportUpdateInput, DataExportUncheckedUpdateInput>
    /**
     * Choose, which DataExport to update.
     */
    where: DataExportWhereUniqueInput
  }

  /**
   * DataExport updateMany
   */
  export type DataExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataExports.
     */
    data: XOR<DataExportUpdateManyMutationInput, DataExportUncheckedUpdateManyInput>
    /**
     * Filter which DataExports to update
     */
    where?: DataExportWhereInput
    /**
     * Limit how many DataExports to update.
     */
    limit?: number
  }

  /**
   * DataExport updateManyAndReturn
   */
  export type DataExportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * The data used to update DataExports.
     */
    data: XOR<DataExportUpdateManyMutationInput, DataExportUncheckedUpdateManyInput>
    /**
     * Filter which DataExports to update
     */
    where?: DataExportWhereInput
    /**
     * Limit how many DataExports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataExport upsert
   */
  export type DataExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * The filter to search for the DataExport to update in case it exists.
     */
    where: DataExportWhereUniqueInput
    /**
     * In case the DataExport found by the `where` argument doesn't exist, create a new DataExport with this data.
     */
    create: XOR<DataExportCreateInput, DataExportUncheckedCreateInput>
    /**
     * In case the DataExport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataExportUpdateInput, DataExportUncheckedUpdateInput>
  }

  /**
   * DataExport delete
   */
  export type DataExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
    /**
     * Filter which DataExport to delete.
     */
    where: DataExportWhereUniqueInput
  }

  /**
   * DataExport deleteMany
   */
  export type DataExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataExports to delete
     */
    where?: DataExportWhereInput
    /**
     * Limit how many DataExports to delete.
     */
    limit?: number
  }

  /**
   * DataExport.company
   */
  export type DataExport$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * DataExport without action
   */
  export type DataExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExport
     */
    select?: DataExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataExport
     */
    omit?: DataExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportInclude<ExtArgs> | null
  }


  /**
   * Model DataDeletionRequest
   */

  export type AggregateDataDeletionRequest = {
    _count: DataDeletionRequestCountAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  export type DataDeletionRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    requestType: string | null
    status: string | null
    requestedAt: Date | null
    processedAt: Date | null
    processedBy: string | null
    confirmationToken: string | null
    confirmedAt: Date | null
    errorMessage: string | null
  }

  export type DataDeletionRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    requestType: string | null
    status: string | null
    requestedAt: Date | null
    processedAt: Date | null
    processedBy: string | null
    confirmationToken: string | null
    confirmedAt: Date | null
    errorMessage: string | null
  }

  export type DataDeletionRequestCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    requestType: number
    status: number
    requestedAt: number
    processedAt: number
    processedBy: number
    deletionScope: number
    confirmationToken: number
    confirmedAt: number
    errorMessage: number
    _all: number
  }


  export type DataDeletionRequestMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    requestType?: true
    status?: true
    requestedAt?: true
    processedAt?: true
    processedBy?: true
    confirmationToken?: true
    confirmedAt?: true
    errorMessage?: true
  }

  export type DataDeletionRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    requestType?: true
    status?: true
    requestedAt?: true
    processedAt?: true
    processedBy?: true
    confirmationToken?: true
    confirmedAt?: true
    errorMessage?: true
  }

  export type DataDeletionRequestCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    requestType?: true
    status?: true
    requestedAt?: true
    processedAt?: true
    processedBy?: true
    deletionScope?: true
    confirmationToken?: true
    confirmedAt?: true
    errorMessage?: true
    _all?: true
  }

  export type DataDeletionRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDeletionRequest to aggregate.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataDeletionRequests
    **/
    _count?: true | DataDeletionRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataDeletionRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataDeletionRequestMaxAggregateInputType
  }

  export type GetDataDeletionRequestAggregateType<T extends DataDeletionRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataDeletionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
      : GetScalarType<T[P], AggregateDataDeletionRequest[P]>
  }




  export type DataDeletionRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataDeletionRequestWhereInput
    orderBy?: DataDeletionRequestOrderByWithAggregationInput | DataDeletionRequestOrderByWithAggregationInput[]
    by: DataDeletionRequestScalarFieldEnum[] | DataDeletionRequestScalarFieldEnum
    having?: DataDeletionRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataDeletionRequestCountAggregateInputType | true
    _min?: DataDeletionRequestMinAggregateInputType
    _max?: DataDeletionRequestMaxAggregateInputType
  }

  export type DataDeletionRequestGroupByOutputType = {
    id: string
    userId: string
    companyId: string | null
    requestType: string
    status: string
    requestedAt: Date
    processedAt: Date | null
    processedBy: string | null
    deletionScope: JsonValue | null
    confirmationToken: string
    confirmedAt: Date | null
    errorMessage: string | null
    _count: DataDeletionRequestCountAggregateOutputType | null
    _min: DataDeletionRequestMinAggregateOutputType | null
    _max: DataDeletionRequestMaxAggregateOutputType | null
  }

  type GetDataDeletionRequestGroupByPayload<T extends DataDeletionRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataDeletionRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataDeletionRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataDeletionRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataDeletionRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    requestType?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    processedBy?: boolean
    deletionScope?: boolean
    confirmationToken?: boolean
    confirmedAt?: boolean
    errorMessage?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataDeletionRequest$companyArgs<ExtArgs>
    processor?: boolean | DataDeletionRequest$processorArgs<ExtArgs>
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    requestType?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    processedBy?: boolean
    deletionScope?: boolean
    confirmationToken?: boolean
    confirmedAt?: boolean
    errorMessage?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataDeletionRequest$companyArgs<ExtArgs>
    processor?: boolean | DataDeletionRequest$processorArgs<ExtArgs>
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    requestType?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    processedBy?: boolean
    deletionScope?: boolean
    confirmationToken?: boolean
    confirmedAt?: boolean
    errorMessage?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataDeletionRequest$companyArgs<ExtArgs>
    processor?: boolean | DataDeletionRequest$processorArgs<ExtArgs>
  }, ExtArgs["result"]["dataDeletionRequest"]>

  export type DataDeletionRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    requestType?: boolean
    status?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    processedBy?: boolean
    deletionScope?: boolean
    confirmationToken?: boolean
    confirmedAt?: boolean
    errorMessage?: boolean
  }

  export type DataDeletionRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "requestType" | "status" | "requestedAt" | "processedAt" | "processedBy" | "deletionScope" | "confirmationToken" | "confirmedAt" | "errorMessage", ExtArgs["result"]["dataDeletionRequest"]>
  export type DataDeletionRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataDeletionRequest$companyArgs<ExtArgs>
    processor?: boolean | DataDeletionRequest$processorArgs<ExtArgs>
  }
  export type DataDeletionRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataDeletionRequest$companyArgs<ExtArgs>
    processor?: boolean | DataDeletionRequest$processorArgs<ExtArgs>
  }
  export type DataDeletionRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | DataDeletionRequest$companyArgs<ExtArgs>
    processor?: boolean | DataDeletionRequest$processorArgs<ExtArgs>
  }

  export type $DataDeletionRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataDeletionRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
      processor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string | null
      requestType: string
      status: string
      requestedAt: Date
      processedAt: Date | null
      processedBy: string | null
      deletionScope: Prisma.JsonValue | null
      confirmationToken: string
      confirmedAt: Date | null
      errorMessage: string | null
    }, ExtArgs["result"]["dataDeletionRequest"]>
    composites: {}
  }

  type DataDeletionRequestGetPayload<S extends boolean | null | undefined | DataDeletionRequestDefaultArgs> = $Result.GetResult<Prisma.$DataDeletionRequestPayload, S>

  type DataDeletionRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataDeletionRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataDeletionRequestCountAggregateInputType | true
    }

  export interface DataDeletionRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataDeletionRequest'], meta: { name: 'DataDeletionRequest' } }
    /**
     * Find zero or one DataDeletionRequest that matches the filter.
     * @param {DataDeletionRequestFindUniqueArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataDeletionRequestFindUniqueArgs>(args: SelectSubset<T, DataDeletionRequestFindUniqueArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataDeletionRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataDeletionRequestFindUniqueOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataDeletionRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataDeletionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataDeletionRequestFindFirstArgs>(args?: SelectSubset<T, DataDeletionRequestFindFirstArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataDeletionRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindFirstOrThrowArgs} args - Arguments to find a DataDeletionRequest
     * @example
     * // Get one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataDeletionRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataDeletionRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataDeletionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany()
     * 
     * // Get first 10 DataDeletionRequests
     * const dataDeletionRequests = await prisma.dataDeletionRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataDeletionRequestFindManyArgs>(args?: SelectSubset<T, DataDeletionRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataDeletionRequest.
     * @param {DataDeletionRequestCreateArgs} args - Arguments to create a DataDeletionRequest.
     * @example
     * // Create one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.create({
     *   data: {
     *     // ... data to create a DataDeletionRequest
     *   }
     * })
     * 
     */
    create<T extends DataDeletionRequestCreateArgs>(args: SelectSubset<T, DataDeletionRequestCreateArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataDeletionRequests.
     * @param {DataDeletionRequestCreateManyArgs} args - Arguments to create many DataDeletionRequests.
     * @example
     * // Create many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataDeletionRequestCreateManyArgs>(args?: SelectSubset<T, DataDeletionRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataDeletionRequests and returns the data saved in the database.
     * @param {DataDeletionRequestCreateManyAndReturnArgs} args - Arguments to create many DataDeletionRequests.
     * @example
     * // Create many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataDeletionRequests and only return the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataDeletionRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataDeletionRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataDeletionRequest.
     * @param {DataDeletionRequestDeleteArgs} args - Arguments to delete one DataDeletionRequest.
     * @example
     * // Delete one DataDeletionRequest
     * const DataDeletionRequest = await prisma.dataDeletionRequest.delete({
     *   where: {
     *     // ... filter to delete one DataDeletionRequest
     *   }
     * })
     * 
     */
    delete<T extends DataDeletionRequestDeleteArgs>(args: SelectSubset<T, DataDeletionRequestDeleteArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataDeletionRequest.
     * @param {DataDeletionRequestUpdateArgs} args - Arguments to update one DataDeletionRequest.
     * @example
     * // Update one DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataDeletionRequestUpdateArgs>(args: SelectSubset<T, DataDeletionRequestUpdateArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataDeletionRequests.
     * @param {DataDeletionRequestDeleteManyArgs} args - Arguments to filter DataDeletionRequests to delete.
     * @example
     * // Delete a few DataDeletionRequests
     * const { count } = await prisma.dataDeletionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataDeletionRequestDeleteManyArgs>(args?: SelectSubset<T, DataDeletionRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataDeletionRequestUpdateManyArgs>(args: SelectSubset<T, DataDeletionRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataDeletionRequests and returns the data updated in the database.
     * @param {DataDeletionRequestUpdateManyAndReturnArgs} args - Arguments to update many DataDeletionRequests.
     * @example
     * // Update many DataDeletionRequests
     * const dataDeletionRequest = await prisma.dataDeletionRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataDeletionRequests and only return the `id`
     * const dataDeletionRequestWithIdOnly = await prisma.dataDeletionRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataDeletionRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataDeletionRequest.
     * @param {DataDeletionRequestUpsertArgs} args - Arguments to update or create a DataDeletionRequest.
     * @example
     * // Update or create a DataDeletionRequest
     * const dataDeletionRequest = await prisma.dataDeletionRequest.upsert({
     *   create: {
     *     // ... data to create a DataDeletionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataDeletionRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataDeletionRequestUpsertArgs>(args: SelectSubset<T, DataDeletionRequestUpsertArgs<ExtArgs>>): Prisma__DataDeletionRequestClient<$Result.GetResult<Prisma.$DataDeletionRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataDeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestCountArgs} args - Arguments to filter DataDeletionRequests to count.
     * @example
     * // Count the number of DataDeletionRequests
     * const count = await prisma.dataDeletionRequest.count({
     *   where: {
     *     // ... the filter for the DataDeletionRequests we want to count
     *   }
     * })
    **/
    count<T extends DataDeletionRequestCountArgs>(
      args?: Subset<T, DataDeletionRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataDeletionRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataDeletionRequestAggregateArgs>(args: Subset<T, DataDeletionRequestAggregateArgs>): Prisma.PrismaPromise<GetDataDeletionRequestAggregateType<T>>

    /**
     * Group by DataDeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataDeletionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataDeletionRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataDeletionRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataDeletionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataDeletionRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataDeletionRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataDeletionRequest model
   */
  readonly fields: DataDeletionRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataDeletionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataDeletionRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends DataDeletionRequest$companyArgs<ExtArgs> = {}>(args?: Subset<T, DataDeletionRequest$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processor<T extends DataDeletionRequest$processorArgs<ExtArgs> = {}>(args?: Subset<T, DataDeletionRequest$processorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataDeletionRequest model
   */
  interface DataDeletionRequestFieldRefs {
    readonly id: FieldRef<"DataDeletionRequest", 'String'>
    readonly userId: FieldRef<"DataDeletionRequest", 'String'>
    readonly companyId: FieldRef<"DataDeletionRequest", 'String'>
    readonly requestType: FieldRef<"DataDeletionRequest", 'String'>
    readonly status: FieldRef<"DataDeletionRequest", 'String'>
    readonly requestedAt: FieldRef<"DataDeletionRequest", 'DateTime'>
    readonly processedAt: FieldRef<"DataDeletionRequest", 'DateTime'>
    readonly processedBy: FieldRef<"DataDeletionRequest", 'String'>
    readonly deletionScope: FieldRef<"DataDeletionRequest", 'Json'>
    readonly confirmationToken: FieldRef<"DataDeletionRequest", 'String'>
    readonly confirmedAt: FieldRef<"DataDeletionRequest", 'DateTime'>
    readonly errorMessage: FieldRef<"DataDeletionRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DataDeletionRequest findUnique
   */
  export type DataDeletionRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest findUniqueOrThrow
   */
  export type DataDeletionRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest findFirst
   */
  export type DataDeletionRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest findFirstOrThrow
   */
  export type DataDeletionRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequest to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataDeletionRequests.
     */
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest findMany
   */
  export type DataDeletionRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataDeletionRequests to fetch.
     */
    where?: DataDeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataDeletionRequests to fetch.
     */
    orderBy?: DataDeletionRequestOrderByWithRelationInput | DataDeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataDeletionRequests.
     */
    cursor?: DataDeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataDeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataDeletionRequests.
     */
    skip?: number
    distinct?: DataDeletionRequestScalarFieldEnum | DataDeletionRequestScalarFieldEnum[]
  }

  /**
   * DataDeletionRequest create
   */
  export type DataDeletionRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
  }

  /**
   * DataDeletionRequest createMany
   */
  export type DataDeletionRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataDeletionRequests.
     */
    data: DataDeletionRequestCreateManyInput | DataDeletionRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataDeletionRequest createManyAndReturn
   */
  export type DataDeletionRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data used to create many DataDeletionRequests.
     */
    data: DataDeletionRequestCreateManyInput | DataDeletionRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataDeletionRequest update
   */
  export type DataDeletionRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DataDeletionRequest.
     */
    data: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
    /**
     * Choose, which DataDeletionRequest to update.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest updateMany
   */
  export type DataDeletionRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataDeletionRequests.
     */
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataDeletionRequests to update
     */
    where?: DataDeletionRequestWhereInput
    /**
     * Limit how many DataDeletionRequests to update.
     */
    limit?: number
  }

  /**
   * DataDeletionRequest updateManyAndReturn
   */
  export type DataDeletionRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * The data used to update DataDeletionRequests.
     */
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataDeletionRequests to update
     */
    where?: DataDeletionRequestWhereInput
    /**
     * Limit how many DataDeletionRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataDeletionRequest upsert
   */
  export type DataDeletionRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DataDeletionRequest to update in case it exists.
     */
    where: DataDeletionRequestWhereUniqueInput
    /**
     * In case the DataDeletionRequest found by the `where` argument doesn't exist, create a new DataDeletionRequest with this data.
     */
    create: XOR<DataDeletionRequestCreateInput, DataDeletionRequestUncheckedCreateInput>
    /**
     * In case the DataDeletionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataDeletionRequestUpdateInput, DataDeletionRequestUncheckedUpdateInput>
  }

  /**
   * DataDeletionRequest delete
   */
  export type DataDeletionRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
    /**
     * Filter which DataDeletionRequest to delete.
     */
    where: DataDeletionRequestWhereUniqueInput
  }

  /**
   * DataDeletionRequest deleteMany
   */
  export type DataDeletionRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataDeletionRequests to delete
     */
    where?: DataDeletionRequestWhereInput
    /**
     * Limit how many DataDeletionRequests to delete.
     */
    limit?: number
  }

  /**
   * DataDeletionRequest.company
   */
  export type DataDeletionRequest$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * DataDeletionRequest.processor
   */
  export type DataDeletionRequest$processorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DataDeletionRequest without action
   */
  export type DataDeletionRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataDeletionRequest
     */
    select?: DataDeletionRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataDeletionRequest
     */
    omit?: DataDeletionRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataDeletionRequestInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ReportSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    reportType: string | null
    format: string | null
    status: string | null
    filePath: string | null
    fileSize: number | null
    generatedAt: Date | null
    expiresAt: Date | null
    userId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    reportType: string | null
    format: string | null
    status: string | null
    filePath: string | null
    fileSize: number | null
    generatedAt: Date | null
    expiresAt: Date | null
    userId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    name: number
    description: number
    reportType: number
    format: number
    config: number
    status: number
    filePath: number
    fileSize: number
    generatedAt: number
    expiresAt: number
    userId: number
    companyId: number
    createdAt: number
    updatedAt: number
    templateId: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    fileSize?: true
  }

  export type ReportSumAggregateInputType = {
    fileSize?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    format?: true
    status?: true
    filePath?: true
    fileSize?: true
    generatedAt?: true
    expiresAt?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    format?: true
    status?: true
    filePath?: true
    fileSize?: true
    generatedAt?: true
    expiresAt?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    format?: true
    config?: true
    status?: true
    filePath?: true
    fileSize?: true
    generatedAt?: true
    expiresAt?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    name: string
    description: string | null
    reportType: string
    format: string
    config: JsonValue
    status: string
    filePath: string | null
    fileSize: number | null
    generatedAt: Date | null
    expiresAt: Date | null
    userId: string
    companyId: string | null
    createdAt: Date
    updatedAt: Date
    templateId: string | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Report$companyArgs<ExtArgs>
    template?: boolean | Report$templateArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Report$companyArgs<ExtArgs>
    template?: boolean | Report$templateArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Report$companyArgs<ExtArgs>
    template?: boolean | Report$templateArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    status?: boolean
    filePath?: boolean
    fileSize?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "reportType" | "format" | "config" | "status" | "filePath" | "fileSize" | "generatedAt" | "expiresAt" | "userId" | "companyId" | "createdAt" | "updatedAt" | "templateId", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Report$companyArgs<ExtArgs>
    template?: boolean | Report$templateArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Report$companyArgs<ExtArgs>
    template?: boolean | Report$templateArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Report$companyArgs<ExtArgs>
    template?: boolean | Report$templateArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
      template: Prisma.$ReportTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      reportType: string
      format: string
      config: Prisma.JsonValue
      status: string
      filePath: string | null
      fileSize: number | null
      generatedAt: Date | null
      expiresAt: Date | null
      userId: string
      companyId: string | null
      createdAt: Date
      updatedAt: Date
      templateId: string | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends Report$companyArgs<ExtArgs> = {}>(args?: Subset<T, Report$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    template<T extends Report$templateArgs<ExtArgs> = {}>(args?: Subset<T, Report$templateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly name: FieldRef<"Report", 'String'>
    readonly description: FieldRef<"Report", 'String'>
    readonly reportType: FieldRef<"Report", 'String'>
    readonly format: FieldRef<"Report", 'String'>
    readonly config: FieldRef<"Report", 'Json'>
    readonly status: FieldRef<"Report", 'String'>
    readonly filePath: FieldRef<"Report", 'String'>
    readonly fileSize: FieldRef<"Report", 'Int'>
    readonly generatedAt: FieldRef<"Report", 'DateTime'>
    readonly expiresAt: FieldRef<"Report", 'DateTime'>
    readonly userId: FieldRef<"Report", 'String'>
    readonly companyId: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
    readonly templateId: FieldRef<"Report", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.company
   */
  export type Report$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Report.template
   */
  export type Report$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportTemplate
   */

  export type AggregateReportTemplate = {
    _count: ReportTemplateCountAggregateOutputType | null
    _avg: ReportTemplateAvgAggregateOutputType | null
    _sum: ReportTemplateSumAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  export type ReportTemplateAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ReportTemplateSumAggregateOutputType = {
    usageCount: number | null
  }

  export type ReportTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    reportType: string | null
    category: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    userId: string | null
    companyId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    reportType: string | null
    category: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    userId: string | null
    companyId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    reportType: number
    category: number
    config: number
    isSystem: number
    isPublic: number
    userId: number
    companyId: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportTemplateAvgAggregateInputType = {
    usageCount?: true
  }

  export type ReportTemplateSumAggregateInputType = {
    usageCount?: true
  }

  export type ReportTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    category?: true
    isSystem?: true
    isPublic?: true
    userId?: true
    companyId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    category?: true
    isSystem?: true
    isPublic?: true
    userId?: true
    companyId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    category?: true
    config?: true
    isSystem?: true
    isPublic?: true
    userId?: true
    companyId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplate to aggregate.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportTemplates
    **/
    _count?: true | ReportTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type GetReportTemplateAggregateType<T extends ReportTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateReportTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportTemplate[P]>
      : GetScalarType<T[P], AggregateReportTemplate[P]>
  }




  export type ReportTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithAggregationInput | ReportTemplateOrderByWithAggregationInput[]
    by: ReportTemplateScalarFieldEnum[] | ReportTemplateScalarFieldEnum
    having?: ReportTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportTemplateCountAggregateInputType | true
    _avg?: ReportTemplateAvgAggregateInputType
    _sum?: ReportTemplateSumAggregateInputType
    _min?: ReportTemplateMinAggregateInputType
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type ReportTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    reportType: string
    category: string | null
    config: JsonValue
    isSystem: boolean
    isPublic: boolean
    userId: string
    companyId: string | null
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: ReportTemplateCountAggregateOutputType | null
    _avg: ReportTemplateAvgAggregateOutputType | null
    _sum: ReportTemplateSumAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  type GetReportTemplateGroupByPayload<T extends ReportTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ReportTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    category?: boolean
    config?: boolean
    isSystem?: boolean
    isPublic?: boolean
    userId?: boolean
    companyId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ReportTemplate$companyArgs<ExtArgs>
    reports?: boolean | ReportTemplate$reportsArgs<ExtArgs>
    scheduledReports?: boolean | ReportTemplate$scheduledReportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    category?: boolean
    config?: boolean
    isSystem?: boolean
    isPublic?: boolean
    userId?: boolean
    companyId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ReportTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    category?: boolean
    config?: boolean
    isSystem?: boolean
    isPublic?: boolean
    userId?: boolean
    companyId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ReportTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    category?: boolean
    config?: boolean
    isSystem?: boolean
    isPublic?: boolean
    userId?: boolean
    companyId?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "reportType" | "category" | "config" | "isSystem" | "isPublic" | "userId" | "companyId" | "usageCount" | "createdAt" | "updatedAt", ExtArgs["result"]["reportTemplate"]>
  export type ReportTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ReportTemplate$companyArgs<ExtArgs>
    reports?: boolean | ReportTemplate$reportsArgs<ExtArgs>
    scheduledReports?: boolean | ReportTemplate$scheduledReportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ReportTemplate$companyArgs<ExtArgs>
  }
  export type ReportTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ReportTemplate$companyArgs<ExtArgs>
  }

  export type $ReportTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportTemplate"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
      reports: Prisma.$ReportPayload<ExtArgs>[]
      scheduledReports: Prisma.$ScheduledReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      reportType: string
      category: string | null
      config: Prisma.JsonValue
      isSystem: boolean
      isPublic: boolean
      userId: string
      companyId: string | null
      usageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportTemplate"]>
    composites: {}
  }

  type ReportTemplateGetPayload<S extends boolean | null | undefined | ReportTemplateDefaultArgs> = $Result.GetResult<Prisma.$ReportTemplatePayload, S>

  type ReportTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportTemplateCountAggregateInputType | true
    }

  export interface ReportTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportTemplate'], meta: { name: 'ReportTemplate' } }
    /**
     * Find zero or one ReportTemplate that matches the filter.
     * @param {ReportTemplateFindUniqueArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportTemplateFindUniqueArgs>(args: SelectSubset<T, ReportTemplateFindUniqueArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportTemplateFindUniqueOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportTemplateFindFirstArgs>(args?: SelectSubset<T, ReportTemplateFindFirstArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany()
     * 
     * // Get first 10 ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportTemplateFindManyArgs>(args?: SelectSubset<T, ReportTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportTemplate.
     * @param {ReportTemplateCreateArgs} args - Arguments to create a ReportTemplate.
     * @example
     * // Create one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.create({
     *   data: {
     *     // ... data to create a ReportTemplate
     *   }
     * })
     * 
     */
    create<T extends ReportTemplateCreateArgs>(args: SelectSubset<T, ReportTemplateCreateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportTemplates.
     * @param {ReportTemplateCreateManyArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportTemplateCreateManyArgs>(args?: SelectSubset<T, ReportTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportTemplates and returns the data saved in the database.
     * @param {ReportTemplateCreateManyAndReturnArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportTemplate.
     * @param {ReportTemplateDeleteArgs} args - Arguments to delete one ReportTemplate.
     * @example
     * // Delete one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.delete({
     *   where: {
     *     // ... filter to delete one ReportTemplate
     *   }
     * })
     * 
     */
    delete<T extends ReportTemplateDeleteArgs>(args: SelectSubset<T, ReportTemplateDeleteArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportTemplate.
     * @param {ReportTemplateUpdateArgs} args - Arguments to update one ReportTemplate.
     * @example
     * // Update one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportTemplateUpdateArgs>(args: SelectSubset<T, ReportTemplateUpdateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportTemplates.
     * @param {ReportTemplateDeleteManyArgs} args - Arguments to filter ReportTemplates to delete.
     * @example
     * // Delete a few ReportTemplates
     * const { count } = await prisma.reportTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportTemplateDeleteManyArgs>(args?: SelectSubset<T, ReportTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportTemplateUpdateManyArgs>(args: SelectSubset<T, ReportTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates and returns the data updated in the database.
     * @param {ReportTemplateUpdateManyAndReturnArgs} args - Arguments to update many ReportTemplates.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportTemplate.
     * @param {ReportTemplateUpsertArgs} args - Arguments to update or create a ReportTemplate.
     * @example
     * // Update or create a ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.upsert({
     *   create: {
     *     // ... data to create a ReportTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ReportTemplateUpsertArgs>(args: SelectSubset<T, ReportTemplateUpsertArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateCountArgs} args - Arguments to filter ReportTemplates to count.
     * @example
     * // Count the number of ReportTemplates
     * const count = await prisma.reportTemplate.count({
     *   where: {
     *     // ... the filter for the ReportTemplates we want to count
     *   }
     * })
    **/
    count<T extends ReportTemplateCountArgs>(
      args?: Subset<T, ReportTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportTemplateAggregateArgs>(args: Subset<T, ReportTemplateAggregateArgs>): Prisma.PrismaPromise<GetReportTemplateAggregateType<T>>

    /**
     * Group by ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ReportTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportTemplate model
   */
  readonly fields: ReportTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends ReportTemplate$companyArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reports<T extends ReportTemplate$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduledReports<T extends ReportTemplate$scheduledReportsArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$scheduledReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportTemplate model
   */
  interface ReportTemplateFieldRefs {
    readonly id: FieldRef<"ReportTemplate", 'String'>
    readonly name: FieldRef<"ReportTemplate", 'String'>
    readonly description: FieldRef<"ReportTemplate", 'String'>
    readonly reportType: FieldRef<"ReportTemplate", 'String'>
    readonly category: FieldRef<"ReportTemplate", 'String'>
    readonly config: FieldRef<"ReportTemplate", 'Json'>
    readonly isSystem: FieldRef<"ReportTemplate", 'Boolean'>
    readonly isPublic: FieldRef<"ReportTemplate", 'Boolean'>
    readonly userId: FieldRef<"ReportTemplate", 'String'>
    readonly companyId: FieldRef<"ReportTemplate", 'String'>
    readonly usageCount: FieldRef<"ReportTemplate", 'Int'>
    readonly createdAt: FieldRef<"ReportTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportTemplate findUnique
   */
  export type ReportTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findUniqueOrThrow
   */
  export type ReportTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findFirst
   */
  export type ReportTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findFirstOrThrow
   */
  export type ReportTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findMany
   */
  export type ReportTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplates to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate create
   */
  export type ReportTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportTemplate.
     */
    data: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
  }

  /**
   * ReportTemplate createMany
   */
  export type ReportTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportTemplate createManyAndReturn
   */
  export type ReportTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportTemplate update
   */
  export type ReportTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportTemplate.
     */
    data: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
    /**
     * Choose, which ReportTemplate to update.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate updateMany
   */
  export type ReportTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to update.
     */
    limit?: number
  }

  /**
   * ReportTemplate updateManyAndReturn
   */
  export type ReportTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportTemplate upsert
   */
  export type ReportTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportTemplate to update in case it exists.
     */
    where: ReportTemplateWhereUniqueInput
    /**
     * In case the ReportTemplate found by the `where` argument doesn't exist, create a new ReportTemplate with this data.
     */
    create: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
    /**
     * In case the ReportTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
  }

  /**
   * ReportTemplate delete
   */
  export type ReportTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter which ReportTemplate to delete.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate deleteMany
   */
  export type ReportTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplates to delete
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to delete.
     */
    limit?: number
  }

  /**
   * ReportTemplate.company
   */
  export type ReportTemplate$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * ReportTemplate.reports
   */
  export type ReportTemplate$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * ReportTemplate.scheduledReports
   */
  export type ReportTemplate$scheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ReportTemplate without action
   */
  export type ReportTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledReport
   */

  export type AggregateScheduledReport = {
    _count: ScheduledReportCountAggregateOutputType | null
    _avg: ScheduledReportAvgAggregateOutputType | null
    _sum: ScheduledReportSumAggregateOutputType | null
    _min: ScheduledReportMinAggregateOutputType | null
    _max: ScheduledReportMaxAggregateOutputType | null
  }

  export type ScheduledReportAvgAggregateOutputType = {
    runCount: number | null
  }

  export type ScheduledReportSumAggregateOutputType = {
    runCount: number | null
  }

  export type ScheduledReportMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    reportType: string | null
    format: string | null
    templateId: string | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    runCount: number | null
    userId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledReportMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    reportType: string | null
    format: string | null
    templateId: string | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    runCount: number | null
    userId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledReportCountAggregateOutputType = {
    id: number
    name: number
    description: number
    reportType: number
    format: number
    config: number
    schedule: number
    recipients: number
    templateId: number
    isActive: number
    lastRunAt: number
    nextRunAt: number
    runCount: number
    userId: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledReportAvgAggregateInputType = {
    runCount?: true
  }

  export type ScheduledReportSumAggregateInputType = {
    runCount?: true
  }

  export type ScheduledReportMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    format?: true
    templateId?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    runCount?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledReportMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    format?: true
    templateId?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    runCount?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledReportCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    reportType?: true
    format?: true
    config?: true
    schedule?: true
    recipients?: true
    templateId?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    runCount?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReport to aggregate.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledReports
    **/
    _count?: true | ScheduledReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduledReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduledReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledReportMaxAggregateInputType
  }

  export type GetScheduledReportAggregateType<T extends ScheduledReportAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledReport[P]>
      : GetScalarType<T[P], AggregateScheduledReport[P]>
  }




  export type ScheduledReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithAggregationInput | ScheduledReportOrderByWithAggregationInput[]
    by: ScheduledReportScalarFieldEnum[] | ScheduledReportScalarFieldEnum
    having?: ScheduledReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledReportCountAggregateInputType | true
    _avg?: ScheduledReportAvgAggregateInputType
    _sum?: ScheduledReportSumAggregateInputType
    _min?: ScheduledReportMinAggregateInputType
    _max?: ScheduledReportMaxAggregateInputType
  }

  export type ScheduledReportGroupByOutputType = {
    id: string
    name: string
    description: string | null
    reportType: string
    format: string
    config: JsonValue
    schedule: JsonValue
    recipients: JsonValue | null
    templateId: string | null
    isActive: boolean
    lastRunAt: Date | null
    nextRunAt: Date | null
    runCount: number
    userId: string
    companyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledReportCountAggregateOutputType | null
    _avg: ScheduledReportAvgAggregateOutputType | null
    _sum: ScheduledReportSumAggregateOutputType | null
    _min: ScheduledReportMinAggregateOutputType | null
    _max: ScheduledReportMaxAggregateOutputType | null
  }

  type GetScheduledReportGroupByPayload<T extends ScheduledReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledReportGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledReportGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    schedule?: boolean
    recipients?: boolean
    templateId?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    runCount?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ScheduledReport$companyArgs<ExtArgs>
    template?: boolean | ScheduledReport$templateArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    schedule?: boolean
    recipients?: boolean
    templateId?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    runCount?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ScheduledReport$companyArgs<ExtArgs>
    template?: boolean | ScheduledReport$templateArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    schedule?: boolean
    recipients?: boolean
    templateId?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    runCount?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ScheduledReport$companyArgs<ExtArgs>
    template?: boolean | ScheduledReport$templateArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    format?: boolean
    config?: boolean
    schedule?: boolean
    recipients?: boolean
    templateId?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    runCount?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "reportType" | "format" | "config" | "schedule" | "recipients" | "templateId" | "isActive" | "lastRunAt" | "nextRunAt" | "runCount" | "userId" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduledReport"]>
  export type ScheduledReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ScheduledReport$companyArgs<ExtArgs>
    template?: boolean | ScheduledReport$templateArgs<ExtArgs>
  }
  export type ScheduledReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ScheduledReport$companyArgs<ExtArgs>
    template?: boolean | ScheduledReport$templateArgs<ExtArgs>
  }
  export type ScheduledReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | ScheduledReport$companyArgs<ExtArgs>
    template?: boolean | ScheduledReport$templateArgs<ExtArgs>
  }

  export type $ScheduledReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledReport"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
      template: Prisma.$ReportTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      reportType: string
      format: string
      config: Prisma.JsonValue
      schedule: Prisma.JsonValue
      recipients: Prisma.JsonValue | null
      templateId: string | null
      isActive: boolean
      lastRunAt: Date | null
      nextRunAt: Date | null
      runCount: number
      userId: string
      companyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledReport"]>
    composites: {}
  }

  type ScheduledReportGetPayload<S extends boolean | null | undefined | ScheduledReportDefaultArgs> = $Result.GetResult<Prisma.$ScheduledReportPayload, S>

  type ScheduledReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledReportCountAggregateInputType | true
    }

  export interface ScheduledReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledReport'], meta: { name: 'ScheduledReport' } }
    /**
     * Find zero or one ScheduledReport that matches the filter.
     * @param {ScheduledReportFindUniqueArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledReportFindUniqueArgs>(args: SelectSubset<T, ScheduledReportFindUniqueArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledReportFindUniqueOrThrowArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindFirstArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledReportFindFirstArgs>(args?: SelectSubset<T, ScheduledReportFindFirstArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindFirstOrThrowArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledReports
     * const scheduledReports = await prisma.scheduledReport.findMany()
     * 
     * // Get first 10 ScheduledReports
     * const scheduledReports = await prisma.scheduledReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledReportFindManyArgs>(args?: SelectSubset<T, ScheduledReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledReport.
     * @param {ScheduledReportCreateArgs} args - Arguments to create a ScheduledReport.
     * @example
     * // Create one ScheduledReport
     * const ScheduledReport = await prisma.scheduledReport.create({
     *   data: {
     *     // ... data to create a ScheduledReport
     *   }
     * })
     * 
     */
    create<T extends ScheduledReportCreateArgs>(args: SelectSubset<T, ScheduledReportCreateArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledReports.
     * @param {ScheduledReportCreateManyArgs} args - Arguments to create many ScheduledReports.
     * @example
     * // Create many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledReportCreateManyArgs>(args?: SelectSubset<T, ScheduledReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledReports and returns the data saved in the database.
     * @param {ScheduledReportCreateManyAndReturnArgs} args - Arguments to create many ScheduledReports.
     * @example
     * // Create many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledReports and only return the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduledReport.
     * @param {ScheduledReportDeleteArgs} args - Arguments to delete one ScheduledReport.
     * @example
     * // Delete one ScheduledReport
     * const ScheduledReport = await prisma.scheduledReport.delete({
     *   where: {
     *     // ... filter to delete one ScheduledReport
     *   }
     * })
     * 
     */
    delete<T extends ScheduledReportDeleteArgs>(args: SelectSubset<T, ScheduledReportDeleteArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledReport.
     * @param {ScheduledReportUpdateArgs} args - Arguments to update one ScheduledReport.
     * @example
     * // Update one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledReportUpdateArgs>(args: SelectSubset<T, ScheduledReportUpdateArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledReports.
     * @param {ScheduledReportDeleteManyArgs} args - Arguments to filter ScheduledReports to delete.
     * @example
     * // Delete a few ScheduledReports
     * const { count } = await prisma.scheduledReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledReportDeleteManyArgs>(args?: SelectSubset<T, ScheduledReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledReportUpdateManyArgs>(args: SelectSubset<T, ScheduledReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledReports and returns the data updated in the database.
     * @param {ScheduledReportUpdateManyAndReturnArgs} args - Arguments to update many ScheduledReports.
     * @example
     * // Update many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduledReports and only return the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduledReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduledReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduledReport.
     * @param {ScheduledReportUpsertArgs} args - Arguments to update or create a ScheduledReport.
     * @example
     * // Update or create a ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.upsert({
     *   create: {
     *     // ... data to create a ScheduledReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledReport we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledReportUpsertArgs>(args: SelectSubset<T, ScheduledReportUpsertArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportCountArgs} args - Arguments to filter ScheduledReports to count.
     * @example
     * // Count the number of ScheduledReports
     * const count = await prisma.scheduledReport.count({
     *   where: {
     *     // ... the filter for the ScheduledReports we want to count
     *   }
     * })
    **/
    count<T extends ScheduledReportCountArgs>(
      args?: Subset<T, ScheduledReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledReportAggregateArgs>(args: Subset<T, ScheduledReportAggregateArgs>): Prisma.PrismaPromise<GetScheduledReportAggregateType<T>>

    /**
     * Group by ScheduledReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledReportGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledReport model
   */
  readonly fields: ScheduledReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends ScheduledReport$companyArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledReport$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    template<T extends ScheduledReport$templateArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledReport$templateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledReport model
   */
  interface ScheduledReportFieldRefs {
    readonly id: FieldRef<"ScheduledReport", 'String'>
    readonly name: FieldRef<"ScheduledReport", 'String'>
    readonly description: FieldRef<"ScheduledReport", 'String'>
    readonly reportType: FieldRef<"ScheduledReport", 'String'>
    readonly format: FieldRef<"ScheduledReport", 'String'>
    readonly config: FieldRef<"ScheduledReport", 'Json'>
    readonly schedule: FieldRef<"ScheduledReport", 'Json'>
    readonly recipients: FieldRef<"ScheduledReport", 'Json'>
    readonly templateId: FieldRef<"ScheduledReport", 'String'>
    readonly isActive: FieldRef<"ScheduledReport", 'Boolean'>
    readonly lastRunAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly nextRunAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly runCount: FieldRef<"ScheduledReport", 'Int'>
    readonly userId: FieldRef<"ScheduledReport", 'String'>
    readonly companyId: FieldRef<"ScheduledReport", 'String'>
    readonly createdAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledReport findUnique
   */
  export type ScheduledReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport findUniqueOrThrow
   */
  export type ScheduledReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport findFirst
   */
  export type ScheduledReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReports.
     */
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport findFirstOrThrow
   */
  export type ScheduledReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReports.
     */
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport findMany
   */
  export type ScheduledReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReports to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport create
   */
  export type ScheduledReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledReport.
     */
    data: XOR<ScheduledReportCreateInput, ScheduledReportUncheckedCreateInput>
  }

  /**
   * ScheduledReport createMany
   */
  export type ScheduledReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledReports.
     */
    data: ScheduledReportCreateManyInput | ScheduledReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledReport createManyAndReturn
   */
  export type ScheduledReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduledReports.
     */
    data: ScheduledReportCreateManyInput | ScheduledReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledReport update
   */
  export type ScheduledReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledReport.
     */
    data: XOR<ScheduledReportUpdateInput, ScheduledReportUncheckedUpdateInput>
    /**
     * Choose, which ScheduledReport to update.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport updateMany
   */
  export type ScheduledReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledReports.
     */
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledReports to update
     */
    where?: ScheduledReportWhereInput
    /**
     * Limit how many ScheduledReports to update.
     */
    limit?: number
  }

  /**
   * ScheduledReport updateManyAndReturn
   */
  export type ScheduledReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * The data used to update ScheduledReports.
     */
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledReports to update
     */
    where?: ScheduledReportWhereInput
    /**
     * Limit how many ScheduledReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledReport upsert
   */
  export type ScheduledReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledReport to update in case it exists.
     */
    where: ScheduledReportWhereUniqueInput
    /**
     * In case the ScheduledReport found by the `where` argument doesn't exist, create a new ScheduledReport with this data.
     */
    create: XOR<ScheduledReportCreateInput, ScheduledReportUncheckedCreateInput>
    /**
     * In case the ScheduledReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledReportUpdateInput, ScheduledReportUncheckedUpdateInput>
  }

  /**
   * ScheduledReport delete
   */
  export type ScheduledReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter which ScheduledReport to delete.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport deleteMany
   */
  export type ScheduledReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReports to delete
     */
    where?: ScheduledReportWhereInput
    /**
     * Limit how many ScheduledReports to delete.
     */
    limit?: number
  }

  /**
   * ScheduledReport.company
   */
  export type ScheduledReport$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * ScheduledReport.template
   */
  export type ScheduledReport$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
  }

  /**
   * ScheduledReport without action
   */
  export type ScheduledReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    recoveryEmail: 'recoveryEmail',
    recoveryEmailVerified: 'recoveryEmailVerified',
    image: 'image',
    password: 'password',
    phoneNumber: 'phoneNumber',
    bio: 'bio',
    preferences: 'preferences',
    role: 'role',
    isActive: 'isActive',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    mfaMethod: 'mfaMethod',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    createdById: 'createdById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceName: 'deviceName',
    deviceType: 'deviceType',
    deviceFingerprint: 'deviceFingerprint',
    isTrusted: 'isTrusted',
    requireMfa: 'requireMfa',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const PasswordScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    password: 'password',
    url: 'url',
    notes: 'notes',
    folderId: 'folderId',
    strength: 'strength',
    hasTotp: 'hasTotp',
    totpSecret: 'totpSecret',
    expiresAt: 'expiresAt',
    isFavorite: 'isFavorite',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rotationPolicyId: 'rotationPolicyId'
  };

  export type PasswordScalarFieldEnum = (typeof PasswordScalarFieldEnum)[keyof typeof PasswordScalarFieldEnum]


  export const PasswordHistoryScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    name: 'name',
    username: 'username',
    password: 'password',
    url: 'url',
    notes: 'notes',
    folderId: 'folderId',
    strength: 'strength',
    hasTotp: 'hasTotp',
    totpSecret: 'totpSecret',
    expiresAt: 'expiresAt',
    changedBy: 'changedBy',
    changeType: 'changeType',
    createdAt: 'createdAt'
  };

  export type PasswordHistoryScalarFieldEnum = (typeof PasswordHistoryScalarFieldEnum)[keyof typeof PasswordHistoryScalarFieldEnum]


  export const PasswordBreachScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    isBreached: 'isBreached',
    breachCount: 'breachCount',
    hashPrefix: 'hashPrefix',
    checkedAt: 'checkedAt',
    checkedBy: 'checkedBy',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy'
  };

  export type PasswordBreachScalarFieldEnum = (typeof PasswordBreachScalarFieldEnum)[keyof typeof PasswordBreachScalarFieldEnum]


  export const PasswordRotationPolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    rotationDays: 'rotationDays',
    reminderDays: 'reminderDays',
    autoRotate: 'autoRotate',
    requireApproval: 'requireApproval',
    isActive: 'isActive',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordRotationPolicyScalarFieldEnum = (typeof PasswordRotationPolicyScalarFieldEnum)[keyof typeof PasswordRotationPolicyScalarFieldEnum]


  export const PasswordRotationScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    policyId: 'policyId',
    rotationType: 'rotationType',
    oldPassword: 'oldPassword',
    newPassword: 'newPassword',
    rotatedAt: 'rotatedAt',
    rotatedBy: 'rotatedBy',
    scheduledFor: 'scheduledFor',
    completedAt: 'completedAt',
    status: 'status',
    notes: 'notes'
  };

  export type PasswordRotationScalarFieldEnum = (typeof PasswordRotationScalarFieldEnum)[keyof typeof PasswordRotationScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const PasswordShareScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    userId: 'userId',
    teamId: 'teamId',
    permission: 'permission',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type PasswordShareScalarFieldEnum = (typeof PasswordShareScalarFieldEnum)[keyof typeof PasswordShareScalarFieldEnum]


  export const TemporaryPasswordShareScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    shareToken: 'shareToken',
    createdBy: 'createdBy',
    accessCount: 'accessCount',
    maxAccesses: 'maxAccesses',
    isOneTime: 'isOneTime',
    includeTotp: 'includeTotp',
    expiresAt: 'expiresAt',
    accessedAt: 'accessedAt',
    revokedAt: 'revokedAt',
    createdAt: 'createdAt'
  };

  export type TemporaryPasswordShareScalarFieldEnum = (typeof TemporaryPasswordShareScalarFieldEnum)[keyof typeof TemporaryPasswordShareScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    icon: 'icon',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PasswordTagScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type PasswordTagScalarFieldEnum = (typeof PasswordTagScalarFieldEnum)[keyof typeof PasswordTagScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AuditLogArchiveScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    archiveDate: 'archiveDate',
    startDate: 'startDate',
    endDate: 'endDate',
    logCount: 'logCount',
    filePath: 'filePath',
    fileSize: 'fileSize',
    archivedBy: 'archivedBy',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AuditLogArchiveScalarFieldEnum = (typeof AuditLogArchiveScalarFieldEnum)[keyof typeof AuditLogArchiveScalarFieldEnum]


  export const AuditLogSearchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    name: 'name',
    searchQuery: 'searchQuery',
    filters: 'filters',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type AuditLogSearchScalarFieldEnum = (typeof AuditLogSearchScalarFieldEnum)[keyof typeof AuditLogSearchScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const ThreatEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    threatType: 'threatType',
    severity: 'severity',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    details: 'details',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt'
  };

  export type ThreatEventScalarFieldEnum = (typeof ThreatEventScalarFieldEnum)[keyof typeof ThreatEventScalarFieldEnum]


  export const RateLimitScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    identifierType: 'identifierType',
    action: 'action',
    count: 'count',
    windowStart: 'windowStart',
    windowEnd: 'windowEnd',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RateLimitScalarFieldEnum = (typeof RateLimitScalarFieldEnum)[keyof typeof RateLimitScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const MfaCredentialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    credentialId: 'credentialId',
    publicKey: 'publicKey',
    counter: 'counter',
    deviceType: 'deviceType',
    backedUp: 'backedUp',
    transports: 'transports',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type MfaCredentialScalarFieldEnum = (typeof MfaCredentialScalarFieldEnum)[keyof typeof MfaCredentialScalarFieldEnum]


  export const RecoveryCodeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    codeHash: 'codeHash',
    used: 'used',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type RecoveryCodeScalarFieldEnum = (typeof RecoveryCodeScalarFieldEnum)[keyof typeof RecoveryCodeScalarFieldEnum]


  export const SavedSearchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    query: 'query',
    folderIds: 'folderIds',
    tagIds: 'tagIds',
    filter: 'filter',
    searchFields: 'searchFields',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type SavedSearchScalarFieldEnum = (typeof SavedSearchScalarFieldEnum)[keyof typeof SavedSearchScalarFieldEnum]


  export const SearchHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    query: 'query',
    folderIds: 'folderIds',
    tagIds: 'tagIds',
    filter: 'filter',
    searchFields: 'searchFields',
    resultCount: 'resultCount',
    createdAt: 'createdAt'
  };

  export type SearchHistoryScalarFieldEnum = (typeof SearchHistoryScalarFieldEnum)[keyof typeof SearchHistoryScalarFieldEnum]


  export const PasswordTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    service: 'service',
    icon: 'icon',
    category: 'category',
    isSystem: 'isSystem',
    isPublic: 'isPublic',
    ownerId: 'ownerId',
    companyId: 'companyId',
    defaultFields: 'defaultFields',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordTemplateScalarFieldEnum = (typeof PasswordTemplateScalarFieldEnum)[keyof typeof PasswordTemplateScalarFieldEnum]


  export const EmailVerificationTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    email: 'email',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type EmailVerificationTokenScalarFieldEnum = (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    email: 'email',
    expiresAt: 'expiresAt',
    used: 'used',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const SecurityQuestionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    question: 'question',
    answerHash: 'answerHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityQuestionScalarFieldEnum = (typeof SecurityQuestionScalarFieldEnum)[keyof typeof SecurityQuestionScalarFieldEnum]


  export const IpWhitelistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    ipAddress: 'ipAddress',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type IpWhitelistScalarFieldEnum = (typeof IpWhitelistScalarFieldEnum)[keyof typeof IpWhitelistScalarFieldEnum]


  export const GeographicRestrictionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    countryCode: 'countryCode',
    action: 'action',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type GeographicRestrictionScalarFieldEnum = (typeof GeographicRestrictionScalarFieldEnum)[keyof typeof GeographicRestrictionScalarFieldEnum]


  export const PasswordPolicyScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    minLength: 'minLength',
    requireUppercase: 'requireUppercase',
    requireLowercase: 'requireLowercase',
    requireNumbers: 'requireNumbers',
    requireSpecial: 'requireSpecial',
    expirationDays: 'expirationDays',
    preventReuseCount: 'preventReuseCount',
    requireChangeOnFirstLogin: 'requireChangeOnFirstLogin',
    requireChangeAfterDays: 'requireChangeAfterDays',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordPolicyScalarFieldEnum = (typeof PasswordPolicyScalarFieldEnum)[keyof typeof PasswordPolicyScalarFieldEnum]


  export const DataRetentionPolicyScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    auditLogRetentionDays: 'auditLogRetentionDays',
    passwordHistoryRetentionDays: 'passwordHistoryRetentionDays',
    sessionRetentionDays: 'sessionRetentionDays',
    deletedDataRetentionDays: 'deletedDataRetentionDays',
    autoDeleteEnabled: 'autoDeleteEnabled',
    lastCleanupAt: 'lastCleanupAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataRetentionPolicyScalarFieldEnum = (typeof DataRetentionPolicyScalarFieldEnum)[keyof typeof DataRetentionPolicyScalarFieldEnum]


  export const DataExportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    exportType: 'exportType',
    status: 'status',
    filePath: 'filePath',
    fileSize: 'fileSize',
    expiresAt: 'expiresAt',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage'
  };

  export type DataExportScalarFieldEnum = (typeof DataExportScalarFieldEnum)[keyof typeof DataExportScalarFieldEnum]


  export const DataDeletionRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    requestType: 'requestType',
    status: 'status',
    requestedAt: 'requestedAt',
    processedAt: 'processedAt',
    processedBy: 'processedBy',
    deletionScope: 'deletionScope',
    confirmationToken: 'confirmationToken',
    confirmedAt: 'confirmedAt',
    errorMessage: 'errorMessage'
  };

  export type DataDeletionRequestScalarFieldEnum = (typeof DataDeletionRequestScalarFieldEnum)[keyof typeof DataDeletionRequestScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    reportType: 'reportType',
    format: 'format',
    config: 'config',
    status: 'status',
    filePath: 'filePath',
    fileSize: 'fileSize',
    generatedAt: 'generatedAt',
    expiresAt: 'expiresAt',
    userId: 'userId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    templateId: 'templateId'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ReportTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    reportType: 'reportType',
    category: 'category',
    config: 'config',
    isSystem: 'isSystem',
    isPublic: 'isPublic',
    userId: 'userId',
    companyId: 'companyId',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportTemplateScalarFieldEnum = (typeof ReportTemplateScalarFieldEnum)[keyof typeof ReportTemplateScalarFieldEnum]


  export const ScheduledReportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    reportType: 'reportType',
    format: 'format',
    config: 'config',
    schedule: 'schedule',
    recipients: 'recipients',
    templateId: 'templateId',
    isActive: 'isActive',
    lastRunAt: 'lastRunAt',
    nextRunAt: 'nextRunAt',
    runCount: 'runCount',
    userId: 'userId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledReportScalarFieldEnum = (typeof ScheduledReportScalarFieldEnum)[keyof typeof ScheduledReportScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MfaMethod'
   */
  export type EnumMfaMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MfaMethod'>
    


  /**
   * Reference to a field of type 'MfaMethod[]'
   */
  export type ListEnumMfaMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MfaMethod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PasswordStrength'
   */
  export type EnumPasswordStrengthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PasswordStrength'>
    


  /**
   * Reference to a field of type 'PasswordStrength[]'
   */
  export type ListEnumPasswordStrengthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PasswordStrength[]'>
    


  /**
   * Reference to a field of type 'SharePermission'
   */
  export type EnumSharePermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SharePermission'>
    


  /**
   * Reference to a field of type 'SharePermission[]'
   */
  export type ListEnumSharePermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SharePermission[]'>
    


  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>
    


  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>
    


  /**
   * Reference to a field of type 'AuditStatus'
   */
  export type EnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus'>
    


  /**
   * Reference to a field of type 'AuditStatus[]'
   */
  export type ListEnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus[]'>
    


  /**
   * Reference to a field of type 'ThreatType'
   */
  export type EnumThreatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreatType'>
    


  /**
   * Reference to a field of type 'ThreatType[]'
   */
  export type ListEnumThreatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreatType[]'>
    


  /**
   * Reference to a field of type 'ThreatSeverity'
   */
  export type EnumThreatSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreatSeverity'>
    


  /**
   * Reference to a field of type 'ThreatSeverity[]'
   */
  export type ListEnumThreatSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreatSeverity[]'>
    


  /**
   * Reference to a field of type 'RateLimitType'
   */
  export type EnumRateLimitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RateLimitType'>
    


  /**
   * Reference to a field of type 'RateLimitType[]'
   */
  export type ListEnumRateLimitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RateLimitType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    subdomain?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    templates?: PasswordTemplateListRelationFilter
    ipWhitelists?: IpWhitelistListRelationFilter
    geographicRestrictions?: GeographicRestrictionListRelationFilter
    threatEvents?: ThreatEventListRelationFilter
    rateLimits?: RateLimitListRelationFilter
    passwordPolicy?: XOR<PasswordPolicyNullableScalarRelationFilter, PasswordPolicyWhereInput> | null
    dataRetentionPolicy?: XOR<DataRetentionPolicyNullableScalarRelationFilter, DataRetentionPolicyWhereInput> | null
    dataExports?: DataExportListRelationFilter
    dataDeletionRequests?: DataDeletionRequestListRelationFilter
    auditLogArchives?: AuditLogArchiveListRelationFilter
    auditLogSearches?: AuditLogSearchListRelationFilter
    reports?: ReportListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    templates?: PasswordTemplateOrderByRelationAggregateInput
    ipWhitelists?: IpWhitelistOrderByRelationAggregateInput
    geographicRestrictions?: GeographicRestrictionOrderByRelationAggregateInput
    threatEvents?: ThreatEventOrderByRelationAggregateInput
    rateLimits?: RateLimitOrderByRelationAggregateInput
    passwordPolicy?: PasswordPolicyOrderByWithRelationInput
    dataRetentionPolicy?: DataRetentionPolicyOrderByWithRelationInput
    dataExports?: DataExportOrderByRelationAggregateInput
    dataDeletionRequests?: DataDeletionRequestOrderByRelationAggregateInput
    auditLogArchives?: AuditLogArchiveOrderByRelationAggregateInput
    auditLogSearches?: AuditLogSearchOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    reportTemplates?: ReportTemplateOrderByRelationAggregateInput
    scheduledReports?: ScheduledReportOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    templates?: PasswordTemplateListRelationFilter
    ipWhitelists?: IpWhitelistListRelationFilter
    geographicRestrictions?: GeographicRestrictionListRelationFilter
    threatEvents?: ThreatEventListRelationFilter
    rateLimits?: RateLimitListRelationFilter
    passwordPolicy?: XOR<PasswordPolicyNullableScalarRelationFilter, PasswordPolicyWhereInput> | null
    dataRetentionPolicy?: XOR<DataRetentionPolicyNullableScalarRelationFilter, DataRetentionPolicyWhereInput> | null
    dataExports?: DataExportListRelationFilter
    dataDeletionRequests?: DataDeletionRequestListRelationFilter
    auditLogArchives?: AuditLogArchiveListRelationFilter
    auditLogSearches?: AuditLogSearchListRelationFilter
    reports?: ReportListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
  }, "id" | "subdomain">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    subdomain?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    ownedPasswords?: PasswordListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    threatEvents?: ThreatEventListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    mfaCredentials?: MfaCredentialListRelationFilter
    recoveryCodes?: RecoveryCodeListRelationFilter
    passwordHistory?: PasswordHistoryListRelationFilter
    passwordBreachesChecked?: PasswordBreachListRelationFilter
    passwordBreachesResolved?: PasswordBreachListRelationFilter
    rotationPolicies?: PasswordRotationPolicyListRelationFilter
    passwordRotations?: PasswordRotationListRelationFilter
    temporaryPasswordShares?: TemporaryPasswordShareListRelationFilter
    savedSearches?: SavedSearchListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    passwordTemplates?: PasswordTemplateListRelationFilter
    reports?: ReportListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    createdRoles?: RoleListRelationFilter
    dataExports?: DataExportListRelationFilter
    dataDeletionRequests?: DataDeletionRequestListRelationFilter
    processedDeletions?: DataDeletionRequestListRelationFilter
    auditLogArchives?: AuditLogArchiveListRelationFilter
    auditLogSearches?: AuditLogSearchListRelationFilter
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    securityQuestions?: SecurityQuestionListRelationFilter
    ipWhitelists?: IpWhitelistListRelationFilter
    geographicRestrictions?: GeographicRestrictionListRelationFilter
    createdIpWhitelists?: IpWhitelistListRelationFilter
    createdGeographicRestrictions?: GeographicRestrictionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryEmailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaMethod?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    ownedPasswords?: PasswordOrderByRelationAggregateInput
    sharedPasswords?: PasswordShareOrderByRelationAggregateInput
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    threatEvents?: ThreatEventOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    mfaCredentials?: MfaCredentialOrderByRelationAggregateInput
    recoveryCodes?: RecoveryCodeOrderByRelationAggregateInput
    passwordHistory?: PasswordHistoryOrderByRelationAggregateInput
    passwordBreachesChecked?: PasswordBreachOrderByRelationAggregateInput
    passwordBreachesResolved?: PasswordBreachOrderByRelationAggregateInput
    rotationPolicies?: PasswordRotationPolicyOrderByRelationAggregateInput
    passwordRotations?: PasswordRotationOrderByRelationAggregateInput
    temporaryPasswordShares?: TemporaryPasswordShareOrderByRelationAggregateInput
    savedSearches?: SavedSearchOrderByRelationAggregateInput
    searchHistory?: SearchHistoryOrderByRelationAggregateInput
    passwordTemplates?: PasswordTemplateOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    reportTemplates?: ReportTemplateOrderByRelationAggregateInput
    scheduledReports?: ScheduledReportOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    createdRoles?: RoleOrderByRelationAggregateInput
    dataExports?: DataExportOrderByRelationAggregateInput
    dataDeletionRequests?: DataDeletionRequestOrderByRelationAggregateInput
    processedDeletions?: DataDeletionRequestOrderByRelationAggregateInput
    auditLogArchives?: AuditLogArchiveOrderByRelationAggregateInput
    auditLogSearches?: AuditLogSearchOrderByRelationAggregateInput
    emailVerificationTokens?: EmailVerificationTokenOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    securityQuestions?: SecurityQuestionOrderByRelationAggregateInput
    ipWhitelists?: IpWhitelistOrderByRelationAggregateInput
    geographicRestrictions?: GeographicRestrictionOrderByRelationAggregateInput
    createdIpWhitelists?: IpWhitelistOrderByRelationAggregateInput
    createdGeographicRestrictions?: GeographicRestrictionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    ownedPasswords?: PasswordListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    threatEvents?: ThreatEventListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    mfaCredentials?: MfaCredentialListRelationFilter
    recoveryCodes?: RecoveryCodeListRelationFilter
    passwordHistory?: PasswordHistoryListRelationFilter
    passwordBreachesChecked?: PasswordBreachListRelationFilter
    passwordBreachesResolved?: PasswordBreachListRelationFilter
    rotationPolicies?: PasswordRotationPolicyListRelationFilter
    passwordRotations?: PasswordRotationListRelationFilter
    temporaryPasswordShares?: TemporaryPasswordShareListRelationFilter
    savedSearches?: SavedSearchListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    passwordTemplates?: PasswordTemplateListRelationFilter
    reports?: ReportListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    createdRoles?: RoleListRelationFilter
    dataExports?: DataExportListRelationFilter
    dataDeletionRequests?: DataDeletionRequestListRelationFilter
    processedDeletions?: DataDeletionRequestListRelationFilter
    auditLogArchives?: AuditLogArchiveListRelationFilter
    auditLogSearches?: AuditLogSearchListRelationFilter
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    securityQuestions?: SecurityQuestionListRelationFilter
    ipWhitelists?: IpWhitelistListRelationFilter
    geographicRestrictions?: GeographicRestrictionListRelationFilter
    createdIpWhitelists?: IpWhitelistListRelationFilter
    createdGeographicRestrictions?: GeographicRestrictionListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryEmailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaMethod?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"User">
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    mfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableWithAggregatesFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    deviceType?: StringNullableFilter<"Session"> | string | null
    deviceFingerprint?: StringNullableFilter<"Session"> | string | null
    isTrusted?: BoolFilter<"Session"> | boolean
    requireMfa?: BoolFilter<"Session"> | boolean
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    isTrusted?: SortOrder
    requireMfa?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    deviceType?: StringNullableFilter<"Session"> | string | null
    deviceFingerprint?: StringNullableFilter<"Session"> | string | null
    isTrusted?: BoolFilter<"Session"> | boolean
    requireMfa?: BoolFilter<"Session"> | boolean
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceFingerprint?: SortOrderInput | SortOrder
    isTrusted?: SortOrder
    requireMfa?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deviceFingerprint?: StringNullableWithAggregatesFilter<"Session"> | string | null
    isTrusted?: BoolWithAggregatesFilter<"Session"> | boolean
    requireMfa?: BoolWithAggregatesFilter<"Session"> | boolean
    lastActiveAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type PasswordWhereInput = {
    AND?: PasswordWhereInput | PasswordWhereInput[]
    OR?: PasswordWhereInput[]
    NOT?: PasswordWhereInput | PasswordWhereInput[]
    id?: StringFilter<"Password"> | string
    name?: StringFilter<"Password"> | string
    username?: StringFilter<"Password"> | string
    password?: StringFilter<"Password"> | string
    url?: StringNullableFilter<"Password"> | string | null
    notes?: StringNullableFilter<"Password"> | string | null
    folderId?: StringNullableFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"Password"> | boolean
    totpSecret?: StringNullableFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableFilter<"Password"> | Date | string | null
    isFavorite?: BoolFilter<"Password"> | boolean
    ownerId?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableFilter<"Password"> | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    sharedWith?: PasswordShareListRelationFilter
    temporaryShares?: TemporaryPasswordShareListRelationFilter
    tags?: PasswordTagListRelationFilter
    history?: PasswordHistoryListRelationFilter
    breaches?: PasswordBreachListRelationFilter
    rotations?: PasswordRotationListRelationFilter
    rotationPolicy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
  }

  export type PasswordOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
    folder?: FolderOrderByWithRelationInput
    sharedWith?: PasswordShareOrderByRelationAggregateInput
    temporaryShares?: TemporaryPasswordShareOrderByRelationAggregateInput
    tags?: PasswordTagOrderByRelationAggregateInput
    history?: PasswordHistoryOrderByRelationAggregateInput
    breaches?: PasswordBreachOrderByRelationAggregateInput
    rotations?: PasswordRotationOrderByRelationAggregateInput
    rotationPolicy?: PasswordRotationPolicyOrderByWithRelationInput
  }

  export type PasswordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordWhereInput | PasswordWhereInput[]
    OR?: PasswordWhereInput[]
    NOT?: PasswordWhereInput | PasswordWhereInput[]
    name?: StringFilter<"Password"> | string
    username?: StringFilter<"Password"> | string
    password?: StringFilter<"Password"> | string
    url?: StringNullableFilter<"Password"> | string | null
    notes?: StringNullableFilter<"Password"> | string | null
    folderId?: StringNullableFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"Password"> | boolean
    totpSecret?: StringNullableFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableFilter<"Password"> | Date | string | null
    isFavorite?: BoolFilter<"Password"> | boolean
    ownerId?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableFilter<"Password"> | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    sharedWith?: PasswordShareListRelationFilter
    temporaryShares?: TemporaryPasswordShareListRelationFilter
    tags?: PasswordTagListRelationFilter
    history?: PasswordHistoryListRelationFilter
    breaches?: PasswordBreachListRelationFilter
    rotations?: PasswordRotationListRelationFilter
    rotationPolicy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
  }, "id">

  export type PasswordOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrderInput | SortOrder
    _count?: PasswordCountOrderByAggregateInput
    _max?: PasswordMaxOrderByAggregateInput
    _min?: PasswordMinOrderByAggregateInput
  }

  export type PasswordScalarWhereWithAggregatesInput = {
    AND?: PasswordScalarWhereWithAggregatesInput | PasswordScalarWhereWithAggregatesInput[]
    OR?: PasswordScalarWhereWithAggregatesInput[]
    NOT?: PasswordScalarWhereWithAggregatesInput | PasswordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Password"> | string
    name?: StringWithAggregatesFilter<"Password"> | string
    username?: StringWithAggregatesFilter<"Password"> | string
    password?: StringWithAggregatesFilter<"Password"> | string
    url?: StringNullableWithAggregatesFilter<"Password"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Password"> | string | null
    folderId?: StringNullableWithAggregatesFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthWithAggregatesFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolWithAggregatesFilter<"Password"> | boolean
    totpSecret?: StringNullableWithAggregatesFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Password"> | Date | string | null
    isFavorite?: BoolWithAggregatesFilter<"Password"> | boolean
    ownerId?: StringWithAggregatesFilter<"Password"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Password"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableWithAggregatesFilter<"Password"> | string | null
  }

  export type PasswordHistoryWhereInput = {
    AND?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    OR?: PasswordHistoryWhereInput[]
    NOT?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    id?: StringFilter<"PasswordHistory"> | string
    passwordId?: StringFilter<"PasswordHistory"> | string
    name?: StringFilter<"PasswordHistory"> | string
    username?: StringFilter<"PasswordHistory"> | string
    password?: StringFilter<"PasswordHistory"> | string
    url?: StringNullableFilter<"PasswordHistory"> | string | null
    notes?: StringNullableFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringFilter<"PasswordHistory"> | string
    changeType?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
    passwordEntry?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    changedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordHistoryOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    passwordEntry?: PasswordOrderByWithRelationInput
    changedByUser?: UserOrderByWithRelationInput
  }

  export type PasswordHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    OR?: PasswordHistoryWhereInput[]
    NOT?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    passwordId?: StringFilter<"PasswordHistory"> | string
    name?: StringFilter<"PasswordHistory"> | string
    username?: StringFilter<"PasswordHistory"> | string
    password?: StringFilter<"PasswordHistory"> | string
    url?: StringNullableFilter<"PasswordHistory"> | string | null
    notes?: StringNullableFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringFilter<"PasswordHistory"> | string
    changeType?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
    passwordEntry?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    changedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordHistoryCountOrderByAggregateInput
    _max?: PasswordHistoryMaxOrderByAggregateInput
    _min?: PasswordHistoryMinOrderByAggregateInput
  }

  export type PasswordHistoryScalarWhereWithAggregatesInput = {
    AND?: PasswordHistoryScalarWhereWithAggregatesInput | PasswordHistoryScalarWhereWithAggregatesInput[]
    OR?: PasswordHistoryScalarWhereWithAggregatesInput[]
    NOT?: PasswordHistoryScalarWhereWithAggregatesInput | PasswordHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordHistory"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordHistory"> | string
    name?: StringWithAggregatesFilter<"PasswordHistory"> | string
    username?: StringWithAggregatesFilter<"PasswordHistory"> | string
    password?: StringWithAggregatesFilter<"PasswordHistory"> | string
    url?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthWithAggregatesFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolWithAggregatesFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringWithAggregatesFilter<"PasswordHistory"> | string
    changeType?: StringWithAggregatesFilter<"PasswordHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordHistory"> | Date | string
  }

  export type PasswordBreachWhereInput = {
    AND?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    OR?: PasswordBreachWhereInput[]
    NOT?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    id?: StringFilter<"PasswordBreach"> | string
    passwordId?: StringFilter<"PasswordBreach"> | string
    isBreached?: BoolFilter<"PasswordBreach"> | boolean
    breachCount?: IntFilter<"PasswordBreach"> | number
    hashPrefix?: StringFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringFilter<"PasswordBreach"> | string
    resolved?: BoolFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableFilter<"PasswordBreach"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    checkedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PasswordBreachOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    password?: PasswordOrderByWithRelationInput
    checkedByUser?: UserOrderByWithRelationInput
    resolvedByUser?: UserOrderByWithRelationInput
  }

  export type PasswordBreachWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    OR?: PasswordBreachWhereInput[]
    NOT?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    passwordId?: StringFilter<"PasswordBreach"> | string
    isBreached?: BoolFilter<"PasswordBreach"> | boolean
    breachCount?: IntFilter<"PasswordBreach"> | number
    hashPrefix?: StringFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringFilter<"PasswordBreach"> | string
    resolved?: BoolFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableFilter<"PasswordBreach"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    checkedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PasswordBreachOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    _count?: PasswordBreachCountOrderByAggregateInput
    _avg?: PasswordBreachAvgOrderByAggregateInput
    _max?: PasswordBreachMaxOrderByAggregateInput
    _min?: PasswordBreachMinOrderByAggregateInput
    _sum?: PasswordBreachSumOrderByAggregateInput
  }

  export type PasswordBreachScalarWhereWithAggregatesInput = {
    AND?: PasswordBreachScalarWhereWithAggregatesInput | PasswordBreachScalarWhereWithAggregatesInput[]
    OR?: PasswordBreachScalarWhereWithAggregatesInput[]
    NOT?: PasswordBreachScalarWhereWithAggregatesInput | PasswordBreachScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordBreach"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordBreach"> | string
    isBreached?: BoolWithAggregatesFilter<"PasswordBreach"> | boolean
    breachCount?: IntWithAggregatesFilter<"PasswordBreach"> | number
    hashPrefix?: StringWithAggregatesFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeWithAggregatesFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringWithAggregatesFilter<"PasswordBreach"> | string
    resolved?: BoolWithAggregatesFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"PasswordBreach"> | string | null
  }

  export type PasswordRotationPolicyWhereInput = {
    AND?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    OR?: PasswordRotationPolicyWhereInput[]
    NOT?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    id?: StringFilter<"PasswordRotationPolicy"> | string
    name?: StringFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    passwords?: PasswordListRelationFilter
    rotations?: PasswordRotationListRelationFilter
  }

  export type PasswordRotationPolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    passwords?: PasswordOrderByRelationAggregateInput
    rotations?: PasswordRotationOrderByRelationAggregateInput
  }

  export type PasswordRotationPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    OR?: PasswordRotationPolicyWhereInput[]
    NOT?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    name?: StringFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    passwords?: PasswordListRelationFilter
    rotations?: PasswordRotationListRelationFilter
  }, "id">

  export type PasswordRotationPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordRotationPolicyCountOrderByAggregateInput
    _avg?: PasswordRotationPolicyAvgOrderByAggregateInput
    _max?: PasswordRotationPolicyMaxOrderByAggregateInput
    _min?: PasswordRotationPolicyMinOrderByAggregateInput
    _sum?: PasswordRotationPolicySumOrderByAggregateInput
  }

  export type PasswordRotationPolicyScalarWhereWithAggregatesInput = {
    AND?: PasswordRotationPolicyScalarWhereWithAggregatesInput | PasswordRotationPolicyScalarWhereWithAggregatesInput[]
    OR?: PasswordRotationPolicyScalarWhereWithAggregatesInput[]
    NOT?: PasswordRotationPolicyScalarWhereWithAggregatesInput | PasswordRotationPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordRotationPolicy"> | string
    name?: StringWithAggregatesFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableWithAggregatesFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntWithAggregatesFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntWithAggregatesFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolWithAggregatesFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolWithAggregatesFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolWithAggregatesFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringWithAggregatesFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordRotationPolicy"> | Date | string
  }

  export type PasswordRotationWhereInput = {
    AND?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    OR?: PasswordRotationWhereInput[]
    NOT?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    id?: StringFilter<"PasswordRotation"> | string
    passwordId?: StringFilter<"PasswordRotation"> | string
    policyId?: StringNullableFilter<"PasswordRotation"> | string | null
    rotationType?: StringFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableFilter<"PasswordRotation"> | string | null
    newPassword?: StringFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    status?: StringFilter<"PasswordRotation"> | string
    notes?: StringNullableFilter<"PasswordRotation"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    policy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
    rotatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordRotationOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrderInput | SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrderInput | SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    password?: PasswordOrderByWithRelationInput
    policy?: PasswordRotationPolicyOrderByWithRelationInput
    rotatedByUser?: UserOrderByWithRelationInput
  }

  export type PasswordRotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    OR?: PasswordRotationWhereInput[]
    NOT?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    passwordId?: StringFilter<"PasswordRotation"> | string
    policyId?: StringNullableFilter<"PasswordRotation"> | string | null
    rotationType?: StringFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableFilter<"PasswordRotation"> | string | null
    newPassword?: StringFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    status?: StringFilter<"PasswordRotation"> | string
    notes?: StringNullableFilter<"PasswordRotation"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    policy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
    rotatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordRotationOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrderInput | SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrderInput | SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: PasswordRotationCountOrderByAggregateInput
    _max?: PasswordRotationMaxOrderByAggregateInput
    _min?: PasswordRotationMinOrderByAggregateInput
  }

  export type PasswordRotationScalarWhereWithAggregatesInput = {
    AND?: PasswordRotationScalarWhereWithAggregatesInput | PasswordRotationScalarWhereWithAggregatesInput[]
    OR?: PasswordRotationScalarWhereWithAggregatesInput[]
    NOT?: PasswordRotationScalarWhereWithAggregatesInput | PasswordRotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordRotation"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordRotation"> | string
    policyId?: StringNullableWithAggregatesFilter<"PasswordRotation"> | string | null
    rotationType?: StringWithAggregatesFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableWithAggregatesFilter<"PasswordRotation"> | string | null
    newPassword?: StringWithAggregatesFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeWithAggregatesFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringWithAggregatesFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PasswordRotation"> | Date | string | null
    status?: StringWithAggregatesFilter<"PasswordRotation"> | string
    notes?: StringNullableWithAggregatesFilter<"PasswordRotation"> | string | null
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    icon?: StringNullableFilter<"Folder"> | string | null
    color?: StringNullableFilter<"Folder"> | string | null
    parentId?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    passwords?: PasswordListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: FolderOrderByWithRelationInput
    children?: FolderOrderByRelationAggregateInput
    passwords?: PasswordOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    icon?: StringNullableFilter<"Folder"> | string | null
    color?: StringNullableFilter<"Folder"> | string | null
    parentId?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    passwords?: PasswordListRelationFilter
  }, "id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    description?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    color?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
  }

  export type PasswordShareWhereInput = {
    AND?: PasswordShareWhereInput | PasswordShareWhereInput[]
    OR?: PasswordShareWhereInput[]
    NOT?: PasswordShareWhereInput | PasswordShareWhereInput[]
    id?: StringFilter<"PasswordShare"> | string
    passwordId?: StringFilter<"PasswordShare"> | string
    userId?: StringNullableFilter<"PasswordShare"> | string | null
    teamId?: StringNullableFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PasswordShare"> | Date | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }

  export type PasswordShareOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    password?: PasswordOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type PasswordShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordShareWhereInput | PasswordShareWhereInput[]
    OR?: PasswordShareWhereInput[]
    NOT?: PasswordShareWhereInput | PasswordShareWhereInput[]
    passwordId?: StringFilter<"PasswordShare"> | string
    userId?: StringNullableFilter<"PasswordShare"> | string | null
    teamId?: StringNullableFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PasswordShare"> | Date | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }, "id">

  export type PasswordShareOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: PasswordShareCountOrderByAggregateInput
    _max?: PasswordShareMaxOrderByAggregateInput
    _min?: PasswordShareMinOrderByAggregateInput
  }

  export type PasswordShareScalarWhereWithAggregatesInput = {
    AND?: PasswordShareScalarWhereWithAggregatesInput | PasswordShareScalarWhereWithAggregatesInput[]
    OR?: PasswordShareScalarWhereWithAggregatesInput[]
    NOT?: PasswordShareScalarWhereWithAggregatesInput | PasswordShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordShare"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordShare"> | string
    userId?: StringNullableWithAggregatesFilter<"PasswordShare"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionWithAggregatesFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeWithAggregatesFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PasswordShare"> | Date | string | null
  }

  export type TemporaryPasswordShareWhereInput = {
    AND?: TemporaryPasswordShareWhereInput | TemporaryPasswordShareWhereInput[]
    OR?: TemporaryPasswordShareWhereInput[]
    NOT?: TemporaryPasswordShareWhereInput | TemporaryPasswordShareWhereInput[]
    id?: StringFilter<"TemporaryPasswordShare"> | string
    passwordId?: StringFilter<"TemporaryPasswordShare"> | string
    shareToken?: StringFilter<"TemporaryPasswordShare"> | string
    createdBy?: StringFilter<"TemporaryPasswordShare"> | string
    accessCount?: IntFilter<"TemporaryPasswordShare"> | number
    maxAccesses?: IntNullableFilter<"TemporaryPasswordShare"> | number | null
    isOneTime?: BoolFilter<"TemporaryPasswordShare"> | boolean
    includeTotp?: BoolFilter<"TemporaryPasswordShare"> | boolean
    expiresAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    accessedAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    createdAt?: DateTimeFilter<"TemporaryPasswordShare"> | Date | string
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TemporaryPasswordShareOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    shareToken?: SortOrder
    createdBy?: SortOrder
    accessCount?: SortOrder
    maxAccesses?: SortOrderInput | SortOrder
    isOneTime?: SortOrder
    includeTotp?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    accessedAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    password?: PasswordOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type TemporaryPasswordShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareToken?: string
    AND?: TemporaryPasswordShareWhereInput | TemporaryPasswordShareWhereInput[]
    OR?: TemporaryPasswordShareWhereInput[]
    NOT?: TemporaryPasswordShareWhereInput | TemporaryPasswordShareWhereInput[]
    passwordId?: StringFilter<"TemporaryPasswordShare"> | string
    createdBy?: StringFilter<"TemporaryPasswordShare"> | string
    accessCount?: IntFilter<"TemporaryPasswordShare"> | number
    maxAccesses?: IntNullableFilter<"TemporaryPasswordShare"> | number | null
    isOneTime?: BoolFilter<"TemporaryPasswordShare"> | boolean
    includeTotp?: BoolFilter<"TemporaryPasswordShare"> | boolean
    expiresAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    accessedAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    createdAt?: DateTimeFilter<"TemporaryPasswordShare"> | Date | string
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "shareToken">

  export type TemporaryPasswordShareOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    shareToken?: SortOrder
    createdBy?: SortOrder
    accessCount?: SortOrder
    maxAccesses?: SortOrderInput | SortOrder
    isOneTime?: SortOrder
    includeTotp?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    accessedAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TemporaryPasswordShareCountOrderByAggregateInput
    _avg?: TemporaryPasswordShareAvgOrderByAggregateInput
    _max?: TemporaryPasswordShareMaxOrderByAggregateInput
    _min?: TemporaryPasswordShareMinOrderByAggregateInput
    _sum?: TemporaryPasswordShareSumOrderByAggregateInput
  }

  export type TemporaryPasswordShareScalarWhereWithAggregatesInput = {
    AND?: TemporaryPasswordShareScalarWhereWithAggregatesInput | TemporaryPasswordShareScalarWhereWithAggregatesInput[]
    OR?: TemporaryPasswordShareScalarWhereWithAggregatesInput[]
    NOT?: TemporaryPasswordShareScalarWhereWithAggregatesInput | TemporaryPasswordShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemporaryPasswordShare"> | string
    passwordId?: StringWithAggregatesFilter<"TemporaryPasswordShare"> | string
    shareToken?: StringWithAggregatesFilter<"TemporaryPasswordShare"> | string
    createdBy?: StringWithAggregatesFilter<"TemporaryPasswordShare"> | string
    accessCount?: IntWithAggregatesFilter<"TemporaryPasswordShare"> | number
    maxAccesses?: IntNullableWithAggregatesFilter<"TemporaryPasswordShare"> | number | null
    isOneTime?: BoolWithAggregatesFilter<"TemporaryPasswordShare"> | boolean
    includeTotp?: BoolWithAggregatesFilter<"TemporaryPasswordShare"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TemporaryPasswordShare"> | Date | string | null
    accessedAt?: DateTimeNullableWithAggregatesFilter<"TemporaryPasswordShare"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"TemporaryPasswordShare"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TemporaryPasswordShare"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: TeamMemberListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: TeamMemberOrderByRelationAggregateInput
    sharedPasswords?: PasswordShareOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: TeamMemberListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: EnumTeamRoleWithAggregatesFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    icon?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    passwords?: PasswordTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    passwords?: PasswordTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    color?: StringNullableFilter<"Tag"> | string | null
    icon?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    passwords?: PasswordTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type PasswordTagWhereInput = {
    AND?: PasswordTagWhereInput | PasswordTagWhereInput[]
    OR?: PasswordTagWhereInput[]
    NOT?: PasswordTagWhereInput | PasswordTagWhereInput[]
    id?: StringFilter<"PasswordTag"> | string
    passwordId?: StringFilter<"PasswordTag"> | string
    tagId?: StringFilter<"PasswordTag"> | string
    createdAt?: DateTimeFilter<"PasswordTag"> | Date | string
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PasswordTagOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    password?: PasswordOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PasswordTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    passwordId_tagId?: PasswordTagPasswordIdTagIdCompoundUniqueInput
    AND?: PasswordTagWhereInput | PasswordTagWhereInput[]
    OR?: PasswordTagWhereInput[]
    NOT?: PasswordTagWhereInput | PasswordTagWhereInput[]
    passwordId?: StringFilter<"PasswordTag"> | string
    tagId?: StringFilter<"PasswordTag"> | string
    createdAt?: DateTimeFilter<"PasswordTag"> | Date | string
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "passwordId_tagId">

  export type PasswordTagOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordTagCountOrderByAggregateInput
    _max?: PasswordTagMaxOrderByAggregateInput
    _min?: PasswordTagMinOrderByAggregateInput
  }

  export type PasswordTagScalarWhereWithAggregatesInput = {
    AND?: PasswordTagScalarWhereWithAggregatesInput | PasswordTagScalarWhereWithAggregatesInput[]
    OR?: PasswordTagScalarWhereWithAggregatesInput[]
    NOT?: PasswordTagScalarWhereWithAggregatesInput | PasswordTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordTag"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordTag"> | string
    tagId?: StringWithAggregatesFilter<"PasswordTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordTag"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusWithAggregatesFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AuditLogArchiveWhereInput = {
    AND?: AuditLogArchiveWhereInput | AuditLogArchiveWhereInput[]
    OR?: AuditLogArchiveWhereInput[]
    NOT?: AuditLogArchiveWhereInput | AuditLogArchiveWhereInput[]
    id?: StringFilter<"AuditLogArchive"> | string
    companyId?: StringNullableFilter<"AuditLogArchive"> | string | null
    archiveDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    startDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    endDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    logCount?: IntFilter<"AuditLogArchive"> | number
    filePath?: StringNullableFilter<"AuditLogArchive"> | string | null
    fileSize?: IntNullableFilter<"AuditLogArchive"> | number | null
    archivedBy?: StringNullableFilter<"AuditLogArchive"> | string | null
    status?: StringFilter<"AuditLogArchive"> | string
    createdAt?: DateTimeFilter<"AuditLogArchive"> | Date | string
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    archiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogArchiveOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    archiveDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    logCount?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    archivedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    archiver?: UserOrderByWithRelationInput
  }

  export type AuditLogArchiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogArchiveWhereInput | AuditLogArchiveWhereInput[]
    OR?: AuditLogArchiveWhereInput[]
    NOT?: AuditLogArchiveWhereInput | AuditLogArchiveWhereInput[]
    companyId?: StringNullableFilter<"AuditLogArchive"> | string | null
    archiveDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    startDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    endDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    logCount?: IntFilter<"AuditLogArchive"> | number
    filePath?: StringNullableFilter<"AuditLogArchive"> | string | null
    fileSize?: IntNullableFilter<"AuditLogArchive"> | number | null
    archivedBy?: StringNullableFilter<"AuditLogArchive"> | string | null
    status?: StringFilter<"AuditLogArchive"> | string
    createdAt?: DateTimeFilter<"AuditLogArchive"> | Date | string
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    archiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogArchiveOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    archiveDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    logCount?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    archivedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogArchiveCountOrderByAggregateInput
    _avg?: AuditLogArchiveAvgOrderByAggregateInput
    _max?: AuditLogArchiveMaxOrderByAggregateInput
    _min?: AuditLogArchiveMinOrderByAggregateInput
    _sum?: AuditLogArchiveSumOrderByAggregateInput
  }

  export type AuditLogArchiveScalarWhereWithAggregatesInput = {
    AND?: AuditLogArchiveScalarWhereWithAggregatesInput | AuditLogArchiveScalarWhereWithAggregatesInput[]
    OR?: AuditLogArchiveScalarWhereWithAggregatesInput[]
    NOT?: AuditLogArchiveScalarWhereWithAggregatesInput | AuditLogArchiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLogArchive"> | string
    companyId?: StringNullableWithAggregatesFilter<"AuditLogArchive"> | string | null
    archiveDate?: DateTimeWithAggregatesFilter<"AuditLogArchive"> | Date | string
    startDate?: DateTimeWithAggregatesFilter<"AuditLogArchive"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AuditLogArchive"> | Date | string
    logCount?: IntWithAggregatesFilter<"AuditLogArchive"> | number
    filePath?: StringNullableWithAggregatesFilter<"AuditLogArchive"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"AuditLogArchive"> | number | null
    archivedBy?: StringNullableWithAggregatesFilter<"AuditLogArchive"> | string | null
    status?: StringWithAggregatesFilter<"AuditLogArchive"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLogArchive"> | Date | string
  }

  export type AuditLogSearchWhereInput = {
    AND?: AuditLogSearchWhereInput | AuditLogSearchWhereInput[]
    OR?: AuditLogSearchWhereInput[]
    NOT?: AuditLogSearchWhereInput | AuditLogSearchWhereInput[]
    id?: StringFilter<"AuditLogSearch"> | string
    userId?: StringFilter<"AuditLogSearch"> | string
    companyId?: StringNullableFilter<"AuditLogSearch"> | string | null
    name?: StringNullableFilter<"AuditLogSearch"> | string | null
    searchQuery?: StringFilter<"AuditLogSearch"> | string
    filters?: JsonNullableFilter<"AuditLogSearch">
    createdAt?: DateTimeFilter<"AuditLogSearch"> | Date | string
    lastUsedAt?: DateTimeFilter<"AuditLogSearch"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type AuditLogSearchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    searchQuery?: SortOrder
    filters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type AuditLogSearchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogSearchWhereInput | AuditLogSearchWhereInput[]
    OR?: AuditLogSearchWhereInput[]
    NOT?: AuditLogSearchWhereInput | AuditLogSearchWhereInput[]
    userId?: StringFilter<"AuditLogSearch"> | string
    companyId?: StringNullableFilter<"AuditLogSearch"> | string | null
    name?: StringNullableFilter<"AuditLogSearch"> | string | null
    searchQuery?: StringFilter<"AuditLogSearch"> | string
    filters?: JsonNullableFilter<"AuditLogSearch">
    createdAt?: DateTimeFilter<"AuditLogSearch"> | Date | string
    lastUsedAt?: DateTimeFilter<"AuditLogSearch"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type AuditLogSearchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    searchQuery?: SortOrder
    filters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    _count?: AuditLogSearchCountOrderByAggregateInput
    _max?: AuditLogSearchMaxOrderByAggregateInput
    _min?: AuditLogSearchMinOrderByAggregateInput
  }

  export type AuditLogSearchScalarWhereWithAggregatesInput = {
    AND?: AuditLogSearchScalarWhereWithAggregatesInput | AuditLogSearchScalarWhereWithAggregatesInput[]
    OR?: AuditLogSearchScalarWhereWithAggregatesInput[]
    NOT?: AuditLogSearchScalarWhereWithAggregatesInput | AuditLogSearchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLogSearch"> | string
    userId?: StringWithAggregatesFilter<"AuditLogSearch"> | string
    companyId?: StringNullableWithAggregatesFilter<"AuditLogSearch"> | string | null
    name?: StringNullableWithAggregatesFilter<"AuditLogSearch"> | string | null
    searchQuery?: StringWithAggregatesFilter<"AuditLogSearch"> | string
    filters?: JsonNullableWithAggregatesFilter<"AuditLogSearch">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLogSearch"> | Date | string
    lastUsedAt?: DateTimeWithAggregatesFilter<"AuditLogSearch"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    key?: StringFilter<"Settings"> | string
    value?: JsonFilter<"Settings">
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    value?: JsonFilter<"Settings">
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }, "id" | "key">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    key?: StringWithAggregatesFilter<"Settings"> | string
    value?: JsonWithAggregatesFilter<"Settings">
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type ThreatEventWhereInput = {
    AND?: ThreatEventWhereInput | ThreatEventWhereInput[]
    OR?: ThreatEventWhereInput[]
    NOT?: ThreatEventWhereInput | ThreatEventWhereInput[]
    id?: StringFilter<"ThreatEvent"> | string
    userId?: StringNullableFilter<"ThreatEvent"> | string | null
    companyId?: StringNullableFilter<"ThreatEvent"> | string | null
    threatType?: EnumThreatTypeFilter<"ThreatEvent"> | $Enums.ThreatType
    severity?: EnumThreatSeverityFilter<"ThreatEvent"> | $Enums.ThreatSeverity
    ipAddress?: StringNullableFilter<"ThreatEvent"> | string | null
    userAgent?: StringNullableFilter<"ThreatEvent"> | string | null
    details?: JsonNullableFilter<"ThreatEvent">
    isResolved?: BoolFilter<"ThreatEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ThreatEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ThreatEvent"> | string | null
    createdAt?: DateTimeFilter<"ThreatEvent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type ThreatEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ThreatEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThreatEventWhereInput | ThreatEventWhereInput[]
    OR?: ThreatEventWhereInput[]
    NOT?: ThreatEventWhereInput | ThreatEventWhereInput[]
    userId?: StringNullableFilter<"ThreatEvent"> | string | null
    companyId?: StringNullableFilter<"ThreatEvent"> | string | null
    threatType?: EnumThreatTypeFilter<"ThreatEvent"> | $Enums.ThreatType
    severity?: EnumThreatSeverityFilter<"ThreatEvent"> | $Enums.ThreatSeverity
    ipAddress?: StringNullableFilter<"ThreatEvent"> | string | null
    userAgent?: StringNullableFilter<"ThreatEvent"> | string | null
    details?: JsonNullableFilter<"ThreatEvent">
    isResolved?: BoolFilter<"ThreatEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ThreatEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ThreatEvent"> | string | null
    createdAt?: DateTimeFilter<"ThreatEvent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type ThreatEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ThreatEventCountOrderByAggregateInput
    _max?: ThreatEventMaxOrderByAggregateInput
    _min?: ThreatEventMinOrderByAggregateInput
  }

  export type ThreatEventScalarWhereWithAggregatesInput = {
    AND?: ThreatEventScalarWhereWithAggregatesInput | ThreatEventScalarWhereWithAggregatesInput[]
    OR?: ThreatEventScalarWhereWithAggregatesInput[]
    NOT?: ThreatEventScalarWhereWithAggregatesInput | ThreatEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThreatEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"ThreatEvent"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"ThreatEvent"> | string | null
    threatType?: EnumThreatTypeWithAggregatesFilter<"ThreatEvent"> | $Enums.ThreatType
    severity?: EnumThreatSeverityWithAggregatesFilter<"ThreatEvent"> | $Enums.ThreatSeverity
    ipAddress?: StringNullableWithAggregatesFilter<"ThreatEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ThreatEvent"> | string | null
    details?: JsonNullableWithAggregatesFilter<"ThreatEvent">
    isResolved?: BoolWithAggregatesFilter<"ThreatEvent"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ThreatEvent"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"ThreatEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ThreatEvent"> | Date | string
  }

  export type RateLimitWhereInput = {
    AND?: RateLimitWhereInput | RateLimitWhereInput[]
    OR?: RateLimitWhereInput[]
    NOT?: RateLimitWhereInput | RateLimitWhereInput[]
    id?: StringFilter<"RateLimit"> | string
    identifier?: StringFilter<"RateLimit"> | string
    identifierType?: EnumRateLimitTypeFilter<"RateLimit"> | $Enums.RateLimitType
    action?: StringFilter<"RateLimit"> | string
    count?: IntFilter<"RateLimit"> | number
    windowStart?: DateTimeFilter<"RateLimit"> | Date | string
    windowEnd?: DateTimeFilter<"RateLimit"> | Date | string
    companyId?: StringNullableFilter<"RateLimit"> | string | null
    createdAt?: DateTimeFilter<"RateLimit"> | Date | string
    updatedAt?: DateTimeFilter<"RateLimit"> | Date | string
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type RateLimitOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    identifierType?: SortOrder
    action?: SortOrder
    count?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type RateLimitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_identifierType_action_windowStart?: RateLimitIdentifierIdentifierTypeActionWindowStartCompoundUniqueInput
    AND?: RateLimitWhereInput | RateLimitWhereInput[]
    OR?: RateLimitWhereInput[]
    NOT?: RateLimitWhereInput | RateLimitWhereInput[]
    identifier?: StringFilter<"RateLimit"> | string
    identifierType?: EnumRateLimitTypeFilter<"RateLimit"> | $Enums.RateLimitType
    action?: StringFilter<"RateLimit"> | string
    count?: IntFilter<"RateLimit"> | number
    windowStart?: DateTimeFilter<"RateLimit"> | Date | string
    windowEnd?: DateTimeFilter<"RateLimit"> | Date | string
    companyId?: StringNullableFilter<"RateLimit"> | string | null
    createdAt?: DateTimeFilter<"RateLimit"> | Date | string
    updatedAt?: DateTimeFilter<"RateLimit"> | Date | string
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id" | "identifier_identifierType_action_windowStart">

  export type RateLimitOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    identifierType?: SortOrder
    action?: SortOrder
    count?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RateLimitCountOrderByAggregateInput
    _avg?: RateLimitAvgOrderByAggregateInput
    _max?: RateLimitMaxOrderByAggregateInput
    _min?: RateLimitMinOrderByAggregateInput
    _sum?: RateLimitSumOrderByAggregateInput
  }

  export type RateLimitScalarWhereWithAggregatesInput = {
    AND?: RateLimitScalarWhereWithAggregatesInput | RateLimitScalarWhereWithAggregatesInput[]
    OR?: RateLimitScalarWhereWithAggregatesInput[]
    NOT?: RateLimitScalarWhereWithAggregatesInput | RateLimitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RateLimit"> | string
    identifier?: StringWithAggregatesFilter<"RateLimit"> | string
    identifierType?: EnumRateLimitTypeWithAggregatesFilter<"RateLimit"> | $Enums.RateLimitType
    action?: StringWithAggregatesFilter<"RateLimit"> | string
    count?: IntWithAggregatesFilter<"RateLimit"> | number
    windowStart?: DateTimeWithAggregatesFilter<"RateLimit"> | Date | string
    windowEnd?: DateTimeWithAggregatesFilter<"RateLimit"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"RateLimit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RateLimit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RateLimit"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    createdById?: StringNullableFilter<"Role"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    permissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    permissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    createdById?: StringNullableFilter<"Role"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    permissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    key?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "key">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    key?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    category?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type MfaCredentialWhereInput = {
    AND?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    OR?: MfaCredentialWhereInput[]
    NOT?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    id?: StringFilter<"MfaCredential"> | string
    userId?: StringFilter<"MfaCredential"> | string
    credentialId?: StringFilter<"MfaCredential"> | string
    publicKey?: StringFilter<"MfaCredential"> | string
    counter?: BigIntFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableFilter<"MfaCredential"> | string | null
    backedUp?: BoolFilter<"MfaCredential"> | boolean
    transports?: StringNullableFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MfaCredential"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MfaCredentialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    backedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MfaCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    credentialId?: string
    AND?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    OR?: MfaCredentialWhereInput[]
    NOT?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    userId?: StringFilter<"MfaCredential"> | string
    publicKey?: StringFilter<"MfaCredential"> | string
    counter?: BigIntFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableFilter<"MfaCredential"> | string | null
    backedUp?: BoolFilter<"MfaCredential"> | boolean
    transports?: StringNullableFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MfaCredential"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "credentialId">

  export type MfaCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    backedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: MfaCredentialCountOrderByAggregateInput
    _avg?: MfaCredentialAvgOrderByAggregateInput
    _max?: MfaCredentialMaxOrderByAggregateInput
    _min?: MfaCredentialMinOrderByAggregateInput
    _sum?: MfaCredentialSumOrderByAggregateInput
  }

  export type MfaCredentialScalarWhereWithAggregatesInput = {
    AND?: MfaCredentialScalarWhereWithAggregatesInput | MfaCredentialScalarWhereWithAggregatesInput[]
    OR?: MfaCredentialScalarWhereWithAggregatesInput[]
    NOT?: MfaCredentialScalarWhereWithAggregatesInput | MfaCredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MfaCredential"> | string
    userId?: StringWithAggregatesFilter<"MfaCredential"> | string
    credentialId?: StringWithAggregatesFilter<"MfaCredential"> | string
    publicKey?: StringWithAggregatesFilter<"MfaCredential"> | string
    counter?: BigIntWithAggregatesFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableWithAggregatesFilter<"MfaCredential"> | string | null
    backedUp?: BoolWithAggregatesFilter<"MfaCredential"> | boolean
    transports?: StringNullableWithAggregatesFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"MfaCredential"> | Date | string | null
  }

  export type RecoveryCodeWhereInput = {
    AND?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    OR?: RecoveryCodeWhereInput[]
    NOT?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    id?: StringFilter<"RecoveryCode"> | string
    userId?: StringFilter<"RecoveryCode"> | string
    codeHash?: StringFilter<"RecoveryCode"> | string
    used?: BoolFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RecoveryCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RecoveryCodeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RecoveryCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    OR?: RecoveryCodeWhereInput[]
    NOT?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    userId?: StringFilter<"RecoveryCode"> | string
    codeHash?: StringFilter<"RecoveryCode"> | string
    used?: BoolFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RecoveryCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RecoveryCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RecoveryCodeCountOrderByAggregateInput
    _max?: RecoveryCodeMaxOrderByAggregateInput
    _min?: RecoveryCodeMinOrderByAggregateInput
  }

  export type RecoveryCodeScalarWhereWithAggregatesInput = {
    AND?: RecoveryCodeScalarWhereWithAggregatesInput | RecoveryCodeScalarWhereWithAggregatesInput[]
    OR?: RecoveryCodeScalarWhereWithAggregatesInput[]
    NOT?: RecoveryCodeScalarWhereWithAggregatesInput | RecoveryCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecoveryCode"> | string
    userId?: StringWithAggregatesFilter<"RecoveryCode"> | string
    codeHash?: StringWithAggregatesFilter<"RecoveryCode"> | string
    used?: BoolWithAggregatesFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecoveryCode"> | Date | string
  }

  export type SavedSearchWhereInput = {
    AND?: SavedSearchWhereInput | SavedSearchWhereInput[]
    OR?: SavedSearchWhereInput[]
    NOT?: SavedSearchWhereInput | SavedSearchWhereInput[]
    id?: StringFilter<"SavedSearch"> | string
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    query?: StringNullableFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SavedSearch"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SavedSearchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SavedSearchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedSearchWhereInput | SavedSearchWhereInput[]
    OR?: SavedSearchWhereInput[]
    NOT?: SavedSearchWhereInput | SavedSearchWhereInput[]
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    query?: StringNullableFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SavedSearch"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SavedSearchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: SavedSearchCountOrderByAggregateInput
    _max?: SavedSearchMaxOrderByAggregateInput
    _min?: SavedSearchMinOrderByAggregateInput
  }

  export type SavedSearchScalarWhereWithAggregatesInput = {
    AND?: SavedSearchScalarWhereWithAggregatesInput | SavedSearchScalarWhereWithAggregatesInput[]
    OR?: SavedSearchScalarWhereWithAggregatesInput[]
    NOT?: SavedSearchScalarWhereWithAggregatesInput | SavedSearchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedSearch"> | string
    userId?: StringWithAggregatesFilter<"SavedSearch"> | string
    name?: StringWithAggregatesFilter<"SavedSearch"> | string
    query?: StringNullableWithAggregatesFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableWithAggregatesFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeWithAggregatesFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"SavedSearch"> | Date | string | null
  }

  export type SearchHistoryWhereInput = {
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringNullableFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SearchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    resultCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringNullableFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SearchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    resultCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SearchHistoryCountOrderByAggregateInput
    _avg?: SearchHistoryAvgOrderByAggregateInput
    _max?: SearchHistoryMaxOrderByAggregateInput
    _min?: SearchHistoryMinOrderByAggregateInput
    _sum?: SearchHistorySumOrderByAggregateInput
  }

  export type SearchHistoryScalarWhereWithAggregatesInput = {
    AND?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    OR?: SearchHistoryScalarWhereWithAggregatesInput[]
    NOT?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchHistory"> | string
    userId?: StringWithAggregatesFilter<"SearchHistory"> | string
    query?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableWithAggregatesFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
  }

  export type PasswordTemplateWhereInput = {
    AND?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    OR?: PasswordTemplateWhereInput[]
    NOT?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    id?: StringFilter<"PasswordTemplate"> | string
    name?: StringFilter<"PasswordTemplate"> | string
    description?: StringNullableFilter<"PasswordTemplate"> | string | null
    service?: StringNullableFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableFilter<"PasswordTemplate"> | string | null
    category?: StringNullableFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonFilter<"PasswordTemplate">
    usageCount?: IntFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type PasswordTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    defaultFields?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type PasswordTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    OR?: PasswordTemplateWhereInput[]
    NOT?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    name?: StringFilter<"PasswordTemplate"> | string
    description?: StringNullableFilter<"PasswordTemplate"> | string | null
    service?: StringNullableFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableFilter<"PasswordTemplate"> | string | null
    category?: StringNullableFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonFilter<"PasswordTemplate">
    usageCount?: IntFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type PasswordTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    defaultFields?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordTemplateCountOrderByAggregateInput
    _avg?: PasswordTemplateAvgOrderByAggregateInput
    _max?: PasswordTemplateMaxOrderByAggregateInput
    _min?: PasswordTemplateMinOrderByAggregateInput
    _sum?: PasswordTemplateSumOrderByAggregateInput
  }

  export type PasswordTemplateScalarWhereWithAggregatesInput = {
    AND?: PasswordTemplateScalarWhereWithAggregatesInput | PasswordTemplateScalarWhereWithAggregatesInput[]
    OR?: PasswordTemplateScalarWhereWithAggregatesInput[]
    NOT?: PasswordTemplateScalarWhereWithAggregatesInput | PasswordTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordTemplate"> | string
    name?: StringWithAggregatesFilter<"PasswordTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    service?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    category?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolWithAggregatesFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolWithAggregatesFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonWithAggregatesFilter<"PasswordTemplate">
    usageCount?: IntWithAggregatesFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordTemplate"> | Date | string
  }

  export type EmailVerificationTokenWhereInput = {
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    OR?: EmailVerificationTokenWhereInput[]
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    id?: StringFilter<"EmailVerificationToken"> | string
    token?: StringFilter<"EmailVerificationToken"> | string
    userId?: StringFilter<"EmailVerificationToken"> | string
    email?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailVerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailVerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    OR?: EmailVerificationTokenWhereInput[]
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    userId?: StringFilter<"EmailVerificationToken"> | string
    email?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type EmailVerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: EmailVerificationTokenCountOrderByAggregateInput
    _max?: EmailVerificationTokenMaxOrderByAggregateInput
    _min?: EmailVerificationTokenMinOrderByAggregateInput
  }

  export type EmailVerificationTokenScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[]
    OR?: EmailVerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    token?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    userId?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    email?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    used?: BoolWithAggregatesFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type SecurityQuestionWhereInput = {
    AND?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    OR?: SecurityQuestionWhereInput[]
    NOT?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    id?: StringFilter<"SecurityQuestion"> | string
    userId?: StringFilter<"SecurityQuestion"> | string
    question?: StringFilter<"SecurityQuestion"> | string
    answerHash?: StringFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SecurityQuestionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SecurityQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    OR?: SecurityQuestionWhereInput[]
    NOT?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    userId?: StringFilter<"SecurityQuestion"> | string
    question?: StringFilter<"SecurityQuestion"> | string
    answerHash?: StringFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SecurityQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityQuestionCountOrderByAggregateInput
    _max?: SecurityQuestionMaxOrderByAggregateInput
    _min?: SecurityQuestionMinOrderByAggregateInput
  }

  export type SecurityQuestionScalarWhereWithAggregatesInput = {
    AND?: SecurityQuestionScalarWhereWithAggregatesInput | SecurityQuestionScalarWhereWithAggregatesInput[]
    OR?: SecurityQuestionScalarWhereWithAggregatesInput[]
    NOT?: SecurityQuestionScalarWhereWithAggregatesInput | SecurityQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    userId?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    question?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    answerHash?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityQuestion"> | Date | string
  }

  export type IpWhitelistWhereInput = {
    AND?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    OR?: IpWhitelistWhereInput[]
    NOT?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    id?: StringFilter<"IpWhitelist"> | string
    userId?: StringNullableFilter<"IpWhitelist"> | string | null
    companyId?: StringNullableFilter<"IpWhitelist"> | string | null
    ipAddress?: StringFilter<"IpWhitelist"> | string
    description?: StringNullableFilter<"IpWhitelist"> | string | null
    isActive?: BoolFilter<"IpWhitelist"> | boolean
    createdAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    updatedAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    createdById?: StringNullableFilter<"IpWhitelist"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type IpWhitelistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type IpWhitelistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    OR?: IpWhitelistWhereInput[]
    NOT?: IpWhitelistWhereInput | IpWhitelistWhereInput[]
    userId?: StringNullableFilter<"IpWhitelist"> | string | null
    companyId?: StringNullableFilter<"IpWhitelist"> | string | null
    ipAddress?: StringFilter<"IpWhitelist"> | string
    description?: StringNullableFilter<"IpWhitelist"> | string | null
    isActive?: BoolFilter<"IpWhitelist"> | boolean
    createdAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    updatedAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    createdById?: StringNullableFilter<"IpWhitelist"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type IpWhitelistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: IpWhitelistCountOrderByAggregateInput
    _max?: IpWhitelistMaxOrderByAggregateInput
    _min?: IpWhitelistMinOrderByAggregateInput
  }

  export type IpWhitelistScalarWhereWithAggregatesInput = {
    AND?: IpWhitelistScalarWhereWithAggregatesInput | IpWhitelistScalarWhereWithAggregatesInput[]
    OR?: IpWhitelistScalarWhereWithAggregatesInput[]
    NOT?: IpWhitelistScalarWhereWithAggregatesInput | IpWhitelistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IpWhitelist"> | string
    userId?: StringNullableWithAggregatesFilter<"IpWhitelist"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"IpWhitelist"> | string | null
    ipAddress?: StringWithAggregatesFilter<"IpWhitelist"> | string
    description?: StringNullableWithAggregatesFilter<"IpWhitelist"> | string | null
    isActive?: BoolWithAggregatesFilter<"IpWhitelist"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"IpWhitelist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IpWhitelist"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"IpWhitelist"> | string | null
  }

  export type GeographicRestrictionWhereInput = {
    AND?: GeographicRestrictionWhereInput | GeographicRestrictionWhereInput[]
    OR?: GeographicRestrictionWhereInput[]
    NOT?: GeographicRestrictionWhereInput | GeographicRestrictionWhereInput[]
    id?: StringFilter<"GeographicRestriction"> | string
    userId?: StringNullableFilter<"GeographicRestriction"> | string | null
    companyId?: StringNullableFilter<"GeographicRestriction"> | string | null
    countryCode?: StringFilter<"GeographicRestriction"> | string
    action?: StringFilter<"GeographicRestriction"> | string
    isActive?: BoolFilter<"GeographicRestriction"> | boolean
    createdAt?: DateTimeFilter<"GeographicRestriction"> | Date | string
    updatedAt?: DateTimeFilter<"GeographicRestriction"> | Date | string
    createdById?: StringNullableFilter<"GeographicRestriction"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GeographicRestrictionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    action?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type GeographicRestrictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GeographicRestrictionWhereInput | GeographicRestrictionWhereInput[]
    OR?: GeographicRestrictionWhereInput[]
    NOT?: GeographicRestrictionWhereInput | GeographicRestrictionWhereInput[]
    userId?: StringNullableFilter<"GeographicRestriction"> | string | null
    companyId?: StringNullableFilter<"GeographicRestriction"> | string | null
    countryCode?: StringFilter<"GeographicRestriction"> | string
    action?: StringFilter<"GeographicRestriction"> | string
    isActive?: BoolFilter<"GeographicRestriction"> | boolean
    createdAt?: DateTimeFilter<"GeographicRestriction"> | Date | string
    updatedAt?: DateTimeFilter<"GeographicRestriction"> | Date | string
    createdById?: StringNullableFilter<"GeographicRestriction"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type GeographicRestrictionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    action?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: GeographicRestrictionCountOrderByAggregateInput
    _max?: GeographicRestrictionMaxOrderByAggregateInput
    _min?: GeographicRestrictionMinOrderByAggregateInput
  }

  export type GeographicRestrictionScalarWhereWithAggregatesInput = {
    AND?: GeographicRestrictionScalarWhereWithAggregatesInput | GeographicRestrictionScalarWhereWithAggregatesInput[]
    OR?: GeographicRestrictionScalarWhereWithAggregatesInput[]
    NOT?: GeographicRestrictionScalarWhereWithAggregatesInput | GeographicRestrictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeographicRestriction"> | string
    userId?: StringNullableWithAggregatesFilter<"GeographicRestriction"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"GeographicRestriction"> | string | null
    countryCode?: StringWithAggregatesFilter<"GeographicRestriction"> | string
    action?: StringWithAggregatesFilter<"GeographicRestriction"> | string
    isActive?: BoolWithAggregatesFilter<"GeographicRestriction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GeographicRestriction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GeographicRestriction"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"GeographicRestriction"> | string | null
  }

  export type PasswordPolicyWhereInput = {
    AND?: PasswordPolicyWhereInput | PasswordPolicyWhereInput[]
    OR?: PasswordPolicyWhereInput[]
    NOT?: PasswordPolicyWhereInput | PasswordPolicyWhereInput[]
    id?: StringFilter<"PasswordPolicy"> | string
    companyId?: StringFilter<"PasswordPolicy"> | string
    minLength?: IntFilter<"PasswordPolicy"> | number
    requireUppercase?: BoolFilter<"PasswordPolicy"> | boolean
    requireLowercase?: BoolFilter<"PasswordPolicy"> | boolean
    requireNumbers?: BoolFilter<"PasswordPolicy"> | boolean
    requireSpecial?: BoolFilter<"PasswordPolicy"> | boolean
    expirationDays?: IntNullableFilter<"PasswordPolicy"> | number | null
    preventReuseCount?: IntFilter<"PasswordPolicy"> | number
    requireChangeOnFirstLogin?: BoolFilter<"PasswordPolicy"> | boolean
    requireChangeAfterDays?: IntNullableFilter<"PasswordPolicy"> | number | null
    isActive?: BoolFilter<"PasswordPolicy"> | boolean
    createdAt?: DateTimeFilter<"PasswordPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordPolicy"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type PasswordPolicyOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    minLength?: SortOrder
    requireUppercase?: SortOrder
    requireLowercase?: SortOrder
    requireNumbers?: SortOrder
    requireSpecial?: SortOrder
    expirationDays?: SortOrderInput | SortOrder
    preventReuseCount?: SortOrder
    requireChangeOnFirstLogin?: SortOrder
    requireChangeAfterDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type PasswordPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId?: string
    AND?: PasswordPolicyWhereInput | PasswordPolicyWhereInput[]
    OR?: PasswordPolicyWhereInput[]
    NOT?: PasswordPolicyWhereInput | PasswordPolicyWhereInput[]
    minLength?: IntFilter<"PasswordPolicy"> | number
    requireUppercase?: BoolFilter<"PasswordPolicy"> | boolean
    requireLowercase?: BoolFilter<"PasswordPolicy"> | boolean
    requireNumbers?: BoolFilter<"PasswordPolicy"> | boolean
    requireSpecial?: BoolFilter<"PasswordPolicy"> | boolean
    expirationDays?: IntNullableFilter<"PasswordPolicy"> | number | null
    preventReuseCount?: IntFilter<"PasswordPolicy"> | number
    requireChangeOnFirstLogin?: BoolFilter<"PasswordPolicy"> | boolean
    requireChangeAfterDays?: IntNullableFilter<"PasswordPolicy"> | number | null
    isActive?: BoolFilter<"PasswordPolicy"> | boolean
    createdAt?: DateTimeFilter<"PasswordPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordPolicy"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId">

  export type PasswordPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    minLength?: SortOrder
    requireUppercase?: SortOrder
    requireLowercase?: SortOrder
    requireNumbers?: SortOrder
    requireSpecial?: SortOrder
    expirationDays?: SortOrderInput | SortOrder
    preventReuseCount?: SortOrder
    requireChangeOnFirstLogin?: SortOrder
    requireChangeAfterDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordPolicyCountOrderByAggregateInput
    _avg?: PasswordPolicyAvgOrderByAggregateInput
    _max?: PasswordPolicyMaxOrderByAggregateInput
    _min?: PasswordPolicyMinOrderByAggregateInput
    _sum?: PasswordPolicySumOrderByAggregateInput
  }

  export type PasswordPolicyScalarWhereWithAggregatesInput = {
    AND?: PasswordPolicyScalarWhereWithAggregatesInput | PasswordPolicyScalarWhereWithAggregatesInput[]
    OR?: PasswordPolicyScalarWhereWithAggregatesInput[]
    NOT?: PasswordPolicyScalarWhereWithAggregatesInput | PasswordPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordPolicy"> | string
    companyId?: StringWithAggregatesFilter<"PasswordPolicy"> | string
    minLength?: IntWithAggregatesFilter<"PasswordPolicy"> | number
    requireUppercase?: BoolWithAggregatesFilter<"PasswordPolicy"> | boolean
    requireLowercase?: BoolWithAggregatesFilter<"PasswordPolicy"> | boolean
    requireNumbers?: BoolWithAggregatesFilter<"PasswordPolicy"> | boolean
    requireSpecial?: BoolWithAggregatesFilter<"PasswordPolicy"> | boolean
    expirationDays?: IntNullableWithAggregatesFilter<"PasswordPolicy"> | number | null
    preventReuseCount?: IntWithAggregatesFilter<"PasswordPolicy"> | number
    requireChangeOnFirstLogin?: BoolWithAggregatesFilter<"PasswordPolicy"> | boolean
    requireChangeAfterDays?: IntNullableWithAggregatesFilter<"PasswordPolicy"> | number | null
    isActive?: BoolWithAggregatesFilter<"PasswordPolicy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PasswordPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordPolicy"> | Date | string
  }

  export type DataRetentionPolicyWhereInput = {
    AND?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    OR?: DataRetentionPolicyWhereInput[]
    NOT?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    id?: StringFilter<"DataRetentionPolicy"> | string
    companyId?: StringFilter<"DataRetentionPolicy"> | string
    auditLogRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    passwordHistoryRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    sessionRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    deletedDataRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    autoDeleteEnabled?: BoolFilter<"DataRetentionPolicy"> | boolean
    lastCleanupAt?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
    isActive?: BoolFilter<"DataRetentionPolicy"> | boolean
    createdAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DataRetentionPolicyOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    auditLogRetentionDays?: SortOrderInput | SortOrder
    passwordHistoryRetentionDays?: SortOrderInput | SortOrder
    sessionRetentionDays?: SortOrderInput | SortOrder
    deletedDataRetentionDays?: SortOrderInput | SortOrder
    autoDeleteEnabled?: SortOrder
    lastCleanupAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DataRetentionPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId?: string
    AND?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    OR?: DataRetentionPolicyWhereInput[]
    NOT?: DataRetentionPolicyWhereInput | DataRetentionPolicyWhereInput[]
    auditLogRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    passwordHistoryRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    sessionRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    deletedDataRetentionDays?: IntNullableFilter<"DataRetentionPolicy"> | number | null
    autoDeleteEnabled?: BoolFilter<"DataRetentionPolicy"> | boolean
    lastCleanupAt?: DateTimeNullableFilter<"DataRetentionPolicy"> | Date | string | null
    isActive?: BoolFilter<"DataRetentionPolicy"> | boolean
    createdAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"DataRetentionPolicy"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId">

  export type DataRetentionPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    auditLogRetentionDays?: SortOrderInput | SortOrder
    passwordHistoryRetentionDays?: SortOrderInput | SortOrder
    sessionRetentionDays?: SortOrderInput | SortOrder
    deletedDataRetentionDays?: SortOrderInput | SortOrder
    autoDeleteEnabled?: SortOrder
    lastCleanupAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataRetentionPolicyCountOrderByAggregateInput
    _avg?: DataRetentionPolicyAvgOrderByAggregateInput
    _max?: DataRetentionPolicyMaxOrderByAggregateInput
    _min?: DataRetentionPolicyMinOrderByAggregateInput
    _sum?: DataRetentionPolicySumOrderByAggregateInput
  }

  export type DataRetentionPolicyScalarWhereWithAggregatesInput = {
    AND?: DataRetentionPolicyScalarWhereWithAggregatesInput | DataRetentionPolicyScalarWhereWithAggregatesInput[]
    OR?: DataRetentionPolicyScalarWhereWithAggregatesInput[]
    NOT?: DataRetentionPolicyScalarWhereWithAggregatesInput | DataRetentionPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataRetentionPolicy"> | string
    companyId?: StringWithAggregatesFilter<"DataRetentionPolicy"> | string
    auditLogRetentionDays?: IntNullableWithAggregatesFilter<"DataRetentionPolicy"> | number | null
    passwordHistoryRetentionDays?: IntNullableWithAggregatesFilter<"DataRetentionPolicy"> | number | null
    sessionRetentionDays?: IntNullableWithAggregatesFilter<"DataRetentionPolicy"> | number | null
    deletedDataRetentionDays?: IntNullableWithAggregatesFilter<"DataRetentionPolicy"> | number | null
    autoDeleteEnabled?: BoolWithAggregatesFilter<"DataRetentionPolicy"> | boolean
    lastCleanupAt?: DateTimeNullableWithAggregatesFilter<"DataRetentionPolicy"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"DataRetentionPolicy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DataRetentionPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataRetentionPolicy"> | Date | string
  }

  export type DataExportWhereInput = {
    AND?: DataExportWhereInput | DataExportWhereInput[]
    OR?: DataExportWhereInput[]
    NOT?: DataExportWhereInput | DataExportWhereInput[]
    id?: StringFilter<"DataExport"> | string
    userId?: StringFilter<"DataExport"> | string
    companyId?: StringNullableFilter<"DataExport"> | string | null
    exportType?: StringFilter<"DataExport"> | string
    status?: StringFilter<"DataExport"> | string
    filePath?: StringNullableFilter<"DataExport"> | string | null
    fileSize?: IntNullableFilter<"DataExport"> | number | null
    expiresAt?: DateTimeNullableFilter<"DataExport"> | Date | string | null
    requestedAt?: DateTimeFilter<"DataExport"> | Date | string
    completedAt?: DateTimeNullableFilter<"DataExport"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataExport"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type DataExportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    exportType?: SortOrder
    status?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DataExportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataExportWhereInput | DataExportWhereInput[]
    OR?: DataExportWhereInput[]
    NOT?: DataExportWhereInput | DataExportWhereInput[]
    userId?: StringFilter<"DataExport"> | string
    companyId?: StringNullableFilter<"DataExport"> | string | null
    exportType?: StringFilter<"DataExport"> | string
    status?: StringFilter<"DataExport"> | string
    filePath?: StringNullableFilter<"DataExport"> | string | null
    fileSize?: IntNullableFilter<"DataExport"> | number | null
    expiresAt?: DateTimeNullableFilter<"DataExport"> | Date | string | null
    requestedAt?: DateTimeFilter<"DataExport"> | Date | string
    completedAt?: DateTimeNullableFilter<"DataExport"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataExport"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type DataExportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    exportType?: SortOrder
    status?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: DataExportCountOrderByAggregateInput
    _avg?: DataExportAvgOrderByAggregateInput
    _max?: DataExportMaxOrderByAggregateInput
    _min?: DataExportMinOrderByAggregateInput
    _sum?: DataExportSumOrderByAggregateInput
  }

  export type DataExportScalarWhereWithAggregatesInput = {
    AND?: DataExportScalarWhereWithAggregatesInput | DataExportScalarWhereWithAggregatesInput[]
    OR?: DataExportScalarWhereWithAggregatesInput[]
    NOT?: DataExportScalarWhereWithAggregatesInput | DataExportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataExport"> | string
    userId?: StringWithAggregatesFilter<"DataExport"> | string
    companyId?: StringNullableWithAggregatesFilter<"DataExport"> | string | null
    exportType?: StringWithAggregatesFilter<"DataExport"> | string
    status?: StringWithAggregatesFilter<"DataExport"> | string
    filePath?: StringNullableWithAggregatesFilter<"DataExport"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"DataExport"> | number | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DataExport"> | Date | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"DataExport"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"DataExport"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"DataExport"> | string | null
  }

  export type DataDeletionRequestWhereInput = {
    AND?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    OR?: DataDeletionRequestWhereInput[]
    NOT?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    id?: StringFilter<"DataDeletionRequest"> | string
    userId?: StringFilter<"DataDeletionRequest"> | string
    companyId?: StringNullableFilter<"DataDeletionRequest"> | string | null
    requestType?: StringFilter<"DataDeletionRequest"> | string
    status?: StringFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    processedBy?: StringNullableFilter<"DataDeletionRequest"> | string | null
    deletionScope?: JsonNullableFilter<"DataDeletionRequest">
    confirmationToken?: StringFilter<"DataDeletionRequest"> | string
    confirmedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataDeletionRequest"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    processor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DataDeletionRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    requestType?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    deletionScope?: SortOrderInput | SortOrder
    confirmationToken?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    processor?: UserOrderByWithRelationInput
  }

  export type DataDeletionRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    confirmationToken?: string
    AND?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    OR?: DataDeletionRequestWhereInput[]
    NOT?: DataDeletionRequestWhereInput | DataDeletionRequestWhereInput[]
    userId?: StringFilter<"DataDeletionRequest"> | string
    companyId?: StringNullableFilter<"DataDeletionRequest"> | string | null
    requestType?: StringFilter<"DataDeletionRequest"> | string
    status?: StringFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    processedBy?: StringNullableFilter<"DataDeletionRequest"> | string | null
    deletionScope?: JsonNullableFilter<"DataDeletionRequest">
    confirmedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataDeletionRequest"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    processor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "confirmationToken">

  export type DataDeletionRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    requestType?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    deletionScope?: SortOrderInput | SortOrder
    confirmationToken?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: DataDeletionRequestCountOrderByAggregateInput
    _max?: DataDeletionRequestMaxOrderByAggregateInput
    _min?: DataDeletionRequestMinOrderByAggregateInput
  }

  export type DataDeletionRequestScalarWhereWithAggregatesInput = {
    AND?: DataDeletionRequestScalarWhereWithAggregatesInput | DataDeletionRequestScalarWhereWithAggregatesInput[]
    OR?: DataDeletionRequestScalarWhereWithAggregatesInput[]
    NOT?: DataDeletionRequestScalarWhereWithAggregatesInput | DataDeletionRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    userId?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    companyId?: StringNullableWithAggregatesFilter<"DataDeletionRequest"> | string | null
    requestType?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    status?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeWithAggregatesFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"DataDeletionRequest"> | Date | string | null
    processedBy?: StringNullableWithAggregatesFilter<"DataDeletionRequest"> | string | null
    deletionScope?: JsonNullableWithAggregatesFilter<"DataDeletionRequest">
    confirmationToken?: StringWithAggregatesFilter<"DataDeletionRequest"> | string
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"DataDeletionRequest"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"DataDeletionRequest"> | string | null
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    reportType?: StringFilter<"Report"> | string
    format?: StringFilter<"Report"> | string
    config?: JsonFilter<"Report">
    status?: StringFilter<"Report"> | string
    filePath?: StringNullableFilter<"Report"> | string | null
    fileSize?: IntNullableFilter<"Report"> | number | null
    generatedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    userId?: StringFilter<"Report"> | string
    companyId?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    templateId?: StringNullableFilter<"Report"> | string | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    template?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    format?: SortOrder
    config?: SortOrder
    status?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    template?: ReportTemplateOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    name?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    reportType?: StringFilter<"Report"> | string
    format?: StringFilter<"Report"> | string
    config?: JsonFilter<"Report">
    status?: StringFilter<"Report"> | string
    filePath?: StringNullableFilter<"Report"> | string | null
    fileSize?: IntNullableFilter<"Report"> | number | null
    generatedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    userId?: StringFilter<"Report"> | string
    companyId?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    templateId?: StringNullableFilter<"Report"> | string | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    template?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    format?: SortOrder
    config?: SortOrder
    status?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    name?: StringWithAggregatesFilter<"Report"> | string
    description?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reportType?: StringWithAggregatesFilter<"Report"> | string
    format?: StringWithAggregatesFilter<"Report"> | string
    config?: JsonWithAggregatesFilter<"Report">
    status?: StringWithAggregatesFilter<"Report"> | string
    filePath?: StringNullableWithAggregatesFilter<"Report"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"Report"> | number | null
    generatedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Report"> | string
    companyId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    templateId?: StringNullableWithAggregatesFilter<"Report"> | string | null
  }

  export type ReportTemplateWhereInput = {
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    reportType?: StringFilter<"ReportTemplate"> | string
    category?: StringNullableFilter<"ReportTemplate"> | string | null
    config?: JsonFilter<"ReportTemplate">
    isSystem?: BoolFilter<"ReportTemplate"> | boolean
    isPublic?: BoolFilter<"ReportTemplate"> | boolean
    userId?: StringFilter<"ReportTemplate"> | string
    companyId?: StringNullableFilter<"ReportTemplate"> | string | null
    usageCount?: IntFilter<"ReportTemplate"> | number
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    reports?: ReportListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
  }

  export type ReportTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    category?: SortOrderInput | SortOrder
    config?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
    scheduledReports?: ScheduledReportOrderByRelationAggregateInput
  }

  export type ReportTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    reportType?: StringFilter<"ReportTemplate"> | string
    category?: StringNullableFilter<"ReportTemplate"> | string | null
    config?: JsonFilter<"ReportTemplate">
    isSystem?: BoolFilter<"ReportTemplate"> | boolean
    isPublic?: BoolFilter<"ReportTemplate"> | boolean
    userId?: StringFilter<"ReportTemplate"> | string
    companyId?: StringNullableFilter<"ReportTemplate"> | string | null
    usageCount?: IntFilter<"ReportTemplate"> | number
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    reports?: ReportListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
  }, "id">

  export type ReportTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    category?: SortOrderInput | SortOrder
    config?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportTemplateCountOrderByAggregateInput
    _avg?: ReportTemplateAvgOrderByAggregateInput
    _max?: ReportTemplateMaxOrderByAggregateInput
    _min?: ReportTemplateMinOrderByAggregateInput
    _sum?: ReportTemplateSumOrderByAggregateInput
  }

  export type ReportTemplateScalarWhereWithAggregatesInput = {
    AND?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    OR?: ReportTemplateScalarWhereWithAggregatesInput[]
    NOT?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportTemplate"> | string
    name?: StringWithAggregatesFilter<"ReportTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    reportType?: StringWithAggregatesFilter<"ReportTemplate"> | string
    category?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    config?: JsonWithAggregatesFilter<"ReportTemplate">
    isSystem?: BoolWithAggregatesFilter<"ReportTemplate"> | boolean
    isPublic?: BoolWithAggregatesFilter<"ReportTemplate"> | boolean
    userId?: StringWithAggregatesFilter<"ReportTemplate"> | string
    companyId?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    usageCount?: IntWithAggregatesFilter<"ReportTemplate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
  }

  export type ScheduledReportWhereInput = {
    AND?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    OR?: ScheduledReportWhereInput[]
    NOT?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    id?: StringFilter<"ScheduledReport"> | string
    name?: StringFilter<"ScheduledReport"> | string
    description?: StringNullableFilter<"ScheduledReport"> | string | null
    reportType?: StringFilter<"ScheduledReport"> | string
    format?: StringFilter<"ScheduledReport"> | string
    config?: JsonFilter<"ScheduledReport">
    schedule?: JsonFilter<"ScheduledReport">
    recipients?: JsonNullableFilter<"ScheduledReport">
    templateId?: StringNullableFilter<"ScheduledReport"> | string | null
    isActive?: BoolFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    runCount?: IntFilter<"ScheduledReport"> | number
    userId?: StringFilter<"ScheduledReport"> | string
    companyId?: StringNullableFilter<"ScheduledReport"> | string | null
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    template?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
  }

  export type ScheduledReportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    format?: SortOrder
    config?: SortOrder
    schedule?: SortOrder
    recipients?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    runCount?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    template?: ReportTemplateOrderByWithRelationInput
  }

  export type ScheduledReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    OR?: ScheduledReportWhereInput[]
    NOT?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    name?: StringFilter<"ScheduledReport"> | string
    description?: StringNullableFilter<"ScheduledReport"> | string | null
    reportType?: StringFilter<"ScheduledReport"> | string
    format?: StringFilter<"ScheduledReport"> | string
    config?: JsonFilter<"ScheduledReport">
    schedule?: JsonFilter<"ScheduledReport">
    recipients?: JsonNullableFilter<"ScheduledReport">
    templateId?: StringNullableFilter<"ScheduledReport"> | string | null
    isActive?: BoolFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    runCount?: IntFilter<"ScheduledReport"> | number
    userId?: StringFilter<"ScheduledReport"> | string
    companyId?: StringNullableFilter<"ScheduledReport"> | string | null
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    template?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
  }, "id">

  export type ScheduledReportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    format?: SortOrder
    config?: SortOrder
    schedule?: SortOrder
    recipients?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    runCount?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledReportCountOrderByAggregateInput
    _avg?: ScheduledReportAvgOrderByAggregateInput
    _max?: ScheduledReportMaxOrderByAggregateInput
    _min?: ScheduledReportMinOrderByAggregateInput
    _sum?: ScheduledReportSumOrderByAggregateInput
  }

  export type ScheduledReportScalarWhereWithAggregatesInput = {
    AND?: ScheduledReportScalarWhereWithAggregatesInput | ScheduledReportScalarWhereWithAggregatesInput[]
    OR?: ScheduledReportScalarWhereWithAggregatesInput[]
    NOT?: ScheduledReportScalarWhereWithAggregatesInput | ScheduledReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledReport"> | string
    name?: StringWithAggregatesFilter<"ScheduledReport"> | string
    description?: StringNullableWithAggregatesFilter<"ScheduledReport"> | string | null
    reportType?: StringWithAggregatesFilter<"ScheduledReport"> | string
    format?: StringWithAggregatesFilter<"ScheduledReport"> | string
    config?: JsonWithAggregatesFilter<"ScheduledReport">
    schedule?: JsonWithAggregatesFilter<"ScheduledReport">
    recipients?: JsonNullableWithAggregatesFilter<"ScheduledReport">
    templateId?: StringNullableWithAggregatesFilter<"ScheduledReport"> | string | null
    isActive?: BoolWithAggregatesFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableWithAggregatesFilter<"ScheduledReport"> | Date | string | null
    runCount?: IntWithAggregatesFilter<"ScheduledReport"> | number
    userId?: StringWithAggregatesFilter<"ScheduledReport"> | string
    companyId?: StringNullableWithAggregatesFilter<"ScheduledReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledReport"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    deviceFingerprint?: string | null
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    deviceFingerprint?: string | null
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    requireMfa?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    requireMfa?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    deviceFingerprint?: string | null
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    requireMfa?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    requireMfa?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordCreateInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordCreateManyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
  }

  export type PasswordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordHistoryCreateInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
    passwordEntry: PasswordCreateNestedOneWithoutHistoryInput
    changedByUser: UserCreateNestedOneWithoutPasswordHistoryInput
  }

  export type PasswordHistoryUncheckedCreateInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordEntry?: PasswordUpdateOneRequiredWithoutHistoryNestedInput
    changedByUser?: UserUpdateOneRequiredWithoutPasswordHistoryNestedInput
  }

  export type PasswordHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryCreateManyInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordBreachCreateInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutBreachesInput
    checkedByUser: UserCreateNestedOneWithoutPasswordBreachesCheckedInput
    resolvedByUser?: UserCreateNestedOneWithoutPasswordBreachesResolvedInput
  }

  export type PasswordBreachUncheckedCreateInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutBreachesNestedInput
    checkedByUser?: UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput
    resolvedByUser?: UserUpdateOneWithoutPasswordBreachesResolvedNestedInput
  }

  export type PasswordBreachUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachCreateManyInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordBreachUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationPolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutRotationPoliciesInput
    passwords?: PasswordCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutRotationPoliciesNestedInput
    passwords?: PasswordUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordRotationPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationCreateInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    password: PasswordCreateNestedOneWithoutRotationsInput
    policy?: PasswordRotationPolicyCreateNestedOneWithoutRotationsInput
    rotatedByUser: UserCreateNestedOneWithoutPasswordRotationsInput
  }

  export type PasswordRotationUncheckedCreateInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    password?: PasswordUpdateOneRequiredWithoutRotationsNestedInput
    policy?: PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput
    rotatedByUser?: UserUpdateOneRequiredWithoutPasswordRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationCreateManyInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FolderCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
    passwords?: PasswordCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    passwords?: PasswordUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    passwords?: PasswordUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    passwords?: PasswordUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordShareCreateInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutSharedWithInput
    user?: UserCreateNestedOneWithoutSharedPasswordsInput
    team?: TeamCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateInput = {
    id?: string
    passwordId: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutSharedWithNestedInput
    user?: UserUpdateOneWithoutSharedPasswordsNestedInput
    team?: TeamUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareCreateManyInput = {
    id?: string
    passwordId: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemporaryPasswordShareCreateInput = {
    id?: string
    shareToken: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
    password: PasswordCreateNestedOneWithoutTemporarySharesInput
    creator: UserCreateNestedOneWithoutTemporaryPasswordSharesInput
  }

  export type TemporaryPasswordShareUncheckedCreateInput = {
    id?: string
    passwordId: string
    shareToken: string
    createdBy: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TemporaryPasswordShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: PasswordUpdateOneRequiredWithoutTemporarySharesNestedInput
    creator?: UserUpdateOneRequiredWithoutTemporaryPasswordSharesNestedInput
  }

  export type TemporaryPasswordShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemporaryPasswordShareCreateManyInput = {
    id?: string
    passwordId: string
    shareToken: string
    createdBy: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TemporaryPasswordShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemporaryPasswordShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    passwords?: PasswordTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    passwords?: PasswordTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagCreateInput = {
    id?: string
    createdAt?: Date | string
    password: PasswordCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordTagUncheckedCreateInput = {
    id?: string
    passwordId: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: PasswordUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPasswordsNestedInput
  }

  export type PasswordTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagCreateManyInput = {
    id?: string
    passwordId: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogArchiveCreateInput = {
    id?: string
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    status?: string
    createdAt?: Date | string
    company?: CompanyCreateNestedOneWithoutAuditLogArchivesInput
    archiver?: UserCreateNestedOneWithoutAuditLogArchivesInput
  }

  export type AuditLogArchiveUncheckedCreateInput = {
    id?: string
    companyId?: string | null
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    archivedBy?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type AuditLogArchiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutAuditLogArchivesNestedInput
    archiver?: UserUpdateOneWithoutAuditLogArchivesNestedInput
  }

  export type AuditLogArchiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    archivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogArchiveCreateManyInput = {
    id?: string
    companyId?: string | null
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    archivedBy?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type AuditLogArchiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogArchiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    archivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogSearchCreateInput = {
    id?: string
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogSearchesInput
    company?: CompanyCreateNestedOneWithoutAuditLogSearchesInput
  }

  export type AuditLogSearchUncheckedCreateInput = {
    id?: string
    userId: string
    companyId?: string | null
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type AuditLogSearchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogSearchesNestedInput
    company?: CompanyUpdateOneWithoutAuditLogSearchesNestedInput
  }

  export type AuditLogSearchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogSearchCreateManyInput = {
    id?: string
    userId: string
    companyId?: string | null
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type AuditLogSearchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogSearchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatEventCreateInput = {
    id?: string
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutThreatEventsInput
    company?: CompanyCreateNestedOneWithoutThreatEventsInput
  }

  export type ThreatEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type ThreatEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutThreatEventsNestedInput
    company?: CompanyUpdateOneWithoutThreatEventsNestedInput
  }

  export type ThreatEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatEventCreateManyInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type ThreatEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitCreateInput = {
    id?: string
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    count?: number
    windowStart?: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutRateLimitsInput
  }

  export type RateLimitUncheckedCreateInput = {
    id?: string
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    count?: number
    windowStart?: Date | string
    windowEnd: Date | string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RateLimitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    identifierType?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutRateLimitsNestedInput
  }

  export type RateLimitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    identifierType?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitCreateManyInput = {
    id?: string
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    count?: number
    windowStart?: Date | string
    windowEnd: Date | string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RateLimitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    identifierType?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    identifierType?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedRolesInput
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedRolesNestedInput
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MfaCredentialCreateInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMfaCredentialsInput
  }

  export type MfaCredentialUncheckedCreateInput = {
    id?: string
    userId: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMfaCredentialsNestedInput
  }

  export type MfaCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialCreateManyInput = {
    id?: string
    userId: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecoveryCodeCreateInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecoveryCodesInput
  }

  export type RecoveryCodeUncheckedCreateInput = {
    id?: string
    userId: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecoveryCodesNestedInput
  }

  export type RecoveryCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeCreateManyInput = {
    id?: string
    userId: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedSearchCreateInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSavedSearchesInput
  }

  export type SavedSearchUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSavedSearchesNestedInput
  }

  export type SavedSearchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchCreateManyInput = {
    id?: string
    userId: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchHistoryCreateInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSearchHistoryInput
  }

  export type SearchHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSearchHistoryNestedInput
  }

  export type SearchHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryCreateManyInput = {
    id?: string
    userId: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutPasswordTemplatesInput
    company?: CompanyCreateNestedOneWithoutTemplatesInput
  }

  export type PasswordTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutPasswordTemplatesNestedInput
    company?: CompanyUpdateOneWithoutTemplatesNestedInput
  }

  export type PasswordTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenCreateInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailVerificationTokensInput
  }

  export type EmailVerificationTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput
  }

  export type EmailVerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionCreateInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSecurityQuestionsInput
  }

  export type SecurityQuestionUncheckedCreateInput = {
    id?: string
    userId: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSecurityQuestionsNestedInput
  }

  export type SecurityQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionCreateManyInput = {
    id?: string
    userId: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpWhitelistCreateInput = {
    id?: string
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutIpWhitelistsInput
    company?: CompanyCreateNestedOneWithoutIpWhitelistsInput
    creator?: UserCreateNestedOneWithoutCreatedIpWhitelistsInput
  }

  export type IpWhitelistUncheckedCreateInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type IpWhitelistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutIpWhitelistsNestedInput
    company?: CompanyUpdateOneWithoutIpWhitelistsNestedInput
    creator?: UserUpdateOneWithoutCreatedIpWhitelistsNestedInput
  }

  export type IpWhitelistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IpWhitelistCreateManyInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type IpWhitelistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpWhitelistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GeographicRestrictionCreateInput = {
    id?: string
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutGeographicRestrictionsInput
    company?: CompanyCreateNestedOneWithoutGeographicRestrictionsInput
    creator?: UserCreateNestedOneWithoutCreatedGeographicRestrictionsInput
  }

  export type GeographicRestrictionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type GeographicRestrictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeographicRestrictionsNestedInput
    company?: CompanyUpdateOneWithoutGeographicRestrictionsNestedInput
    creator?: UserUpdateOneWithoutCreatedGeographicRestrictionsNestedInput
  }

  export type GeographicRestrictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GeographicRestrictionCreateManyInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type GeographicRestrictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeographicRestrictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordPolicyCreateInput = {
    id?: string
    minLength?: number
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: number | null
    preventReuseCount?: number
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPasswordPolicyInput
  }

  export type PasswordPolicyUncheckedCreateInput = {
    id?: string
    companyId: string
    minLength?: number
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: number | null
    preventReuseCount?: number
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minLength?: IntFieldUpdateOperationsInput | number
    requireUppercase?: BoolFieldUpdateOperationsInput | boolean
    requireLowercase?: BoolFieldUpdateOperationsInput | boolean
    requireNumbers?: BoolFieldUpdateOperationsInput | boolean
    requireSpecial?: BoolFieldUpdateOperationsInput | boolean
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    preventReuseCount?: IntFieldUpdateOperationsInput | number
    requireChangeOnFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    requireChangeAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPasswordPolicyNestedInput
  }

  export type PasswordPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    minLength?: IntFieldUpdateOperationsInput | number
    requireUppercase?: BoolFieldUpdateOperationsInput | boolean
    requireLowercase?: BoolFieldUpdateOperationsInput | boolean
    requireNumbers?: BoolFieldUpdateOperationsInput | boolean
    requireSpecial?: BoolFieldUpdateOperationsInput | boolean
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    preventReuseCount?: IntFieldUpdateOperationsInput | number
    requireChangeOnFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    requireChangeAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordPolicyCreateManyInput = {
    id?: string
    companyId: string
    minLength?: number
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: number | null
    preventReuseCount?: number
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minLength?: IntFieldUpdateOperationsInput | number
    requireUppercase?: BoolFieldUpdateOperationsInput | boolean
    requireLowercase?: BoolFieldUpdateOperationsInput | boolean
    requireNumbers?: BoolFieldUpdateOperationsInput | boolean
    requireSpecial?: BoolFieldUpdateOperationsInput | boolean
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    preventReuseCount?: IntFieldUpdateOperationsInput | number
    requireChangeOnFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    requireChangeAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    minLength?: IntFieldUpdateOperationsInput | number
    requireUppercase?: BoolFieldUpdateOperationsInput | boolean
    requireLowercase?: BoolFieldUpdateOperationsInput | boolean
    requireNumbers?: BoolFieldUpdateOperationsInput | boolean
    requireSpecial?: BoolFieldUpdateOperationsInput | boolean
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    preventReuseCount?: IntFieldUpdateOperationsInput | number
    requireChangeOnFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    requireChangeAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRetentionPolicyCreateInput = {
    id?: string
    auditLogRetentionDays?: number | null
    passwordHistoryRetentionDays?: number | null
    sessionRetentionDays?: number | null
    deletedDataRetentionDays?: number | null
    autoDeleteEnabled?: boolean
    lastCleanupAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDataRetentionPolicyInput
  }

  export type DataRetentionPolicyUncheckedCreateInput = {
    id?: string
    companyId: string
    auditLogRetentionDays?: number | null
    passwordHistoryRetentionDays?: number | null
    sessionRetentionDays?: number | null
    deletedDataRetentionDays?: number | null
    autoDeleteEnabled?: boolean
    lastCleanupAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRetentionPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditLogRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    passwordHistoryRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    sessionRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    deletedDataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastCleanupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDataRetentionPolicyNestedInput
  }

  export type DataRetentionPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    auditLogRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    passwordHistoryRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    sessionRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    deletedDataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastCleanupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRetentionPolicyCreateManyInput = {
    id?: string
    companyId: string
    auditLogRetentionDays?: number | null
    passwordHistoryRetentionDays?: number | null
    sessionRetentionDays?: number | null
    deletedDataRetentionDays?: number | null
    autoDeleteEnabled?: boolean
    lastCleanupAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRetentionPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditLogRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    passwordHistoryRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    sessionRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    deletedDataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastCleanupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRetentionPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    auditLogRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    passwordHistoryRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    sessionRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    deletedDataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastCleanupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportCreateInput = {
    id?: string
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    user: UserCreateNestedOneWithoutDataExportsInput
    company?: CompanyCreateNestedOneWithoutDataExportsInput
  }

  export type DataExportUncheckedCreateInput = {
    id?: string
    userId: string
    companyId?: string | null
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataExportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDataExportsNestedInput
    company?: CompanyUpdateOneWithoutDataExportsNestedInput
  }

  export type DataExportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataExportCreateManyInput = {
    id?: string
    userId: string
    companyId?: string | null
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataExportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataExportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestCreateInput = {
    id?: string
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
    user: UserCreateNestedOneWithoutDataDeletionRequestsInput
    company?: CompanyCreateNestedOneWithoutDataDeletionRequestsInput
    processor?: UserCreateNestedOneWithoutProcessedDeletionsInput
  }

  export type DataDeletionRequestUncheckedCreateInput = {
    id?: string
    userId: string
    companyId?: string | null
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    processedBy?: string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDataDeletionRequestsNestedInput
    company?: CompanyUpdateOneWithoutDataDeletionRequestsNestedInput
    processor?: UserUpdateOneWithoutProcessedDeletionsNestedInput
  }

  export type DataDeletionRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestCreateManyInput = {
    id?: string
    userId: string
    companyId?: string | null
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    processedBy?: string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutReportsInput
    company?: CompanyCreateNestedOneWithoutReportsInput
    template?: ReportTemplateCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    company?: CompanyUpdateOneWithoutReportsNestedInput
    template?: ReportTemplateUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutReportTemplatesInput
    company?: CompanyCreateNestedOneWithoutReportTemplatesInput
    reports?: ReportCreateNestedManyWithoutTemplateInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    userId: string
    companyId?: string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutTemplateInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutReportTemplatesNestedInput
    company?: CompanyUpdateOneWithoutReportTemplatesNestedInput
    reports?: ReportUpdateManyWithoutTemplateNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutTemplateNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    userId: string
    companyId?: string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportCreateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutScheduledReportsInput
    company?: CompanyCreateNestedOneWithoutScheduledReportsInput
    template?: ReportTemplateCreateNestedOneWithoutScheduledReportsInput
  }

  export type ScheduledReportUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: string | null
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutScheduledReportsNestedInput
    company?: CompanyUpdateOneWithoutScheduledReportsNestedInput
    template?: ReportTemplateUpdateOneWithoutScheduledReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: string | null
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PasswordTemplateListRelationFilter = {
    every?: PasswordTemplateWhereInput
    some?: PasswordTemplateWhereInput
    none?: PasswordTemplateWhereInput
  }

  export type IpWhitelistListRelationFilter = {
    every?: IpWhitelistWhereInput
    some?: IpWhitelistWhereInput
    none?: IpWhitelistWhereInput
  }

  export type GeographicRestrictionListRelationFilter = {
    every?: GeographicRestrictionWhereInput
    some?: GeographicRestrictionWhereInput
    none?: GeographicRestrictionWhereInput
  }

  export type ThreatEventListRelationFilter = {
    every?: ThreatEventWhereInput
    some?: ThreatEventWhereInput
    none?: ThreatEventWhereInput
  }

  export type RateLimitListRelationFilter = {
    every?: RateLimitWhereInput
    some?: RateLimitWhereInput
    none?: RateLimitWhereInput
  }

  export type PasswordPolicyNullableScalarRelationFilter = {
    is?: PasswordPolicyWhereInput | null
    isNot?: PasswordPolicyWhereInput | null
  }

  export type DataRetentionPolicyNullableScalarRelationFilter = {
    is?: DataRetentionPolicyWhereInput | null
    isNot?: DataRetentionPolicyWhereInput | null
  }

  export type DataExportListRelationFilter = {
    every?: DataExportWhereInput
    some?: DataExportWhereInput
    none?: DataExportWhereInput
  }

  export type DataDeletionRequestListRelationFilter = {
    every?: DataDeletionRequestWhereInput
    some?: DataDeletionRequestWhereInput
    none?: DataDeletionRequestWhereInput
  }

  export type AuditLogArchiveListRelationFilter = {
    every?: AuditLogArchiveWhereInput
    some?: AuditLogArchiveWhereInput
    none?: AuditLogArchiveWhereInput
  }

  export type AuditLogSearchListRelationFilter = {
    every?: AuditLogSearchWhereInput
    some?: AuditLogSearchWhereInput
    none?: AuditLogSearchWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ReportTemplateListRelationFilter = {
    every?: ReportTemplateWhereInput
    some?: ReportTemplateWhereInput
    none?: ReportTemplateWhereInput
  }

  export type ScheduledReportListRelationFilter = {
    every?: ScheduledReportWhereInput
    some?: ScheduledReportWhereInput
    none?: ScheduledReportWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IpWhitelistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeographicRestrictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreatEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RateLimitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataExportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataDeletionRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogArchiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogSearchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumMfaMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableFilter<$PrismaModel> | $Enums.MfaMethod | null
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type PasswordListRelationFilter = {
    every?: PasswordWhereInput
    some?: PasswordWhereInput
    none?: PasswordWhereInput
  }

  export type PasswordShareListRelationFilter = {
    every?: PasswordShareWhereInput
    some?: PasswordShareWhereInput
    none?: PasswordShareWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type MfaCredentialListRelationFilter = {
    every?: MfaCredentialWhereInput
    some?: MfaCredentialWhereInput
    none?: MfaCredentialWhereInput
  }

  export type RecoveryCodeListRelationFilter = {
    every?: RecoveryCodeWhereInput
    some?: RecoveryCodeWhereInput
    none?: RecoveryCodeWhereInput
  }

  export type PasswordHistoryListRelationFilter = {
    every?: PasswordHistoryWhereInput
    some?: PasswordHistoryWhereInput
    none?: PasswordHistoryWhereInput
  }

  export type PasswordBreachListRelationFilter = {
    every?: PasswordBreachWhereInput
    some?: PasswordBreachWhereInput
    none?: PasswordBreachWhereInput
  }

  export type PasswordRotationPolicyListRelationFilter = {
    every?: PasswordRotationPolicyWhereInput
    some?: PasswordRotationPolicyWhereInput
    none?: PasswordRotationPolicyWhereInput
  }

  export type PasswordRotationListRelationFilter = {
    every?: PasswordRotationWhereInput
    some?: PasswordRotationWhereInput
    none?: PasswordRotationWhereInput
  }

  export type TemporaryPasswordShareListRelationFilter = {
    every?: TemporaryPasswordShareWhereInput
    some?: TemporaryPasswordShareWhereInput
    none?: TemporaryPasswordShareWhereInput
  }

  export type SavedSearchListRelationFilter = {
    every?: SavedSearchWhereInput
    some?: SavedSearchWhereInput
    none?: SavedSearchWhereInput
  }

  export type SearchHistoryListRelationFilter = {
    every?: SearchHistoryWhereInput
    some?: SearchHistoryWhereInput
    none?: SearchHistoryWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type EmailVerificationTokenListRelationFilter = {
    every?: EmailVerificationTokenWhereInput
    some?: EmailVerificationTokenWhereInput
    none?: EmailVerificationTokenWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SecurityQuestionListRelationFilter = {
    every?: SecurityQuestionWhereInput
    some?: SecurityQuestionWhereInput
    none?: SecurityQuestionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PasswordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MfaCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecoveryCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordBreachOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordRotationPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordRotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemporaryPasswordShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedSearchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailVerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    recoveryEmail?: SortOrder
    recoveryEmailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    bio?: SortOrder
    preferences?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaMethod?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    recoveryEmail?: SortOrder
    recoveryEmailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaMethod?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    recoveryEmail?: SortOrder
    recoveryEmailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaMethod?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdById?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumMfaMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.MfaMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    deviceFingerprint?: SortOrder
    isTrusted?: SortOrder
    requireMfa?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    deviceFingerprint?: SortOrder
    isTrusted?: SortOrder
    requireMfa?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    deviceFingerprint?: SortOrder
    isTrusted?: SortOrder
    requireMfa?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPasswordStrengthFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthFilter<$PrismaModel> | $Enums.PasswordStrength
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type PasswordTagListRelationFilter = {
    every?: PasswordTagWhereInput
    some?: PasswordTagWhereInput
    none?: PasswordTagWhereInput
  }

  export type PasswordRotationPolicyNullableScalarRelationFilter = {
    is?: PasswordRotationPolicyWhereInput | null
    isNot?: PasswordRotationPolicyWhereInput | null
  }

  export type PasswordTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrder
  }

  export type PasswordMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrder
  }

  export type PasswordMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrder
  }

  export type EnumPasswordStrengthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthWithAggregatesFilter<$PrismaModel> | $Enums.PasswordStrength
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPasswordStrengthFilter<$PrismaModel>
    _max?: NestedEnumPasswordStrengthFilter<$PrismaModel>
  }

  export type PasswordScalarRelationFilter = {
    is?: PasswordWhereInput
    isNot?: PasswordWhereInput
  }

  export type PasswordHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PasswordBreachCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type PasswordBreachAvgOrderByAggregateInput = {
    breachCount?: SortOrder
  }

  export type PasswordBreachMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type PasswordBreachMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type PasswordBreachSumOrderByAggregateInput = {
    breachCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PasswordRotationPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordRotationPolicyAvgOrderByAggregateInput = {
    rotationDays?: SortOrder
    reminderDays?: SortOrder
  }

  export type PasswordRotationPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordRotationPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordRotationPolicySumOrderByAggregateInput = {
    rotationDays?: SortOrder
    reminderDays?: SortOrder
  }

  export type PasswordRotationCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type PasswordRotationMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type PasswordRotationMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSharePermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionFilter<$PrismaModel> | $Enums.SharePermission
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type PasswordShareCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordShareMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordShareMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumSharePermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionWithAggregatesFilter<$PrismaModel> | $Enums.SharePermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSharePermissionFilter<$PrismaModel>
    _max?: NestedEnumSharePermissionFilter<$PrismaModel>
  }

  export type TemporaryPasswordShareCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    shareToken?: SortOrder
    createdBy?: SortOrder
    accessCount?: SortOrder
    maxAccesses?: SortOrder
    isOneTime?: SortOrder
    includeTotp?: SortOrder
    expiresAt?: SortOrder
    accessedAt?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TemporaryPasswordShareAvgOrderByAggregateInput = {
    accessCount?: SortOrder
    maxAccesses?: SortOrder
  }

  export type TemporaryPasswordShareMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    shareToken?: SortOrder
    createdBy?: SortOrder
    accessCount?: SortOrder
    maxAccesses?: SortOrder
    isOneTime?: SortOrder
    includeTotp?: SortOrder
    expiresAt?: SortOrder
    accessedAt?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TemporaryPasswordShareMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    shareToken?: SortOrder
    createdBy?: SortOrder
    accessCount?: SortOrder
    maxAccesses?: SortOrder
    isOneTime?: SortOrder
    includeTotp?: SortOrder
    expiresAt?: SortOrder
    accessedAt?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TemporaryPasswordShareSumOrderByAggregateInput = {
    accessCount?: SortOrder
    maxAccesses?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PasswordTagPasswordIdTagIdCompoundUniqueInput = {
    passwordId: string
    tagId: string
  }

  export type PasswordTagCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordTagMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordTagMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type AuditLogArchiveCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    archiveDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    logCount?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    archivedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogArchiveAvgOrderByAggregateInput = {
    logCount?: SortOrder
    fileSize?: SortOrder
  }

  export type AuditLogArchiveMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    archiveDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    logCount?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    archivedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogArchiveMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    archiveDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    logCount?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    archivedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogArchiveSumOrderByAggregateInput = {
    logCount?: SortOrder
    fileSize?: SortOrder
  }

  export type AuditLogSearchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    searchQuery?: SortOrder
    filters?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type AuditLogSearchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    searchQuery?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type AuditLogSearchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    searchQuery?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumThreatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatType | EnumThreatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatTypeFilter<$PrismaModel> | $Enums.ThreatType
  }

  export type EnumThreatSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatSeverity | EnumThreatSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatSeverityFilter<$PrismaModel> | $Enums.ThreatSeverity
  }

  export type ThreatEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    details?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ThreatEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ThreatEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumThreatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatType | EnumThreatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatTypeWithAggregatesFilter<$PrismaModel> | $Enums.ThreatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThreatTypeFilter<$PrismaModel>
    _max?: NestedEnumThreatTypeFilter<$PrismaModel>
  }

  export type EnumThreatSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatSeverity | EnumThreatSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ThreatSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThreatSeverityFilter<$PrismaModel>
    _max?: NestedEnumThreatSeverityFilter<$PrismaModel>
  }

  export type EnumRateLimitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRateLimitTypeFilter<$PrismaModel> | $Enums.RateLimitType
  }

  export type RateLimitIdentifierIdentifierTypeActionWindowStartCompoundUniqueInput = {
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    windowStart: Date | string
  }

  export type RateLimitCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    identifierType?: SortOrder
    action?: SortOrder
    count?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RateLimitAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type RateLimitMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    identifierType?: SortOrder
    action?: SortOrder
    count?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RateLimitMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    identifierType?: SortOrder
    action?: SortOrder
    count?: SortOrder
    windowStart?: SortOrder
    windowEnd?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RateLimitSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type EnumRateLimitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRateLimitTypeWithAggregatesFilter<$PrismaModel> | $Enums.RateLimitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRateLimitTypeFilter<$PrismaModel>
    _max?: NestedEnumRateLimitTypeFilter<$PrismaModel>
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type MfaCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type MfaCredentialAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type MfaCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type MfaCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type MfaCredentialSumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type RecoveryCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RecoveryCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RecoveryCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SavedSearchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrder
    searchFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SavedSearchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SavedSearchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SearchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrder
    searchFields?: SortOrder
    resultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryAvgOrderByAggregateInput = {
    resultCount?: SortOrder
  }

  export type SearchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    resultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    resultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistorySumOrderByAggregateInput = {
    resultCount?: SortOrder
  }

  export type PasswordTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
    defaultFields?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type PasswordTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EmailVerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailVerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailVerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IpWhitelistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    ipAddress?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type IpWhitelistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    ipAddress?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type IpWhitelistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    ipAddress?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type GeographicRestrictionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryCode?: SortOrder
    action?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type GeographicRestrictionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryCode?: SortOrder
    action?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type GeographicRestrictionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    countryCode?: SortOrder
    action?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type PasswordPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    minLength?: SortOrder
    requireUppercase?: SortOrder
    requireLowercase?: SortOrder
    requireNumbers?: SortOrder
    requireSpecial?: SortOrder
    expirationDays?: SortOrder
    preventReuseCount?: SortOrder
    requireChangeOnFirstLogin?: SortOrder
    requireChangeAfterDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordPolicyAvgOrderByAggregateInput = {
    minLength?: SortOrder
    expirationDays?: SortOrder
    preventReuseCount?: SortOrder
    requireChangeAfterDays?: SortOrder
  }

  export type PasswordPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    minLength?: SortOrder
    requireUppercase?: SortOrder
    requireLowercase?: SortOrder
    requireNumbers?: SortOrder
    requireSpecial?: SortOrder
    expirationDays?: SortOrder
    preventReuseCount?: SortOrder
    requireChangeOnFirstLogin?: SortOrder
    requireChangeAfterDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    minLength?: SortOrder
    requireUppercase?: SortOrder
    requireLowercase?: SortOrder
    requireNumbers?: SortOrder
    requireSpecial?: SortOrder
    expirationDays?: SortOrder
    preventReuseCount?: SortOrder
    requireChangeOnFirstLogin?: SortOrder
    requireChangeAfterDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordPolicySumOrderByAggregateInput = {
    minLength?: SortOrder
    expirationDays?: SortOrder
    preventReuseCount?: SortOrder
    requireChangeAfterDays?: SortOrder
  }

  export type DataRetentionPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    auditLogRetentionDays?: SortOrder
    passwordHistoryRetentionDays?: SortOrder
    sessionRetentionDays?: SortOrder
    deletedDataRetentionDays?: SortOrder
    autoDeleteEnabled?: SortOrder
    lastCleanupAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRetentionPolicyAvgOrderByAggregateInput = {
    auditLogRetentionDays?: SortOrder
    passwordHistoryRetentionDays?: SortOrder
    sessionRetentionDays?: SortOrder
    deletedDataRetentionDays?: SortOrder
  }

  export type DataRetentionPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    auditLogRetentionDays?: SortOrder
    passwordHistoryRetentionDays?: SortOrder
    sessionRetentionDays?: SortOrder
    deletedDataRetentionDays?: SortOrder
    autoDeleteEnabled?: SortOrder
    lastCleanupAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRetentionPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    auditLogRetentionDays?: SortOrder
    passwordHistoryRetentionDays?: SortOrder
    sessionRetentionDays?: SortOrder
    deletedDataRetentionDays?: SortOrder
    autoDeleteEnabled?: SortOrder
    lastCleanupAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRetentionPolicySumOrderByAggregateInput = {
    auditLogRetentionDays?: SortOrder
    passwordHistoryRetentionDays?: SortOrder
    sessionRetentionDays?: SortOrder
    deletedDataRetentionDays?: SortOrder
  }

  export type DataExportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    exportType?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    expiresAt?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type DataExportAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DataExportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    exportType?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    expiresAt?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type DataExportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    exportType?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    expiresAt?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type DataExportSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DataDeletionRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    processedBy?: SortOrder
    deletionScope?: SortOrder
    confirmationToken?: SortOrder
    confirmedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type DataDeletionRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    processedBy?: SortOrder
    confirmationToken?: SortOrder
    confirmedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type DataDeletionRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
    processedBy?: SortOrder
    confirmationToken?: SortOrder
    confirmedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type ReportTemplateNullableScalarRelationFilter = {
    is?: ReportTemplateWhereInput | null
    isNot?: ReportTemplateWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    format?: SortOrder
    config?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    format?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    format?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ReportTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    category?: SortOrder
    config?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ReportTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ScheduledReportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    format?: SortOrder
    config?: SortOrder
    schedule?: SortOrder
    recipients?: SortOrder
    templateId?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    runCount?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledReportAvgOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type ScheduledReportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    format?: SortOrder
    templateId?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    runCount?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledReportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    format?: SortOrder
    templateId?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    runCount?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledReportSumOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PasswordTemplateCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type IpWhitelistCreateNestedManyWithoutCompanyInput = {
    create?: XOR<IpWhitelistCreateWithoutCompanyInput, IpWhitelistUncheckedCreateWithoutCompanyInput> | IpWhitelistCreateWithoutCompanyInput[] | IpWhitelistUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCompanyInput | IpWhitelistCreateOrConnectWithoutCompanyInput[]
    createMany?: IpWhitelistCreateManyCompanyInputEnvelope
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
  }

  export type GeographicRestrictionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCompanyInput, GeographicRestrictionUncheckedCreateWithoutCompanyInput> | GeographicRestrictionCreateWithoutCompanyInput[] | GeographicRestrictionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCompanyInput | GeographicRestrictionCreateOrConnectWithoutCompanyInput[]
    createMany?: GeographicRestrictionCreateManyCompanyInputEnvelope
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
  }

  export type ThreatEventCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ThreatEventCreateWithoutCompanyInput, ThreatEventUncheckedCreateWithoutCompanyInput> | ThreatEventCreateWithoutCompanyInput[] | ThreatEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutCompanyInput | ThreatEventCreateOrConnectWithoutCompanyInput[]
    createMany?: ThreatEventCreateManyCompanyInputEnvelope
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
  }

  export type RateLimitCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RateLimitCreateWithoutCompanyInput, RateLimitUncheckedCreateWithoutCompanyInput> | RateLimitCreateWithoutCompanyInput[] | RateLimitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RateLimitCreateOrConnectWithoutCompanyInput | RateLimitCreateOrConnectWithoutCompanyInput[]
    createMany?: RateLimitCreateManyCompanyInputEnvelope
    connect?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
  }

  export type PasswordPolicyCreateNestedOneWithoutCompanyInput = {
    create?: XOR<PasswordPolicyCreateWithoutCompanyInput, PasswordPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PasswordPolicyCreateOrConnectWithoutCompanyInput
    connect?: PasswordPolicyWhereUniqueInput
  }

  export type DataRetentionPolicyCreateNestedOneWithoutCompanyInput = {
    create?: XOR<DataRetentionPolicyCreateWithoutCompanyInput, DataRetentionPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DataRetentionPolicyCreateOrConnectWithoutCompanyInput
    connect?: DataRetentionPolicyWhereUniqueInput
  }

  export type DataExportCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DataExportCreateWithoutCompanyInput, DataExportUncheckedCreateWithoutCompanyInput> | DataExportCreateWithoutCompanyInput[] | DataExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutCompanyInput | DataExportCreateOrConnectWithoutCompanyInput[]
    createMany?: DataExportCreateManyCompanyInputEnvelope
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
  }

  export type DataDeletionRequestCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DataDeletionRequestCreateWithoutCompanyInput, DataDeletionRequestUncheckedCreateWithoutCompanyInput> | DataDeletionRequestCreateWithoutCompanyInput[] | DataDeletionRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutCompanyInput | DataDeletionRequestCreateOrConnectWithoutCompanyInput[]
    createMany?: DataDeletionRequestCreateManyCompanyInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type AuditLogArchiveCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogArchiveCreateWithoutCompanyInput, AuditLogArchiveUncheckedCreateWithoutCompanyInput> | AuditLogArchiveCreateWithoutCompanyInput[] | AuditLogArchiveUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutCompanyInput | AuditLogArchiveCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogArchiveCreateManyCompanyInputEnvelope
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
  }

  export type AuditLogSearchCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogSearchCreateWithoutCompanyInput, AuditLogSearchUncheckedCreateWithoutCompanyInput> | AuditLogSearchCreateWithoutCompanyInput[] | AuditLogSearchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutCompanyInput | AuditLogSearchCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogSearchCreateManyCompanyInputEnvelope
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportTemplateCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportTemplateCreateWithoutCompanyInput, ReportTemplateUncheckedCreateWithoutCompanyInput> | ReportTemplateCreateWithoutCompanyInput[] | ReportTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCompanyInput | ReportTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportTemplateCreateManyCompanyInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ScheduledReportCreateWithoutCompanyInput, ScheduledReportUncheckedCreateWithoutCompanyInput> | ScheduledReportCreateWithoutCompanyInput[] | ScheduledReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCompanyInput | ScheduledReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ScheduledReportCreateManyCompanyInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<IpWhitelistCreateWithoutCompanyInput, IpWhitelistUncheckedCreateWithoutCompanyInput> | IpWhitelistCreateWithoutCompanyInput[] | IpWhitelistUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCompanyInput | IpWhitelistCreateOrConnectWithoutCompanyInput[]
    createMany?: IpWhitelistCreateManyCompanyInputEnvelope
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
  }

  export type GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCompanyInput, GeographicRestrictionUncheckedCreateWithoutCompanyInput> | GeographicRestrictionCreateWithoutCompanyInput[] | GeographicRestrictionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCompanyInput | GeographicRestrictionCreateOrConnectWithoutCompanyInput[]
    createMany?: GeographicRestrictionCreateManyCompanyInputEnvelope
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
  }

  export type ThreatEventUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ThreatEventCreateWithoutCompanyInput, ThreatEventUncheckedCreateWithoutCompanyInput> | ThreatEventCreateWithoutCompanyInput[] | ThreatEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutCompanyInput | ThreatEventCreateOrConnectWithoutCompanyInput[]
    createMany?: ThreatEventCreateManyCompanyInputEnvelope
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
  }

  export type RateLimitUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RateLimitCreateWithoutCompanyInput, RateLimitUncheckedCreateWithoutCompanyInput> | RateLimitCreateWithoutCompanyInput[] | RateLimitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RateLimitCreateOrConnectWithoutCompanyInput | RateLimitCreateOrConnectWithoutCompanyInput[]
    createMany?: RateLimitCreateManyCompanyInputEnvelope
    connect?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
  }

  export type PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput = {
    create?: XOR<PasswordPolicyCreateWithoutCompanyInput, PasswordPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PasswordPolicyCreateOrConnectWithoutCompanyInput
    connect?: PasswordPolicyWhereUniqueInput
  }

  export type DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput = {
    create?: XOR<DataRetentionPolicyCreateWithoutCompanyInput, DataRetentionPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DataRetentionPolicyCreateOrConnectWithoutCompanyInput
    connect?: DataRetentionPolicyWhereUniqueInput
  }

  export type DataExportUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DataExportCreateWithoutCompanyInput, DataExportUncheckedCreateWithoutCompanyInput> | DataExportCreateWithoutCompanyInput[] | DataExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutCompanyInput | DataExportCreateOrConnectWithoutCompanyInput[]
    createMany?: DataExportCreateManyCompanyInputEnvelope
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
  }

  export type DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DataDeletionRequestCreateWithoutCompanyInput, DataDeletionRequestUncheckedCreateWithoutCompanyInput> | DataDeletionRequestCreateWithoutCompanyInput[] | DataDeletionRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutCompanyInput | DataDeletionRequestCreateOrConnectWithoutCompanyInput[]
    createMany?: DataDeletionRequestCreateManyCompanyInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogArchiveCreateWithoutCompanyInput, AuditLogArchiveUncheckedCreateWithoutCompanyInput> | AuditLogArchiveCreateWithoutCompanyInput[] | AuditLogArchiveUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutCompanyInput | AuditLogArchiveCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogArchiveCreateManyCompanyInputEnvelope
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
  }

  export type AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogSearchCreateWithoutCompanyInput, AuditLogSearchUncheckedCreateWithoutCompanyInput> | AuditLogSearchCreateWithoutCompanyInput[] | AuditLogSearchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutCompanyInput | AuditLogSearchCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogSearchCreateManyCompanyInputEnvelope
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportTemplateCreateWithoutCompanyInput, ReportTemplateUncheckedCreateWithoutCompanyInput> | ReportTemplateCreateWithoutCompanyInput[] | ReportTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCompanyInput | ReportTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportTemplateCreateManyCompanyInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ScheduledReportCreateWithoutCompanyInput, ScheduledReportUncheckedCreateWithoutCompanyInput> | ScheduledReportCreateWithoutCompanyInput[] | ScheduledReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCompanyInput | ScheduledReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ScheduledReportCreateManyCompanyInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PasswordTemplateUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutCompanyInput | PasswordTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type IpWhitelistUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<IpWhitelistCreateWithoutCompanyInput, IpWhitelistUncheckedCreateWithoutCompanyInput> | IpWhitelistCreateWithoutCompanyInput[] | IpWhitelistUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCompanyInput | IpWhitelistCreateOrConnectWithoutCompanyInput[]
    upsert?: IpWhitelistUpsertWithWhereUniqueWithoutCompanyInput | IpWhitelistUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: IpWhitelistCreateManyCompanyInputEnvelope
    set?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    disconnect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    delete?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    update?: IpWhitelistUpdateWithWhereUniqueWithoutCompanyInput | IpWhitelistUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: IpWhitelistUpdateManyWithWhereWithoutCompanyInput | IpWhitelistUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
  }

  export type GeographicRestrictionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCompanyInput, GeographicRestrictionUncheckedCreateWithoutCompanyInput> | GeographicRestrictionCreateWithoutCompanyInput[] | GeographicRestrictionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCompanyInput | GeographicRestrictionCreateOrConnectWithoutCompanyInput[]
    upsert?: GeographicRestrictionUpsertWithWhereUniqueWithoutCompanyInput | GeographicRestrictionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GeographicRestrictionCreateManyCompanyInputEnvelope
    set?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    disconnect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    delete?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    update?: GeographicRestrictionUpdateWithWhereUniqueWithoutCompanyInput | GeographicRestrictionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GeographicRestrictionUpdateManyWithWhereWithoutCompanyInput | GeographicRestrictionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
  }

  export type ThreatEventUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ThreatEventCreateWithoutCompanyInput, ThreatEventUncheckedCreateWithoutCompanyInput> | ThreatEventCreateWithoutCompanyInput[] | ThreatEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutCompanyInput | ThreatEventCreateOrConnectWithoutCompanyInput[]
    upsert?: ThreatEventUpsertWithWhereUniqueWithoutCompanyInput | ThreatEventUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ThreatEventCreateManyCompanyInputEnvelope
    set?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    disconnect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    delete?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    update?: ThreatEventUpdateWithWhereUniqueWithoutCompanyInput | ThreatEventUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ThreatEventUpdateManyWithWhereWithoutCompanyInput | ThreatEventUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ThreatEventScalarWhereInput | ThreatEventScalarWhereInput[]
  }

  export type RateLimitUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RateLimitCreateWithoutCompanyInput, RateLimitUncheckedCreateWithoutCompanyInput> | RateLimitCreateWithoutCompanyInput[] | RateLimitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RateLimitCreateOrConnectWithoutCompanyInput | RateLimitCreateOrConnectWithoutCompanyInput[]
    upsert?: RateLimitUpsertWithWhereUniqueWithoutCompanyInput | RateLimitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RateLimitCreateManyCompanyInputEnvelope
    set?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    disconnect?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    delete?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    connect?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    update?: RateLimitUpdateWithWhereUniqueWithoutCompanyInput | RateLimitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RateLimitUpdateManyWithWhereWithoutCompanyInput | RateLimitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RateLimitScalarWhereInput | RateLimitScalarWhereInput[]
  }

  export type PasswordPolicyUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<PasswordPolicyCreateWithoutCompanyInput, PasswordPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PasswordPolicyCreateOrConnectWithoutCompanyInput
    upsert?: PasswordPolicyUpsertWithoutCompanyInput
    disconnect?: PasswordPolicyWhereInput | boolean
    delete?: PasswordPolicyWhereInput | boolean
    connect?: PasswordPolicyWhereUniqueInput
    update?: XOR<XOR<PasswordPolicyUpdateToOneWithWhereWithoutCompanyInput, PasswordPolicyUpdateWithoutCompanyInput>, PasswordPolicyUncheckedUpdateWithoutCompanyInput>
  }

  export type DataRetentionPolicyUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<DataRetentionPolicyCreateWithoutCompanyInput, DataRetentionPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DataRetentionPolicyCreateOrConnectWithoutCompanyInput
    upsert?: DataRetentionPolicyUpsertWithoutCompanyInput
    disconnect?: DataRetentionPolicyWhereInput | boolean
    delete?: DataRetentionPolicyWhereInput | boolean
    connect?: DataRetentionPolicyWhereUniqueInput
    update?: XOR<XOR<DataRetentionPolicyUpdateToOneWithWhereWithoutCompanyInput, DataRetentionPolicyUpdateWithoutCompanyInput>, DataRetentionPolicyUncheckedUpdateWithoutCompanyInput>
  }

  export type DataExportUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DataExportCreateWithoutCompanyInput, DataExportUncheckedCreateWithoutCompanyInput> | DataExportCreateWithoutCompanyInput[] | DataExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutCompanyInput | DataExportCreateOrConnectWithoutCompanyInput[]
    upsert?: DataExportUpsertWithWhereUniqueWithoutCompanyInput | DataExportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DataExportCreateManyCompanyInputEnvelope
    set?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    disconnect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    delete?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    update?: DataExportUpdateWithWhereUniqueWithoutCompanyInput | DataExportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DataExportUpdateManyWithWhereWithoutCompanyInput | DataExportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DataExportScalarWhereInput | DataExportScalarWhereInput[]
  }

  export type DataDeletionRequestUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutCompanyInput, DataDeletionRequestUncheckedCreateWithoutCompanyInput> | DataDeletionRequestCreateWithoutCompanyInput[] | DataDeletionRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutCompanyInput | DataDeletionRequestCreateOrConnectWithoutCompanyInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutCompanyInput | DataDeletionRequestUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DataDeletionRequestCreateManyCompanyInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutCompanyInput | DataDeletionRequestUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutCompanyInput | DataDeletionRequestUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type AuditLogArchiveUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogArchiveCreateWithoutCompanyInput, AuditLogArchiveUncheckedCreateWithoutCompanyInput> | AuditLogArchiveCreateWithoutCompanyInput[] | AuditLogArchiveUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutCompanyInput | AuditLogArchiveCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogArchiveUpsertWithWhereUniqueWithoutCompanyInput | AuditLogArchiveUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogArchiveCreateManyCompanyInputEnvelope
    set?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    disconnect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    delete?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    update?: AuditLogArchiveUpdateWithWhereUniqueWithoutCompanyInput | AuditLogArchiveUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogArchiveUpdateManyWithWhereWithoutCompanyInput | AuditLogArchiveUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogArchiveScalarWhereInput | AuditLogArchiveScalarWhereInput[]
  }

  export type AuditLogSearchUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogSearchCreateWithoutCompanyInput, AuditLogSearchUncheckedCreateWithoutCompanyInput> | AuditLogSearchCreateWithoutCompanyInput[] | AuditLogSearchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutCompanyInput | AuditLogSearchCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogSearchUpsertWithWhereUniqueWithoutCompanyInput | AuditLogSearchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogSearchCreateManyCompanyInputEnvelope
    set?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    disconnect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    delete?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    update?: AuditLogSearchUpdateWithWhereUniqueWithoutCompanyInput | AuditLogSearchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogSearchUpdateManyWithWhereWithoutCompanyInput | AuditLogSearchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogSearchScalarWhereInput | AuditLogSearchScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCompanyInput | ReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCompanyInput | ReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCompanyInput | ReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportTemplateUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutCompanyInput, ReportTemplateUncheckedCreateWithoutCompanyInput> | ReportTemplateCreateWithoutCompanyInput[] | ReportTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCompanyInput | ReportTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutCompanyInput | ReportTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportTemplateCreateManyCompanyInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutCompanyInput | ReportTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutCompanyInput | ReportTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutCompanyInput, ScheduledReportUncheckedCreateWithoutCompanyInput> | ScheduledReportCreateWithoutCompanyInput[] | ScheduledReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCompanyInput | ScheduledReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutCompanyInput | ScheduledReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ScheduledReportCreateManyCompanyInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutCompanyInput | ScheduledReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutCompanyInput | ScheduledReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutCompanyInput | PasswordTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<IpWhitelistCreateWithoutCompanyInput, IpWhitelistUncheckedCreateWithoutCompanyInput> | IpWhitelistCreateWithoutCompanyInput[] | IpWhitelistUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCompanyInput | IpWhitelistCreateOrConnectWithoutCompanyInput[]
    upsert?: IpWhitelistUpsertWithWhereUniqueWithoutCompanyInput | IpWhitelistUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: IpWhitelistCreateManyCompanyInputEnvelope
    set?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    disconnect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    delete?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    update?: IpWhitelistUpdateWithWhereUniqueWithoutCompanyInput | IpWhitelistUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: IpWhitelistUpdateManyWithWhereWithoutCompanyInput | IpWhitelistUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
  }

  export type GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCompanyInput, GeographicRestrictionUncheckedCreateWithoutCompanyInput> | GeographicRestrictionCreateWithoutCompanyInput[] | GeographicRestrictionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCompanyInput | GeographicRestrictionCreateOrConnectWithoutCompanyInput[]
    upsert?: GeographicRestrictionUpsertWithWhereUniqueWithoutCompanyInput | GeographicRestrictionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GeographicRestrictionCreateManyCompanyInputEnvelope
    set?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    disconnect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    delete?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    update?: GeographicRestrictionUpdateWithWhereUniqueWithoutCompanyInput | GeographicRestrictionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GeographicRestrictionUpdateManyWithWhereWithoutCompanyInput | GeographicRestrictionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
  }

  export type ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ThreatEventCreateWithoutCompanyInput, ThreatEventUncheckedCreateWithoutCompanyInput> | ThreatEventCreateWithoutCompanyInput[] | ThreatEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutCompanyInput | ThreatEventCreateOrConnectWithoutCompanyInput[]
    upsert?: ThreatEventUpsertWithWhereUniqueWithoutCompanyInput | ThreatEventUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ThreatEventCreateManyCompanyInputEnvelope
    set?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    disconnect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    delete?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    update?: ThreatEventUpdateWithWhereUniqueWithoutCompanyInput | ThreatEventUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ThreatEventUpdateManyWithWhereWithoutCompanyInput | ThreatEventUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ThreatEventScalarWhereInput | ThreatEventScalarWhereInput[]
  }

  export type RateLimitUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RateLimitCreateWithoutCompanyInput, RateLimitUncheckedCreateWithoutCompanyInput> | RateLimitCreateWithoutCompanyInput[] | RateLimitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RateLimitCreateOrConnectWithoutCompanyInput | RateLimitCreateOrConnectWithoutCompanyInput[]
    upsert?: RateLimitUpsertWithWhereUniqueWithoutCompanyInput | RateLimitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RateLimitCreateManyCompanyInputEnvelope
    set?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    disconnect?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    delete?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    connect?: RateLimitWhereUniqueInput | RateLimitWhereUniqueInput[]
    update?: RateLimitUpdateWithWhereUniqueWithoutCompanyInput | RateLimitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RateLimitUpdateManyWithWhereWithoutCompanyInput | RateLimitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RateLimitScalarWhereInput | RateLimitScalarWhereInput[]
  }

  export type PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<PasswordPolicyCreateWithoutCompanyInput, PasswordPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PasswordPolicyCreateOrConnectWithoutCompanyInput
    upsert?: PasswordPolicyUpsertWithoutCompanyInput
    disconnect?: PasswordPolicyWhereInput | boolean
    delete?: PasswordPolicyWhereInput | boolean
    connect?: PasswordPolicyWhereUniqueInput
    update?: XOR<XOR<PasswordPolicyUpdateToOneWithWhereWithoutCompanyInput, PasswordPolicyUpdateWithoutCompanyInput>, PasswordPolicyUncheckedUpdateWithoutCompanyInput>
  }

  export type DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<DataRetentionPolicyCreateWithoutCompanyInput, DataRetentionPolicyUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DataRetentionPolicyCreateOrConnectWithoutCompanyInput
    upsert?: DataRetentionPolicyUpsertWithoutCompanyInput
    disconnect?: DataRetentionPolicyWhereInput | boolean
    delete?: DataRetentionPolicyWhereInput | boolean
    connect?: DataRetentionPolicyWhereUniqueInput
    update?: XOR<XOR<DataRetentionPolicyUpdateToOneWithWhereWithoutCompanyInput, DataRetentionPolicyUpdateWithoutCompanyInput>, DataRetentionPolicyUncheckedUpdateWithoutCompanyInput>
  }

  export type DataExportUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DataExportCreateWithoutCompanyInput, DataExportUncheckedCreateWithoutCompanyInput> | DataExportCreateWithoutCompanyInput[] | DataExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutCompanyInput | DataExportCreateOrConnectWithoutCompanyInput[]
    upsert?: DataExportUpsertWithWhereUniqueWithoutCompanyInput | DataExportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DataExportCreateManyCompanyInputEnvelope
    set?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    disconnect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    delete?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    update?: DataExportUpdateWithWhereUniqueWithoutCompanyInput | DataExportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DataExportUpdateManyWithWhereWithoutCompanyInput | DataExportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DataExportScalarWhereInput | DataExportScalarWhereInput[]
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutCompanyInput, DataDeletionRequestUncheckedCreateWithoutCompanyInput> | DataDeletionRequestCreateWithoutCompanyInput[] | DataDeletionRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutCompanyInput | DataDeletionRequestCreateOrConnectWithoutCompanyInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutCompanyInput | DataDeletionRequestUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DataDeletionRequestCreateManyCompanyInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutCompanyInput | DataDeletionRequestUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutCompanyInput | DataDeletionRequestUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogArchiveCreateWithoutCompanyInput, AuditLogArchiveUncheckedCreateWithoutCompanyInput> | AuditLogArchiveCreateWithoutCompanyInput[] | AuditLogArchiveUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutCompanyInput | AuditLogArchiveCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogArchiveUpsertWithWhereUniqueWithoutCompanyInput | AuditLogArchiveUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogArchiveCreateManyCompanyInputEnvelope
    set?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    disconnect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    delete?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    update?: AuditLogArchiveUpdateWithWhereUniqueWithoutCompanyInput | AuditLogArchiveUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogArchiveUpdateManyWithWhereWithoutCompanyInput | AuditLogArchiveUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogArchiveScalarWhereInput | AuditLogArchiveScalarWhereInput[]
  }

  export type AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogSearchCreateWithoutCompanyInput, AuditLogSearchUncheckedCreateWithoutCompanyInput> | AuditLogSearchCreateWithoutCompanyInput[] | AuditLogSearchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutCompanyInput | AuditLogSearchCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogSearchUpsertWithWhereUniqueWithoutCompanyInput | AuditLogSearchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogSearchCreateManyCompanyInputEnvelope
    set?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    disconnect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    delete?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    update?: AuditLogSearchUpdateWithWhereUniqueWithoutCompanyInput | AuditLogSearchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogSearchUpdateManyWithWhereWithoutCompanyInput | AuditLogSearchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogSearchScalarWhereInput | AuditLogSearchScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCompanyInput | ReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCompanyInput | ReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCompanyInput | ReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutCompanyInput, ReportTemplateUncheckedCreateWithoutCompanyInput> | ReportTemplateCreateWithoutCompanyInput[] | ReportTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCompanyInput | ReportTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutCompanyInput | ReportTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportTemplateCreateManyCompanyInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutCompanyInput | ReportTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutCompanyInput | ReportTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutCompanyInput, ScheduledReportUncheckedCreateWithoutCompanyInput> | ScheduledReportCreateWithoutCompanyInput[] | ScheduledReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCompanyInput | ScheduledReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutCompanyInput | ScheduledReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ScheduledReportCreateManyCompanyInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutCompanyInput | ScheduledReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutCompanyInput | ScheduledReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type PasswordCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordShareCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ThreatEventCreateNestedManyWithoutUserInput = {
    create?: XOR<ThreatEventCreateWithoutUserInput, ThreatEventUncheckedCreateWithoutUserInput> | ThreatEventCreateWithoutUserInput[] | ThreatEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutUserInput | ThreatEventCreateOrConnectWithoutUserInput[]
    createMany?: ThreatEventCreateManyUserInputEnvelope
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MfaCredentialCreateNestedManyWithoutUserInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
  }

  export type RecoveryCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
  }

  export type PasswordHistoryCreateNestedManyWithoutChangedByUserInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachCreateNestedManyWithoutCheckedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordBreachCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationPolicyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
  }

  export type PasswordRotationCreateNestedManyWithoutRotatedByUserInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type TemporaryPasswordShareCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutCreatorInput, TemporaryPasswordShareUncheckedCreateWithoutCreatorInput> | TemporaryPasswordShareCreateWithoutCreatorInput[] | TemporaryPasswordShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutCreatorInput | TemporaryPasswordShareCreateOrConnectWithoutCreatorInput[]
    createMany?: TemporaryPasswordShareCreateManyCreatorInputEnvelope
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
  }

  export type SavedSearchCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
  }

  export type SearchHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type PasswordTemplateCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatedByInput, ReportTemplateUncheckedCreateWithoutCreatedByInput> | ReportTemplateCreateWithoutCreatedByInput[] | ReportTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatedByInput | ReportTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportTemplateCreateManyCreatedByInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatedByInput, ScheduledReportUncheckedCreateWithoutCreatedByInput> | ScheduledReportCreateWithoutCreatedByInput[] | ScheduledReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatedByInput | ScheduledReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ScheduledReportCreateManyCreatedByInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type DataExportCreateNestedManyWithoutUserInput = {
    create?: XOR<DataExportCreateWithoutUserInput, DataExportUncheckedCreateWithoutUserInput> | DataExportCreateWithoutUserInput[] | DataExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutUserInput | DataExportCreateOrConnectWithoutUserInput[]
    createMany?: DataExportCreateManyUserInputEnvelope
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
  }

  export type DataDeletionRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type DataDeletionRequestCreateNestedManyWithoutProcessorInput = {
    create?: XOR<DataDeletionRequestCreateWithoutProcessorInput, DataDeletionRequestUncheckedCreateWithoutProcessorInput> | DataDeletionRequestCreateWithoutProcessorInput[] | DataDeletionRequestUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutProcessorInput | DataDeletionRequestCreateOrConnectWithoutProcessorInput[]
    createMany?: DataDeletionRequestCreateManyProcessorInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type AuditLogArchiveCreateNestedManyWithoutArchiverInput = {
    create?: XOR<AuditLogArchiveCreateWithoutArchiverInput, AuditLogArchiveUncheckedCreateWithoutArchiverInput> | AuditLogArchiveCreateWithoutArchiverInput[] | AuditLogArchiveUncheckedCreateWithoutArchiverInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutArchiverInput | AuditLogArchiveCreateOrConnectWithoutArchiverInput[]
    createMany?: AuditLogArchiveCreateManyArchiverInputEnvelope
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
  }

  export type AuditLogSearchCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogSearchCreateWithoutUserInput, AuditLogSearchUncheckedCreateWithoutUserInput> | AuditLogSearchCreateWithoutUserInput[] | AuditLogSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutUserInput | AuditLogSearchCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogSearchCreateManyUserInputEnvelope
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
  }

  export type EmailVerificationTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SecurityQuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
  }

  export type IpWhitelistCreateNestedManyWithoutUserInput = {
    create?: XOR<IpWhitelistCreateWithoutUserInput, IpWhitelistUncheckedCreateWithoutUserInput> | IpWhitelistCreateWithoutUserInput[] | IpWhitelistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutUserInput | IpWhitelistCreateOrConnectWithoutUserInput[]
    createMany?: IpWhitelistCreateManyUserInputEnvelope
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
  }

  export type GeographicRestrictionCreateNestedManyWithoutUserInput = {
    create?: XOR<GeographicRestrictionCreateWithoutUserInput, GeographicRestrictionUncheckedCreateWithoutUserInput> | GeographicRestrictionCreateWithoutUserInput[] | GeographicRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutUserInput | GeographicRestrictionCreateOrConnectWithoutUserInput[]
    createMany?: GeographicRestrictionCreateManyUserInputEnvelope
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
  }

  export type IpWhitelistCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IpWhitelistCreateWithoutCreatorInput, IpWhitelistUncheckedCreateWithoutCreatorInput> | IpWhitelistCreateWithoutCreatorInput[] | IpWhitelistUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCreatorInput | IpWhitelistCreateOrConnectWithoutCreatorInput[]
    createMany?: IpWhitelistCreateManyCreatorInputEnvelope
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
  }

  export type GeographicRestrictionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCreatorInput, GeographicRestrictionUncheckedCreateWithoutCreatorInput> | GeographicRestrictionCreateWithoutCreatorInput[] | GeographicRestrictionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCreatorInput | GeographicRestrictionCreateOrConnectWithoutCreatorInput[]
    createMany?: GeographicRestrictionCreateManyCreatorInputEnvelope
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
  }

  export type PasswordUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordShareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ThreatEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ThreatEventCreateWithoutUserInput, ThreatEventUncheckedCreateWithoutUserInput> | ThreatEventCreateWithoutUserInput[] | ThreatEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutUserInput | ThreatEventCreateOrConnectWithoutUserInput[]
    createMany?: ThreatEventCreateManyUserInputEnvelope
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MfaCredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
  }

  export type RecoveryCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
  }

  export type PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
  }

  export type PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutCreatorInput, TemporaryPasswordShareUncheckedCreateWithoutCreatorInput> | TemporaryPasswordShareCreateWithoutCreatorInput[] | TemporaryPasswordShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutCreatorInput | TemporaryPasswordShareCreateOrConnectWithoutCreatorInput[]
    createMany?: TemporaryPasswordShareCreateManyCreatorInputEnvelope
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
  }

  export type SavedSearchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatedByInput, ReportTemplateUncheckedCreateWithoutCreatedByInput> | ReportTemplateCreateWithoutCreatedByInput[] | ReportTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatedByInput | ReportTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportTemplateCreateManyCreatedByInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatedByInput, ScheduledReportUncheckedCreateWithoutCreatedByInput> | ScheduledReportCreateWithoutCreatedByInput[] | ScheduledReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatedByInput | ScheduledReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ScheduledReportCreateManyCreatedByInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type DataExportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataExportCreateWithoutUserInput, DataExportUncheckedCreateWithoutUserInput> | DataExportCreateWithoutUserInput[] | DataExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutUserInput | DataExportCreateOrConnectWithoutUserInput[]
    createMany?: DataExportCreateManyUserInputEnvelope
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
  }

  export type DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput = {
    create?: XOR<DataDeletionRequestCreateWithoutProcessorInput, DataDeletionRequestUncheckedCreateWithoutProcessorInput> | DataDeletionRequestCreateWithoutProcessorInput[] | DataDeletionRequestUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutProcessorInput | DataDeletionRequestCreateOrConnectWithoutProcessorInput[]
    createMany?: DataDeletionRequestCreateManyProcessorInputEnvelope
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
  }

  export type AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput = {
    create?: XOR<AuditLogArchiveCreateWithoutArchiverInput, AuditLogArchiveUncheckedCreateWithoutArchiverInput> | AuditLogArchiveCreateWithoutArchiverInput[] | AuditLogArchiveUncheckedCreateWithoutArchiverInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutArchiverInput | AuditLogArchiveCreateOrConnectWithoutArchiverInput[]
    createMany?: AuditLogArchiveCreateManyArchiverInputEnvelope
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
  }

  export type AuditLogSearchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogSearchCreateWithoutUserInput, AuditLogSearchUncheckedCreateWithoutUserInput> | AuditLogSearchCreateWithoutUserInput[] | AuditLogSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutUserInput | AuditLogSearchCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogSearchCreateManyUserInputEnvelope
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
  }

  export type EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SecurityQuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
  }

  export type IpWhitelistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IpWhitelistCreateWithoutUserInput, IpWhitelistUncheckedCreateWithoutUserInput> | IpWhitelistCreateWithoutUserInput[] | IpWhitelistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutUserInput | IpWhitelistCreateOrConnectWithoutUserInput[]
    createMany?: IpWhitelistCreateManyUserInputEnvelope
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
  }

  export type GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GeographicRestrictionCreateWithoutUserInput, GeographicRestrictionUncheckedCreateWithoutUserInput> | GeographicRestrictionCreateWithoutUserInput[] | GeographicRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutUserInput | GeographicRestrictionCreateOrConnectWithoutUserInput[]
    createMany?: GeographicRestrictionCreateManyUserInputEnvelope
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
  }

  export type IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IpWhitelistCreateWithoutCreatorInput, IpWhitelistUncheckedCreateWithoutCreatorInput> | IpWhitelistCreateWithoutCreatorInput[] | IpWhitelistUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCreatorInput | IpWhitelistCreateOrConnectWithoutCreatorInput[]
    createMany?: IpWhitelistCreateManyCreatorInputEnvelope
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
  }

  export type GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCreatorInput, GeographicRestrictionUncheckedCreateWithoutCreatorInput> | GeographicRestrictionCreateWithoutCreatorInput[] | GeographicRestrictionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCreatorInput | GeographicRestrictionCreateOrConnectWithoutCreatorInput[]
    createMany?: GeographicRestrictionCreateManyCreatorInputEnvelope
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumMfaMethodFieldUpdateOperationsInput = {
    set?: $Enums.MfaMethod | null
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type PasswordUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutOwnerInput | PasswordUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutOwnerInput | PasswordUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutOwnerInput | PasswordUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordShareUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutUserInput | PasswordShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutUserInput | PasswordShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutUserInput | PasswordShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ThreatEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<ThreatEventCreateWithoutUserInput, ThreatEventUncheckedCreateWithoutUserInput> | ThreatEventCreateWithoutUserInput[] | ThreatEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutUserInput | ThreatEventCreateOrConnectWithoutUserInput[]
    upsert?: ThreatEventUpsertWithWhereUniqueWithoutUserInput | ThreatEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ThreatEventCreateManyUserInputEnvelope
    set?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    disconnect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    delete?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    update?: ThreatEventUpdateWithWhereUniqueWithoutUserInput | ThreatEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ThreatEventUpdateManyWithWhereWithoutUserInput | ThreatEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ThreatEventScalarWhereInput | ThreatEventScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MfaCredentialUpdateManyWithoutUserNestedInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    upsert?: MfaCredentialUpsertWithWhereUniqueWithoutUserInput | MfaCredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    set?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    disconnect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    delete?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    update?: MfaCredentialUpdateWithWhereUniqueWithoutUserInput | MfaCredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MfaCredentialUpdateManyWithWhereWithoutUserInput | MfaCredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
  }

  export type RecoveryCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    upsert?: RecoveryCodeUpsertWithWhereUniqueWithoutUserInput | RecoveryCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    set?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    disconnect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    delete?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    update?: RecoveryCodeUpdateWithWhereUniqueWithoutUserInput | RecoveryCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecoveryCodeUpdateManyWithWhereWithoutUserInput | RecoveryCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
  }

  export type PasswordHistoryUpdateManyWithoutChangedByUserNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput | PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUpdateManyWithoutCheckedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput | PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordBreachUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput | PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    set?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    disconnect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    delete?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    update?: PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput | PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
  }

  export type PasswordRotationUpdateManyWithoutRotatedByUserNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput | PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutCreatorInput, TemporaryPasswordShareUncheckedCreateWithoutCreatorInput> | TemporaryPasswordShareCreateWithoutCreatorInput[] | TemporaryPasswordShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutCreatorInput | TemporaryPasswordShareCreateOrConnectWithoutCreatorInput[]
    upsert?: TemporaryPasswordShareUpsertWithWhereUniqueWithoutCreatorInput | TemporaryPasswordShareUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TemporaryPasswordShareCreateManyCreatorInputEnvelope
    set?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    disconnect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    delete?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    update?: TemporaryPasswordShareUpdateWithWhereUniqueWithoutCreatorInput | TemporaryPasswordShareUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TemporaryPasswordShareUpdateManyWithWhereWithoutCreatorInput | TemporaryPasswordShareUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TemporaryPasswordShareScalarWhereInput | TemporaryPasswordShareScalarWhereInput[]
  }

  export type SavedSearchUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    upsert?: SavedSearchUpsertWithWhereUniqueWithoutUserInput | SavedSearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    set?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    disconnect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    delete?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    update?: SavedSearchUpdateWithWhereUniqueWithoutUserInput | SavedSearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedSearchUpdateManyWithWhereWithoutUserInput | SavedSearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
  }

  export type SearchHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type PasswordTemplateUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutOwnerInput | PasswordTemplateUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatedByInput | ReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatedByInput | ReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatedByInput | ReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatedByInput, ReportTemplateUncheckedCreateWithoutCreatedByInput> | ReportTemplateCreateWithoutCreatedByInput[] | ReportTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatedByInput | ReportTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutCreatedByInput | ReportTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportTemplateCreateManyCreatedByInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutCreatedByInput | ReportTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutCreatedByInput | ReportTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatedByInput, ScheduledReportUncheckedCreateWithoutCreatedByInput> | ScheduledReportCreateWithoutCreatedByInput[] | ScheduledReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatedByInput | ScheduledReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutCreatedByInput | ScheduledReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ScheduledReportCreateManyCreatedByInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutCreatedByInput | ScheduledReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutCreatedByInput | ScheduledReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutCreatedByInput | RoleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutCreatedByInput | RoleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutCreatedByInput | RoleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type DataExportUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataExportCreateWithoutUserInput, DataExportUncheckedCreateWithoutUserInput> | DataExportCreateWithoutUserInput[] | DataExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutUserInput | DataExportCreateOrConnectWithoutUserInput[]
    upsert?: DataExportUpsertWithWhereUniqueWithoutUserInput | DataExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataExportCreateManyUserInputEnvelope
    set?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    disconnect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    delete?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    update?: DataExportUpdateWithWhereUniqueWithoutUserInput | DataExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataExportUpdateManyWithWhereWithoutUserInput | DataExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataExportScalarWhereInput | DataExportScalarWhereInput[]
  }

  export type DataDeletionRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput | DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput | DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutUserInput | DataDeletionRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type DataDeletionRequestUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutProcessorInput, DataDeletionRequestUncheckedCreateWithoutProcessorInput> | DataDeletionRequestCreateWithoutProcessorInput[] | DataDeletionRequestUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutProcessorInput | DataDeletionRequestCreateOrConnectWithoutProcessorInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutProcessorInput | DataDeletionRequestUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: DataDeletionRequestCreateManyProcessorInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutProcessorInput | DataDeletionRequestUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutProcessorInput | DataDeletionRequestUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type AuditLogArchiveUpdateManyWithoutArchiverNestedInput = {
    create?: XOR<AuditLogArchiveCreateWithoutArchiverInput, AuditLogArchiveUncheckedCreateWithoutArchiverInput> | AuditLogArchiveCreateWithoutArchiverInput[] | AuditLogArchiveUncheckedCreateWithoutArchiverInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutArchiverInput | AuditLogArchiveCreateOrConnectWithoutArchiverInput[]
    upsert?: AuditLogArchiveUpsertWithWhereUniqueWithoutArchiverInput | AuditLogArchiveUpsertWithWhereUniqueWithoutArchiverInput[]
    createMany?: AuditLogArchiveCreateManyArchiverInputEnvelope
    set?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    disconnect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    delete?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    update?: AuditLogArchiveUpdateWithWhereUniqueWithoutArchiverInput | AuditLogArchiveUpdateWithWhereUniqueWithoutArchiverInput[]
    updateMany?: AuditLogArchiveUpdateManyWithWhereWithoutArchiverInput | AuditLogArchiveUpdateManyWithWhereWithoutArchiverInput[]
    deleteMany?: AuditLogArchiveScalarWhereInput | AuditLogArchiveScalarWhereInput[]
  }

  export type AuditLogSearchUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogSearchCreateWithoutUserInput, AuditLogSearchUncheckedCreateWithoutUserInput> | AuditLogSearchCreateWithoutUserInput[] | AuditLogSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutUserInput | AuditLogSearchCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogSearchUpsertWithWhereUniqueWithoutUserInput | AuditLogSearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogSearchCreateManyUserInputEnvelope
    set?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    disconnect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    delete?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    update?: AuditLogSearchUpdateWithWhereUniqueWithoutUserInput | AuditLogSearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogSearchUpdateManyWithWhereWithoutUserInput | AuditLogSearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogSearchScalarWhereInput | AuditLogSearchScalarWhereInput[]
  }

  export type EmailVerificationTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SecurityQuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    upsert?: SecurityQuestionUpsertWithWhereUniqueWithoutUserInput | SecurityQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    set?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    disconnect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    delete?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    update?: SecurityQuestionUpdateWithWhereUniqueWithoutUserInput | SecurityQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityQuestionUpdateManyWithWhereWithoutUserInput | SecurityQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
  }

  export type IpWhitelistUpdateManyWithoutUserNestedInput = {
    create?: XOR<IpWhitelistCreateWithoutUserInput, IpWhitelistUncheckedCreateWithoutUserInput> | IpWhitelistCreateWithoutUserInput[] | IpWhitelistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutUserInput | IpWhitelistCreateOrConnectWithoutUserInput[]
    upsert?: IpWhitelistUpsertWithWhereUniqueWithoutUserInput | IpWhitelistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IpWhitelistCreateManyUserInputEnvelope
    set?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    disconnect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    delete?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    update?: IpWhitelistUpdateWithWhereUniqueWithoutUserInput | IpWhitelistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IpWhitelistUpdateManyWithWhereWithoutUserInput | IpWhitelistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
  }

  export type GeographicRestrictionUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeographicRestrictionCreateWithoutUserInput, GeographicRestrictionUncheckedCreateWithoutUserInput> | GeographicRestrictionCreateWithoutUserInput[] | GeographicRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutUserInput | GeographicRestrictionCreateOrConnectWithoutUserInput[]
    upsert?: GeographicRestrictionUpsertWithWhereUniqueWithoutUserInput | GeographicRestrictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeographicRestrictionCreateManyUserInputEnvelope
    set?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    disconnect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    delete?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    update?: GeographicRestrictionUpdateWithWhereUniqueWithoutUserInput | GeographicRestrictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeographicRestrictionUpdateManyWithWhereWithoutUserInput | GeographicRestrictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
  }

  export type IpWhitelistUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IpWhitelistCreateWithoutCreatorInput, IpWhitelistUncheckedCreateWithoutCreatorInput> | IpWhitelistCreateWithoutCreatorInput[] | IpWhitelistUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCreatorInput | IpWhitelistCreateOrConnectWithoutCreatorInput[]
    upsert?: IpWhitelistUpsertWithWhereUniqueWithoutCreatorInput | IpWhitelistUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IpWhitelistCreateManyCreatorInputEnvelope
    set?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    disconnect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    delete?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    update?: IpWhitelistUpdateWithWhereUniqueWithoutCreatorInput | IpWhitelistUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IpWhitelistUpdateManyWithWhereWithoutCreatorInput | IpWhitelistUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
  }

  export type GeographicRestrictionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCreatorInput, GeographicRestrictionUncheckedCreateWithoutCreatorInput> | GeographicRestrictionCreateWithoutCreatorInput[] | GeographicRestrictionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCreatorInput | GeographicRestrictionCreateOrConnectWithoutCreatorInput[]
    upsert?: GeographicRestrictionUpsertWithWhereUniqueWithoutCreatorInput | GeographicRestrictionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GeographicRestrictionCreateManyCreatorInputEnvelope
    set?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    disconnect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    delete?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    update?: GeographicRestrictionUpdateWithWhereUniqueWithoutCreatorInput | GeographicRestrictionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GeographicRestrictionUpdateManyWithWhereWithoutCreatorInput | GeographicRestrictionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
  }

  export type PasswordUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutOwnerInput | PasswordUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutOwnerInput | PasswordUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutOwnerInput | PasswordUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordShareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutUserInput | PasswordShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutUserInput | PasswordShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutUserInput | PasswordShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ThreatEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ThreatEventCreateWithoutUserInput, ThreatEventUncheckedCreateWithoutUserInput> | ThreatEventCreateWithoutUserInput[] | ThreatEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThreatEventCreateOrConnectWithoutUserInput | ThreatEventCreateOrConnectWithoutUserInput[]
    upsert?: ThreatEventUpsertWithWhereUniqueWithoutUserInput | ThreatEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ThreatEventCreateManyUserInputEnvelope
    set?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    disconnect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    delete?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    connect?: ThreatEventWhereUniqueInput | ThreatEventWhereUniqueInput[]
    update?: ThreatEventUpdateWithWhereUniqueWithoutUserInput | ThreatEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ThreatEventUpdateManyWithWhereWithoutUserInput | ThreatEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ThreatEventScalarWhereInput | ThreatEventScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MfaCredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    upsert?: MfaCredentialUpsertWithWhereUniqueWithoutUserInput | MfaCredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    set?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    disconnect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    delete?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    update?: MfaCredentialUpdateWithWhereUniqueWithoutUserInput | MfaCredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MfaCredentialUpdateManyWithWhereWithoutUserInput | MfaCredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
  }

  export type RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    upsert?: RecoveryCodeUpsertWithWhereUniqueWithoutUserInput | RecoveryCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    set?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    disconnect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    delete?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    update?: RecoveryCodeUpdateWithWhereUniqueWithoutUserInput | RecoveryCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecoveryCodeUpdateManyWithWhereWithoutUserInput | RecoveryCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput | PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput | PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput | PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    set?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    disconnect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    delete?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    update?: PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput | PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
  }

  export type PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput | PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutCreatorInput, TemporaryPasswordShareUncheckedCreateWithoutCreatorInput> | TemporaryPasswordShareCreateWithoutCreatorInput[] | TemporaryPasswordShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutCreatorInput | TemporaryPasswordShareCreateOrConnectWithoutCreatorInput[]
    upsert?: TemporaryPasswordShareUpsertWithWhereUniqueWithoutCreatorInput | TemporaryPasswordShareUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TemporaryPasswordShareCreateManyCreatorInputEnvelope
    set?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    disconnect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    delete?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    update?: TemporaryPasswordShareUpdateWithWhereUniqueWithoutCreatorInput | TemporaryPasswordShareUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TemporaryPasswordShareUpdateManyWithWhereWithoutCreatorInput | TemporaryPasswordShareUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TemporaryPasswordShareScalarWhereInput | TemporaryPasswordShareScalarWhereInput[]
  }

  export type SavedSearchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    upsert?: SavedSearchUpsertWithWhereUniqueWithoutUserInput | SavedSearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    set?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    disconnect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    delete?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    update?: SavedSearchUpdateWithWhereUniqueWithoutUserInput | SavedSearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedSearchUpdateManyWithWhereWithoutUserInput | SavedSearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutOwnerInput | PasswordTemplateUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatedByInput | ReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatedByInput | ReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatedByInput | ReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatedByInput, ReportTemplateUncheckedCreateWithoutCreatedByInput> | ReportTemplateCreateWithoutCreatedByInput[] | ReportTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatedByInput | ReportTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutCreatedByInput | ReportTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportTemplateCreateManyCreatedByInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutCreatedByInput | ReportTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutCreatedByInput | ReportTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatedByInput, ScheduledReportUncheckedCreateWithoutCreatedByInput> | ScheduledReportCreateWithoutCreatedByInput[] | ScheduledReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatedByInput | ScheduledReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutCreatedByInput | ScheduledReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ScheduledReportCreateManyCreatedByInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutCreatedByInput | ScheduledReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutCreatedByInput | ScheduledReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutCreatedByInput | RoleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutCreatedByInput | RoleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutCreatedByInput | RoleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type DataExportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataExportCreateWithoutUserInput, DataExportUncheckedCreateWithoutUserInput> | DataExportCreateWithoutUserInput[] | DataExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportCreateOrConnectWithoutUserInput | DataExportCreateOrConnectWithoutUserInput[]
    upsert?: DataExportUpsertWithWhereUniqueWithoutUserInput | DataExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataExportCreateManyUserInputEnvelope
    set?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    disconnect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    delete?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    connect?: DataExportWhereUniqueInput | DataExportWhereUniqueInput[]
    update?: DataExportUpdateWithWhereUniqueWithoutUserInput | DataExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataExportUpdateManyWithWhereWithoutUserInput | DataExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataExportScalarWhereInput | DataExportScalarWhereInput[]
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput> | DataDeletionRequestCreateWithoutUserInput[] | DataDeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutUserInput | DataDeletionRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput | DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataDeletionRequestCreateManyUserInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput | DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutUserInput | DataDeletionRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<DataDeletionRequestCreateWithoutProcessorInput, DataDeletionRequestUncheckedCreateWithoutProcessorInput> | DataDeletionRequestCreateWithoutProcessorInput[] | DataDeletionRequestUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: DataDeletionRequestCreateOrConnectWithoutProcessorInput | DataDeletionRequestCreateOrConnectWithoutProcessorInput[]
    upsert?: DataDeletionRequestUpsertWithWhereUniqueWithoutProcessorInput | DataDeletionRequestUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: DataDeletionRequestCreateManyProcessorInputEnvelope
    set?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    disconnect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    delete?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    connect?: DataDeletionRequestWhereUniqueInput | DataDeletionRequestWhereUniqueInput[]
    update?: DataDeletionRequestUpdateWithWhereUniqueWithoutProcessorInput | DataDeletionRequestUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: DataDeletionRequestUpdateManyWithWhereWithoutProcessorInput | DataDeletionRequestUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
  }

  export type AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput = {
    create?: XOR<AuditLogArchiveCreateWithoutArchiverInput, AuditLogArchiveUncheckedCreateWithoutArchiverInput> | AuditLogArchiveCreateWithoutArchiverInput[] | AuditLogArchiveUncheckedCreateWithoutArchiverInput[]
    connectOrCreate?: AuditLogArchiveCreateOrConnectWithoutArchiverInput | AuditLogArchiveCreateOrConnectWithoutArchiverInput[]
    upsert?: AuditLogArchiveUpsertWithWhereUniqueWithoutArchiverInput | AuditLogArchiveUpsertWithWhereUniqueWithoutArchiverInput[]
    createMany?: AuditLogArchiveCreateManyArchiverInputEnvelope
    set?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    disconnect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    delete?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    connect?: AuditLogArchiveWhereUniqueInput | AuditLogArchiveWhereUniqueInput[]
    update?: AuditLogArchiveUpdateWithWhereUniqueWithoutArchiverInput | AuditLogArchiveUpdateWithWhereUniqueWithoutArchiverInput[]
    updateMany?: AuditLogArchiveUpdateManyWithWhereWithoutArchiverInput | AuditLogArchiveUpdateManyWithWhereWithoutArchiverInput[]
    deleteMany?: AuditLogArchiveScalarWhereInput | AuditLogArchiveScalarWhereInput[]
  }

  export type AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogSearchCreateWithoutUserInput, AuditLogSearchUncheckedCreateWithoutUserInput> | AuditLogSearchCreateWithoutUserInput[] | AuditLogSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogSearchCreateOrConnectWithoutUserInput | AuditLogSearchCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogSearchUpsertWithWhereUniqueWithoutUserInput | AuditLogSearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogSearchCreateManyUserInputEnvelope
    set?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    disconnect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    delete?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    connect?: AuditLogSearchWhereUniqueInput | AuditLogSearchWhereUniqueInput[]
    update?: AuditLogSearchUpdateWithWhereUniqueWithoutUserInput | AuditLogSearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogSearchUpdateManyWithWhereWithoutUserInput | AuditLogSearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogSearchScalarWhereInput | AuditLogSearchScalarWhereInput[]
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    upsert?: SecurityQuestionUpsertWithWhereUniqueWithoutUserInput | SecurityQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    set?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    disconnect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    delete?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    update?: SecurityQuestionUpdateWithWhereUniqueWithoutUserInput | SecurityQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityQuestionUpdateManyWithWhereWithoutUserInput | SecurityQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
  }

  export type IpWhitelistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IpWhitelistCreateWithoutUserInput, IpWhitelistUncheckedCreateWithoutUserInput> | IpWhitelistCreateWithoutUserInput[] | IpWhitelistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutUserInput | IpWhitelistCreateOrConnectWithoutUserInput[]
    upsert?: IpWhitelistUpsertWithWhereUniqueWithoutUserInput | IpWhitelistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IpWhitelistCreateManyUserInputEnvelope
    set?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    disconnect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    delete?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    update?: IpWhitelistUpdateWithWhereUniqueWithoutUserInput | IpWhitelistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IpWhitelistUpdateManyWithWhereWithoutUserInput | IpWhitelistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
  }

  export type GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeographicRestrictionCreateWithoutUserInput, GeographicRestrictionUncheckedCreateWithoutUserInput> | GeographicRestrictionCreateWithoutUserInput[] | GeographicRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutUserInput | GeographicRestrictionCreateOrConnectWithoutUserInput[]
    upsert?: GeographicRestrictionUpsertWithWhereUniqueWithoutUserInput | GeographicRestrictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeographicRestrictionCreateManyUserInputEnvelope
    set?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    disconnect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    delete?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    update?: GeographicRestrictionUpdateWithWhereUniqueWithoutUserInput | GeographicRestrictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeographicRestrictionUpdateManyWithWhereWithoutUserInput | GeographicRestrictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
  }

  export type IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IpWhitelistCreateWithoutCreatorInput, IpWhitelistUncheckedCreateWithoutCreatorInput> | IpWhitelistCreateWithoutCreatorInput[] | IpWhitelistUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IpWhitelistCreateOrConnectWithoutCreatorInput | IpWhitelistCreateOrConnectWithoutCreatorInput[]
    upsert?: IpWhitelistUpsertWithWhereUniqueWithoutCreatorInput | IpWhitelistUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IpWhitelistCreateManyCreatorInputEnvelope
    set?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    disconnect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    delete?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    connect?: IpWhitelistWhereUniqueInput | IpWhitelistWhereUniqueInput[]
    update?: IpWhitelistUpdateWithWhereUniqueWithoutCreatorInput | IpWhitelistUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IpWhitelistUpdateManyWithWhereWithoutCreatorInput | IpWhitelistUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
  }

  export type GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GeographicRestrictionCreateWithoutCreatorInput, GeographicRestrictionUncheckedCreateWithoutCreatorInput> | GeographicRestrictionCreateWithoutCreatorInput[] | GeographicRestrictionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GeographicRestrictionCreateOrConnectWithoutCreatorInput | GeographicRestrictionCreateOrConnectWithoutCreatorInput[]
    upsert?: GeographicRestrictionUpsertWithWhereUniqueWithoutCreatorInput | GeographicRestrictionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GeographicRestrictionCreateManyCreatorInputEnvelope
    set?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    disconnect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    delete?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    connect?: GeographicRestrictionWhereUniqueInput | GeographicRestrictionWhereUniqueInput[]
    update?: GeographicRestrictionUpdateWithWhereUniqueWithoutCreatorInput | GeographicRestrictionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GeographicRestrictionUpdateManyWithWhereWithoutCreatorInput | GeographicRestrictionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutOwnedPasswordsInput = {
    create?: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedPasswordsInput
    connect?: UserWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutPasswordsInput = {
    create?: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutPasswordsInput
    connect?: FolderWhereUniqueInput
  }

  export type PasswordShareCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TemporaryPasswordShareCreateNestedManyWithoutPasswordInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutPasswordInput, TemporaryPasswordShareUncheckedCreateWithoutPasswordInput> | TemporaryPasswordShareCreateWithoutPasswordInput[] | TemporaryPasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutPasswordInput | TemporaryPasswordShareCreateOrConnectWithoutPasswordInput[]
    createMany?: TemporaryPasswordShareCreateManyPasswordInputEnvelope
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
  }

  export type PasswordTagCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordHistoryCreateNestedManyWithoutPasswordEntryInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutPasswordsInput
    connect?: PasswordRotationPolicyWhereUniqueInput
  }

  export type PasswordShareUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutPasswordInput, TemporaryPasswordShareUncheckedCreateWithoutPasswordInput> | TemporaryPasswordShareCreateWithoutPasswordInput[] | TemporaryPasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutPasswordInput | TemporaryPasswordShareCreateOrConnectWithoutPasswordInput[]
    createMany?: TemporaryPasswordShareCreateManyPasswordInputEnvelope
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
  }

  export type PasswordTagUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type EnumPasswordStrengthFieldUpdateOperationsInput = {
    set?: $Enums.PasswordStrength
  }

  export type UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedPasswordsInput
    upsert?: UserUpsertWithoutOwnedPasswordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedPasswordsInput, UserUpdateWithoutOwnedPasswordsInput>, UserUncheckedUpdateWithoutOwnedPasswordsInput>
  }

  export type FolderUpdateOneWithoutPasswordsNestedInput = {
    create?: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutPasswordsInput
    upsert?: FolderUpsertWithoutPasswordsInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutPasswordsInput, FolderUpdateWithoutPasswordsInput>, FolderUncheckedUpdateWithoutPasswordsInput>
  }

  export type PasswordShareUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutPasswordInput | PasswordShareUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutPasswordInput | PasswordShareUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutPasswordInput | PasswordShareUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutPasswordInput, TemporaryPasswordShareUncheckedCreateWithoutPasswordInput> | TemporaryPasswordShareCreateWithoutPasswordInput[] | TemporaryPasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutPasswordInput | TemporaryPasswordShareCreateOrConnectWithoutPasswordInput[]
    upsert?: TemporaryPasswordShareUpsertWithWhereUniqueWithoutPasswordInput | TemporaryPasswordShareUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: TemporaryPasswordShareCreateManyPasswordInputEnvelope
    set?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    disconnect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    delete?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    update?: TemporaryPasswordShareUpdateWithWhereUniqueWithoutPasswordInput | TemporaryPasswordShareUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: TemporaryPasswordShareUpdateManyWithWhereWithoutPasswordInput | TemporaryPasswordShareUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: TemporaryPasswordShareScalarWhereInput | TemporaryPasswordShareScalarWhereInput[]
  }

  export type PasswordTagUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutPasswordInput | PasswordTagUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutPasswordInput | PasswordTagUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutPasswordInput | PasswordTagUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput | PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput | PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput | PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutPasswordInput | PasswordBreachUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput | PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput | PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPasswordInput | PasswordRotationUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutPasswordsInput
    upsert?: PasswordRotationPolicyUpsertWithoutPasswordsInput
    disconnect?: PasswordRotationPolicyWhereInput | boolean
    delete?: PasswordRotationPolicyWhereInput | boolean
    connect?: PasswordRotationPolicyWhereUniqueInput
    update?: XOR<XOR<PasswordRotationPolicyUpdateToOneWithWhereWithoutPasswordsInput, PasswordRotationPolicyUpdateWithoutPasswordsInput>, PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput>
  }

  export type PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutPasswordInput | PasswordShareUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutPasswordInput | PasswordShareUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutPasswordInput | PasswordShareUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<TemporaryPasswordShareCreateWithoutPasswordInput, TemporaryPasswordShareUncheckedCreateWithoutPasswordInput> | TemporaryPasswordShareCreateWithoutPasswordInput[] | TemporaryPasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: TemporaryPasswordShareCreateOrConnectWithoutPasswordInput | TemporaryPasswordShareCreateOrConnectWithoutPasswordInput[]
    upsert?: TemporaryPasswordShareUpsertWithWhereUniqueWithoutPasswordInput | TemporaryPasswordShareUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: TemporaryPasswordShareCreateManyPasswordInputEnvelope
    set?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    disconnect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    delete?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    connect?: TemporaryPasswordShareWhereUniqueInput | TemporaryPasswordShareWhereUniqueInput[]
    update?: TemporaryPasswordShareUpdateWithWhereUniqueWithoutPasswordInput | TemporaryPasswordShareUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: TemporaryPasswordShareUpdateManyWithWhereWithoutPasswordInput | TemporaryPasswordShareUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: TemporaryPasswordShareScalarWhereInput | TemporaryPasswordShareScalarWhereInput[]
  }

  export type PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutPasswordInput | PasswordTagUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutPasswordInput | PasswordTagUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutPasswordInput | PasswordTagUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput | PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput | PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput | PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutPasswordInput | PasswordBreachUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput | PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput | PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPasswordInput | PasswordRotationUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutHistoryInput = {
    create?: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutHistoryInput
    connect?: PasswordWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordHistoryInput = {
    create?: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type PasswordUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutHistoryInput
    upsert?: PasswordUpsertWithoutHistoryInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutHistoryInput, PasswordUpdateWithoutHistoryInput>, PasswordUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutPasswordHistoryNestedInput = {
    create?: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordHistoryInput
    upsert?: UserUpsertWithoutPasswordHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordHistoryInput, UserUpdateWithoutPasswordHistoryInput>, UserUncheckedUpdateWithoutPasswordHistoryInput>
  }

  export type PasswordCreateNestedOneWithoutBreachesInput = {
    create?: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutBreachesInput
    connect?: PasswordWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordBreachesCheckedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesCheckedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordBreachesResolvedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesResolvedInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PasswordUpdateOneRequiredWithoutBreachesNestedInput = {
    create?: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutBreachesInput
    upsert?: PasswordUpsertWithoutBreachesInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutBreachesInput, PasswordUpdateWithoutBreachesInput>, PasswordUncheckedUpdateWithoutBreachesInput>
  }

  export type UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesCheckedInput
    upsert?: UserUpsertWithoutPasswordBreachesCheckedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordBreachesCheckedInput, UserUpdateWithoutPasswordBreachesCheckedInput>, UserUncheckedUpdateWithoutPasswordBreachesCheckedInput>
  }

  export type UserUpdateOneWithoutPasswordBreachesResolvedNestedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesResolvedInput
    upsert?: UserUpsertWithoutPasswordBreachesResolvedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordBreachesResolvedInput, UserUpdateWithoutPasswordBreachesResolvedInput>, UserUncheckedUpdateWithoutPasswordBreachesResolvedInput>
  }

  export type UserCreateNestedOneWithoutRotationPoliciesInput = {
    create?: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationPoliciesInput
    connect?: UserWhereUniqueInput
  }

  export type PasswordCreateNestedManyWithoutRotationPolicyInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordRotationCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutRotationPoliciesNestedInput = {
    create?: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationPoliciesInput
    upsert?: UserUpsertWithoutRotationPoliciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRotationPoliciesInput, UserUpdateWithoutRotationPoliciesInput>, UserUncheckedUpdateWithoutRotationPoliciesInput>
  }

  export type PasswordUpdateManyWithoutRotationPolicyNestedInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput | PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput | PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutRotationPolicyInput | PasswordUpdateManyWithWhereWithoutRotationPolicyInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordRotationUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput | PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput | PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPolicyInput | PasswordRotationUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput | PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput | PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutRotationPolicyInput | PasswordUpdateManyWithWhereWithoutRotationPolicyInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput | PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput | PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPolicyInput | PasswordRotationUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutRotationsInput = {
    create?: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationsInput
    connect?: PasswordWhereUniqueInput
  }

  export type PasswordRotationPolicyCreateNestedOneWithoutRotationsInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutRotationsInput
    connect?: PasswordRotationPolicyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordRotationsInput = {
    create?: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordRotationsInput
    connect?: UserWhereUniqueInput
  }

  export type PasswordUpdateOneRequiredWithoutRotationsNestedInput = {
    create?: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationsInput
    upsert?: PasswordUpsertWithoutRotationsInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutRotationsInput, PasswordUpdateWithoutRotationsInput>, PasswordUncheckedUpdateWithoutRotationsInput>
  }

  export type PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutRotationsInput
    upsert?: PasswordRotationPolicyUpsertWithoutRotationsInput
    disconnect?: PasswordRotationPolicyWhereInput | boolean
    delete?: PasswordRotationPolicyWhereInput | boolean
    connect?: PasswordRotationPolicyWhereUniqueInput
    update?: XOR<XOR<PasswordRotationPolicyUpdateToOneWithWhereWithoutRotationsInput, PasswordRotationPolicyUpdateWithoutRotationsInput>, PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput>
  }

  export type UserUpdateOneRequiredWithoutPasswordRotationsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordRotationsInput
    upsert?: UserUpsertWithoutPasswordRotationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordRotationsInput, UserUpdateWithoutPasswordRotationsInput>, UserUncheckedUpdateWithoutPasswordRotationsInput>
  }

  export type FolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    connect?: FolderWhereUniqueInput
  }

  export type FolderCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type PasswordCreateNestedManyWithoutFolderInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type PasswordUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type FolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    upsert?: FolderUpsertWithoutChildrenInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutChildrenInput, FolderUpdateWithoutChildrenInput>, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type PasswordUpdateManyWithoutFolderNestedInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutFolderInput | PasswordUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutFolderInput | PasswordUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutFolderInput | PasswordUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type PasswordUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutFolderInput | PasswordUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutFolderInput | PasswordUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutFolderInput | PasswordUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutSharedWithInput = {
    create?: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutSharedWithInput
    connect?: PasswordWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedPasswordsInput = {
    create?: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedPasswordsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSharedPasswordsInput = {
    create?: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSharedPasswordsInput
    connect?: TeamWhereUniqueInput
  }

  export type EnumSharePermissionFieldUpdateOperationsInput = {
    set?: $Enums.SharePermission
  }

  export type PasswordUpdateOneRequiredWithoutSharedWithNestedInput = {
    create?: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutSharedWithInput
    upsert?: PasswordUpsertWithoutSharedWithInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutSharedWithInput, PasswordUpdateWithoutSharedWithInput>, PasswordUncheckedUpdateWithoutSharedWithInput>
  }

  export type UserUpdateOneWithoutSharedPasswordsNestedInput = {
    create?: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedPasswordsInput
    upsert?: UserUpsertWithoutSharedPasswordsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedPasswordsInput, UserUpdateWithoutSharedPasswordsInput>, UserUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type TeamUpdateOneWithoutSharedPasswordsNestedInput = {
    create?: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSharedPasswordsInput
    upsert?: TeamUpsertWithoutSharedPasswordsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSharedPasswordsInput, TeamUpdateWithoutSharedPasswordsInput>, TeamUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type PasswordCreateNestedOneWithoutTemporarySharesInput = {
    create?: XOR<PasswordCreateWithoutTemporarySharesInput, PasswordUncheckedCreateWithoutTemporarySharesInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutTemporarySharesInput
    connect?: PasswordWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTemporaryPasswordSharesInput = {
    create?: XOR<UserCreateWithoutTemporaryPasswordSharesInput, UserUncheckedCreateWithoutTemporaryPasswordSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemporaryPasswordSharesInput
    connect?: UserWhereUniqueInput
  }

  export type PasswordUpdateOneRequiredWithoutTemporarySharesNestedInput = {
    create?: XOR<PasswordCreateWithoutTemporarySharesInput, PasswordUncheckedCreateWithoutTemporarySharesInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutTemporarySharesInput
    upsert?: PasswordUpsertWithoutTemporarySharesInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutTemporarySharesInput, PasswordUpdateWithoutTemporarySharesInput>, PasswordUncheckedUpdateWithoutTemporarySharesInput>
  }

  export type UserUpdateOneRequiredWithoutTemporaryPasswordSharesNestedInput = {
    create?: XOR<UserCreateWithoutTemporaryPasswordSharesInput, UserUncheckedCreateWithoutTemporaryPasswordSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemporaryPasswordSharesInput
    upsert?: UserUpsertWithoutTemporaryPasswordSharesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTemporaryPasswordSharesInput, UserUpdateWithoutTemporaryPasswordSharesInput>, UserUncheckedUpdateWithoutTemporaryPasswordSharesInput>
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type PasswordShareCreateNestedManyWithoutTeamInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type PasswordShareUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type PasswordShareUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutTeamInput | PasswordShareUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutTeamInput | PasswordShareUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutTeamInput | PasswordShareUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type PasswordShareUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutTeamInput | PasswordShareUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutTeamInput | PasswordShareUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutTeamInput | PasswordShareUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type PasswordTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutTagInput | PasswordTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutTagInput | PasswordTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutTagInput | PasswordTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutTagInput | PasswordTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutTagInput | PasswordTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutTagInput | PasswordTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutTagsInput = {
    create?: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutTagsInput
    connect?: PasswordWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPasswordsInput = {
    create?: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPasswordsInput
    connect?: TagWhereUniqueInput
  }

  export type PasswordUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutTagsInput
    upsert?: PasswordUpsertWithoutTagsInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutTagsInput, PasswordUpdateWithoutTagsInput>, PasswordUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPasswordsNestedInput = {
    create?: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPasswordsInput
    upsert?: TagUpsertWithoutPasswordsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPasswordsInput, TagUpdateWithoutPasswordsInput>, TagUncheckedUpdateWithoutPasswordsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditStatus
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyCreateNestedOneWithoutAuditLogArchivesInput = {
    create?: XOR<CompanyCreateWithoutAuditLogArchivesInput, CompanyUncheckedCreateWithoutAuditLogArchivesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogArchivesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogArchivesInput = {
    create?: XOR<UserCreateWithoutAuditLogArchivesInput, UserUncheckedCreateWithoutAuditLogArchivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogArchivesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutAuditLogArchivesNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogArchivesInput, CompanyUncheckedCreateWithoutAuditLogArchivesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogArchivesInput
    upsert?: CompanyUpsertWithoutAuditLogArchivesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogArchivesInput, CompanyUpdateWithoutAuditLogArchivesInput>, CompanyUncheckedUpdateWithoutAuditLogArchivesInput>
  }

  export type UserUpdateOneWithoutAuditLogArchivesNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogArchivesInput, UserUncheckedCreateWithoutAuditLogArchivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogArchivesInput
    upsert?: UserUpsertWithoutAuditLogArchivesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogArchivesInput, UserUpdateWithoutAuditLogArchivesInput>, UserUncheckedUpdateWithoutAuditLogArchivesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogSearchesInput = {
    create?: XOR<UserCreateWithoutAuditLogSearchesInput, UserUncheckedCreateWithoutAuditLogSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogSearchesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAuditLogSearchesInput = {
    create?: XOR<CompanyCreateWithoutAuditLogSearchesInput, CompanyUncheckedCreateWithoutAuditLogSearchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogSearchesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogSearchesNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogSearchesInput, UserUncheckedCreateWithoutAuditLogSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogSearchesInput
    upsert?: UserUpsertWithoutAuditLogSearchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogSearchesInput, UserUpdateWithoutAuditLogSearchesInput>, UserUncheckedUpdateWithoutAuditLogSearchesInput>
  }

  export type CompanyUpdateOneWithoutAuditLogSearchesNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogSearchesInput, CompanyUncheckedCreateWithoutAuditLogSearchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogSearchesInput
    upsert?: CompanyUpsertWithoutAuditLogSearchesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogSearchesInput, CompanyUpdateWithoutAuditLogSearchesInput>, CompanyUncheckedUpdateWithoutAuditLogSearchesInput>
  }

  export type UserCreateNestedOneWithoutThreatEventsInput = {
    create?: XOR<UserCreateWithoutThreatEventsInput, UserUncheckedCreateWithoutThreatEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreatEventsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutThreatEventsInput = {
    create?: XOR<CompanyCreateWithoutThreatEventsInput, CompanyUncheckedCreateWithoutThreatEventsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutThreatEventsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumThreatTypeFieldUpdateOperationsInput = {
    set?: $Enums.ThreatType
  }

  export type EnumThreatSeverityFieldUpdateOperationsInput = {
    set?: $Enums.ThreatSeverity
  }

  export type UserUpdateOneWithoutThreatEventsNestedInput = {
    create?: XOR<UserCreateWithoutThreatEventsInput, UserUncheckedCreateWithoutThreatEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreatEventsInput
    upsert?: UserUpsertWithoutThreatEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutThreatEventsInput, UserUpdateWithoutThreatEventsInput>, UserUncheckedUpdateWithoutThreatEventsInput>
  }

  export type CompanyUpdateOneWithoutThreatEventsNestedInput = {
    create?: XOR<CompanyCreateWithoutThreatEventsInput, CompanyUncheckedCreateWithoutThreatEventsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutThreatEventsInput
    upsert?: CompanyUpsertWithoutThreatEventsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutThreatEventsInput, CompanyUpdateWithoutThreatEventsInput>, CompanyUncheckedUpdateWithoutThreatEventsInput>
  }

  export type CompanyCreateNestedOneWithoutRateLimitsInput = {
    create?: XOR<CompanyCreateWithoutRateLimitsInput, CompanyUncheckedCreateWithoutRateLimitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRateLimitsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumRateLimitTypeFieldUpdateOperationsInput = {
    set?: $Enums.RateLimitType
  }

  export type CompanyUpdateOneWithoutRateLimitsNestedInput = {
    create?: XOR<CompanyCreateWithoutRateLimitsInput, CompanyUncheckedCreateWithoutRateLimitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRateLimitsInput
    upsert?: CompanyUpsertWithoutRateLimitsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutRateLimitsInput, CompanyUpdateWithoutRateLimitsInput>, CompanyUncheckedUpdateWithoutRateLimitsInput>
  }

  export type UserCreateNestedOneWithoutCreatedRolesInput = {
    create?: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedRolesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRolesInput
    upsert?: UserUpsertWithoutCreatedRolesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRolesInput, UserUpdateWithoutCreatedRolesInput>, UserUncheckedUpdateWithoutCreatedRolesInput>
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type UserCreateNestedOneWithoutMfaCredentialsInput = {
    create?: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutMfaCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaCredentialsInput
    upsert?: UserUpsertWithoutMfaCredentialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMfaCredentialsInput, UserUpdateWithoutMfaCredentialsInput>, UserUncheckedUpdateWithoutMfaCredentialsInput>
  }

  export type UserCreateNestedOneWithoutRecoveryCodesInput = {
    create?: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecoveryCodesNestedInput = {
    create?: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryCodesInput
    upsert?: UserUpsertWithoutRecoveryCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecoveryCodesInput, UserUpdateWithoutRecoveryCodesInput>, UserUncheckedUpdateWithoutRecoveryCodesInput>
  }

  export type SavedSearchCreatefolderIdsInput = {
    set: string[]
  }

  export type SavedSearchCreatetagIdsInput = {
    set: string[]
  }

  export type SavedSearchCreatesearchFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSavedSearchesInput = {
    create?: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedSearchesInput
    connect?: UserWhereUniqueInput
  }

  export type SavedSearchUpdatefolderIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SavedSearchUpdatetagIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SavedSearchUpdatesearchFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSavedSearchesNestedInput = {
    create?: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedSearchesInput
    upsert?: UserUpsertWithoutSavedSearchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedSearchesInput, UserUpdateWithoutSavedSearchesInput>, UserUncheckedUpdateWithoutSavedSearchesInput>
  }

  export type SearchHistoryCreatefolderIdsInput = {
    set: string[]
  }

  export type SearchHistoryCreatetagIdsInput = {
    set: string[]
  }

  export type SearchHistoryCreatesearchFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSearchHistoryInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type SearchHistoryUpdatefolderIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SearchHistoryUpdatetagIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SearchHistoryUpdatesearchFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSearchHistoryNestedInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    upsert?: UserUpsertWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchHistoryInput, UserUpdateWithoutSearchHistoryInput>, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserCreateNestedOneWithoutPasswordTemplatesInput = {
    create?: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTemplatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneWithoutPasswordTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordTemplatesInput
    upsert?: UserUpsertWithoutPasswordTemplatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordTemplatesInput, UserUpdateWithoutPasswordTemplatesInput>, UserUncheckedUpdateWithoutPasswordTemplatesInput>
  }

  export type CompanyUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTemplatesInput
    upsert?: CompanyUpsertWithoutTemplatesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTemplatesInput, CompanyUpdateWithoutTemplatesInput>, CompanyUncheckedUpdateWithoutTemplatesInput>
  }

  export type UserCreateNestedOneWithoutEmailVerificationTokensInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput
    upsert?: UserUpsertWithoutEmailVerificationTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput, UserUpdateWithoutEmailVerificationTokensInput>, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserCreateNestedOneWithoutSecurityQuestionsInput = {
    create?: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSecurityQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityQuestionsInput
    upsert?: UserUpsertWithoutSecurityQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityQuestionsInput, UserUpdateWithoutSecurityQuestionsInput>, UserUncheckedUpdateWithoutSecurityQuestionsInput>
  }

  export type UserCreateNestedOneWithoutIpWhitelistsInput = {
    create?: XOR<UserCreateWithoutIpWhitelistsInput, UserUncheckedCreateWithoutIpWhitelistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIpWhitelistsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutIpWhitelistsInput = {
    create?: XOR<CompanyCreateWithoutIpWhitelistsInput, CompanyUncheckedCreateWithoutIpWhitelistsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutIpWhitelistsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedIpWhitelistsInput = {
    create?: XOR<UserCreateWithoutCreatedIpWhitelistsInput, UserUncheckedCreateWithoutCreatedIpWhitelistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIpWhitelistsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutIpWhitelistsNestedInput = {
    create?: XOR<UserCreateWithoutIpWhitelistsInput, UserUncheckedCreateWithoutIpWhitelistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIpWhitelistsInput
    upsert?: UserUpsertWithoutIpWhitelistsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIpWhitelistsInput, UserUpdateWithoutIpWhitelistsInput>, UserUncheckedUpdateWithoutIpWhitelistsInput>
  }

  export type CompanyUpdateOneWithoutIpWhitelistsNestedInput = {
    create?: XOR<CompanyCreateWithoutIpWhitelistsInput, CompanyUncheckedCreateWithoutIpWhitelistsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutIpWhitelistsInput
    upsert?: CompanyUpsertWithoutIpWhitelistsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutIpWhitelistsInput, CompanyUpdateWithoutIpWhitelistsInput>, CompanyUncheckedUpdateWithoutIpWhitelistsInput>
  }

  export type UserUpdateOneWithoutCreatedIpWhitelistsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedIpWhitelistsInput, UserUncheckedCreateWithoutCreatedIpWhitelistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIpWhitelistsInput
    upsert?: UserUpsertWithoutCreatedIpWhitelistsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedIpWhitelistsInput, UserUpdateWithoutCreatedIpWhitelistsInput>, UserUncheckedUpdateWithoutCreatedIpWhitelistsInput>
  }

  export type UserCreateNestedOneWithoutGeographicRestrictionsInput = {
    create?: XOR<UserCreateWithoutGeographicRestrictionsInput, UserUncheckedCreateWithoutGeographicRestrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeographicRestrictionsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutGeographicRestrictionsInput = {
    create?: XOR<CompanyCreateWithoutGeographicRestrictionsInput, CompanyUncheckedCreateWithoutGeographicRestrictionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGeographicRestrictionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedGeographicRestrictionsInput = {
    create?: XOR<UserCreateWithoutCreatedGeographicRestrictionsInput, UserUncheckedCreateWithoutCreatedGeographicRestrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGeographicRestrictionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutGeographicRestrictionsNestedInput = {
    create?: XOR<UserCreateWithoutGeographicRestrictionsInput, UserUncheckedCreateWithoutGeographicRestrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeographicRestrictionsInput
    upsert?: UserUpsertWithoutGeographicRestrictionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeographicRestrictionsInput, UserUpdateWithoutGeographicRestrictionsInput>, UserUncheckedUpdateWithoutGeographicRestrictionsInput>
  }

  export type CompanyUpdateOneWithoutGeographicRestrictionsNestedInput = {
    create?: XOR<CompanyCreateWithoutGeographicRestrictionsInput, CompanyUncheckedCreateWithoutGeographicRestrictionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGeographicRestrictionsInput
    upsert?: CompanyUpsertWithoutGeographicRestrictionsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutGeographicRestrictionsInput, CompanyUpdateWithoutGeographicRestrictionsInput>, CompanyUncheckedUpdateWithoutGeographicRestrictionsInput>
  }

  export type UserUpdateOneWithoutCreatedGeographicRestrictionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGeographicRestrictionsInput, UserUncheckedCreateWithoutCreatedGeographicRestrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGeographicRestrictionsInput
    upsert?: UserUpsertWithoutCreatedGeographicRestrictionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGeographicRestrictionsInput, UserUpdateWithoutCreatedGeographicRestrictionsInput>, UserUncheckedUpdateWithoutCreatedGeographicRestrictionsInput>
  }

  export type CompanyCreateNestedOneWithoutPasswordPolicyInput = {
    create?: XOR<CompanyCreateWithoutPasswordPolicyInput, CompanyUncheckedCreateWithoutPasswordPolicyInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPasswordPolicyInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutPasswordPolicyNestedInput = {
    create?: XOR<CompanyCreateWithoutPasswordPolicyInput, CompanyUncheckedCreateWithoutPasswordPolicyInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPasswordPolicyInput
    upsert?: CompanyUpsertWithoutPasswordPolicyInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPasswordPolicyInput, CompanyUpdateWithoutPasswordPolicyInput>, CompanyUncheckedUpdateWithoutPasswordPolicyInput>
  }

  export type CompanyCreateNestedOneWithoutDataRetentionPolicyInput = {
    create?: XOR<CompanyCreateWithoutDataRetentionPolicyInput, CompanyUncheckedCreateWithoutDataRetentionPolicyInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDataRetentionPolicyInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDataRetentionPolicyNestedInput = {
    create?: XOR<CompanyCreateWithoutDataRetentionPolicyInput, CompanyUncheckedCreateWithoutDataRetentionPolicyInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDataRetentionPolicyInput
    upsert?: CompanyUpsertWithoutDataRetentionPolicyInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDataRetentionPolicyInput, CompanyUpdateWithoutDataRetentionPolicyInput>, CompanyUncheckedUpdateWithoutDataRetentionPolicyInput>
  }

  export type UserCreateNestedOneWithoutDataExportsInput = {
    create?: XOR<UserCreateWithoutDataExportsInput, UserUncheckedCreateWithoutDataExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataExportsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDataExportsInput = {
    create?: XOR<CompanyCreateWithoutDataExportsInput, CompanyUncheckedCreateWithoutDataExportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDataExportsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDataExportsNestedInput = {
    create?: XOR<UserCreateWithoutDataExportsInput, UserUncheckedCreateWithoutDataExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataExportsInput
    upsert?: UserUpsertWithoutDataExportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataExportsInput, UserUpdateWithoutDataExportsInput>, UserUncheckedUpdateWithoutDataExportsInput>
  }

  export type CompanyUpdateOneWithoutDataExportsNestedInput = {
    create?: XOR<CompanyCreateWithoutDataExportsInput, CompanyUncheckedCreateWithoutDataExportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDataExportsInput
    upsert?: CompanyUpsertWithoutDataExportsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDataExportsInput, CompanyUpdateWithoutDataExportsInput>, CompanyUncheckedUpdateWithoutDataExportsInput>
  }

  export type UserCreateNestedOneWithoutDataDeletionRequestsInput = {
    create?: XOR<UserCreateWithoutDataDeletionRequestsInput, UserUncheckedCreateWithoutDataDeletionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataDeletionRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDataDeletionRequestsInput = {
    create?: XOR<CompanyCreateWithoutDataDeletionRequestsInput, CompanyUncheckedCreateWithoutDataDeletionRequestsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDataDeletionRequestsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProcessedDeletionsInput = {
    create?: XOR<UserCreateWithoutProcessedDeletionsInput, UserUncheckedCreateWithoutProcessedDeletionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedDeletionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDataDeletionRequestsNestedInput = {
    create?: XOR<UserCreateWithoutDataDeletionRequestsInput, UserUncheckedCreateWithoutDataDeletionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataDeletionRequestsInput
    upsert?: UserUpsertWithoutDataDeletionRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataDeletionRequestsInput, UserUpdateWithoutDataDeletionRequestsInput>, UserUncheckedUpdateWithoutDataDeletionRequestsInput>
  }

  export type CompanyUpdateOneWithoutDataDeletionRequestsNestedInput = {
    create?: XOR<CompanyCreateWithoutDataDeletionRequestsInput, CompanyUncheckedCreateWithoutDataDeletionRequestsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDataDeletionRequestsInput
    upsert?: CompanyUpsertWithoutDataDeletionRequestsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDataDeletionRequestsInput, CompanyUpdateWithoutDataDeletionRequestsInput>, CompanyUncheckedUpdateWithoutDataDeletionRequestsInput>
  }

  export type UserUpdateOneWithoutProcessedDeletionsNestedInput = {
    create?: XOR<UserCreateWithoutProcessedDeletionsInput, UserUncheckedCreateWithoutProcessedDeletionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedDeletionsInput
    upsert?: UserUpsertWithoutProcessedDeletionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessedDeletionsInput, UserUpdateWithoutProcessedDeletionsInput>, UserUncheckedUpdateWithoutProcessedDeletionsInput>
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutReportsInput = {
    create?: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ReportTemplateCreateNestedOneWithoutReportsInput = {
    create?: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutReportsInput
    connect?: ReportTemplateWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type CompanyUpdateOneWithoutReportsNestedInput = {
    create?: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportsInput
    upsert?: CompanyUpsertWithoutReportsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutReportsInput, CompanyUpdateWithoutReportsInput>, CompanyUncheckedUpdateWithoutReportsInput>
  }

  export type ReportTemplateUpdateOneWithoutReportsNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutReportsInput
    upsert?: ReportTemplateUpsertWithoutReportsInput
    disconnect?: ReportTemplateWhereInput | boolean
    delete?: ReportTemplateWhereInput | boolean
    connect?: ReportTemplateWhereUniqueInput
    update?: XOR<XOR<ReportTemplateUpdateToOneWithWhereWithoutReportsInput, ReportTemplateUpdateWithoutReportsInput>, ReportTemplateUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutReportTemplatesInput = {
    create?: XOR<UserCreateWithoutReportTemplatesInput, UserUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutReportTemplatesInput = {
    create?: XOR<CompanyCreateWithoutReportTemplatesInput, CompanyUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportTemplatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ScheduledReportCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ScheduledReportCreateWithoutTemplateInput, ScheduledReportUncheckedCreateWithoutTemplateInput> | ScheduledReportCreateWithoutTemplateInput[] | ScheduledReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTemplateInput | ScheduledReportCreateOrConnectWithoutTemplateInput[]
    createMany?: ScheduledReportCreateManyTemplateInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ScheduledReportCreateWithoutTemplateInput, ScheduledReportUncheckedCreateWithoutTemplateInput> | ScheduledReportCreateWithoutTemplateInput[] | ScheduledReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTemplateInput | ScheduledReportCreateOrConnectWithoutTemplateInput[]
    createMany?: ScheduledReportCreateManyTemplateInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReportTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutReportTemplatesInput, UserUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportTemplatesInput
    upsert?: UserUpsertWithoutReportTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportTemplatesInput, UserUpdateWithoutReportTemplatesInput>, UserUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type CompanyUpdateOneWithoutReportTemplatesNestedInput = {
    create?: XOR<CompanyCreateWithoutReportTemplatesInput, CompanyUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportTemplatesInput
    upsert?: CompanyUpsertWithoutReportTemplatesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutReportTemplatesInput, CompanyUpdateWithoutReportTemplatesInput>, CompanyUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type ReportUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTemplateInput | ReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTemplateInput | ReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTemplateInput | ReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ScheduledReportUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutTemplateInput, ScheduledReportUncheckedCreateWithoutTemplateInput> | ScheduledReportCreateWithoutTemplateInput[] | ScheduledReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTemplateInput | ScheduledReportCreateOrConnectWithoutTemplateInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutTemplateInput | ScheduledReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ScheduledReportCreateManyTemplateInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutTemplateInput | ScheduledReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutTemplateInput | ScheduledReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTemplateInput | ReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTemplateInput | ReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTemplateInput | ReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutTemplateInput, ScheduledReportUncheckedCreateWithoutTemplateInput> | ScheduledReportCreateWithoutTemplateInput[] | ScheduledReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTemplateInput | ScheduledReportCreateOrConnectWithoutTemplateInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutTemplateInput | ScheduledReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ScheduledReportCreateManyTemplateInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutTemplateInput | ScheduledReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutTemplateInput | ScheduledReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutScheduledReportsInput = {
    create?: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledReportsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutScheduledReportsInput = {
    create?: XOR<CompanyCreateWithoutScheduledReportsInput, CompanyUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutScheduledReportsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ReportTemplateCreateNestedOneWithoutScheduledReportsInput = {
    create?: XOR<ReportTemplateCreateWithoutScheduledReportsInput, ReportTemplateUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutScheduledReportsInput
    connect?: ReportTemplateWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutScheduledReportsNestedInput = {
    create?: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledReportsInput
    upsert?: UserUpsertWithoutScheduledReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduledReportsInput, UserUpdateWithoutScheduledReportsInput>, UserUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type CompanyUpdateOneWithoutScheduledReportsNestedInput = {
    create?: XOR<CompanyCreateWithoutScheduledReportsInput, CompanyUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutScheduledReportsInput
    upsert?: CompanyUpsertWithoutScheduledReportsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutScheduledReportsInput, CompanyUpdateWithoutScheduledReportsInput>, CompanyUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type ReportTemplateUpdateOneWithoutScheduledReportsNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutScheduledReportsInput, ReportTemplateUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutScheduledReportsInput
    upsert?: ReportTemplateUpsertWithoutScheduledReportsInput
    disconnect?: ReportTemplateWhereInput | boolean
    delete?: ReportTemplateWhereInput | boolean
    connect?: ReportTemplateWhereUniqueInput
    update?: XOR<XOR<ReportTemplateUpdateToOneWithWhereWithoutScheduledReportsInput, ReportTemplateUpdateWithoutScheduledReportsInput>, ReportTemplateUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumMfaMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableFilter<$PrismaModel> | $Enums.MfaMethod | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumMfaMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.MfaMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPasswordStrengthFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthFilter<$PrismaModel> | $Enums.PasswordStrength
  }

  export type NestedEnumPasswordStrengthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthWithAggregatesFilter<$PrismaModel> | $Enums.PasswordStrength
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPasswordStrengthFilter<$PrismaModel>
    _max?: NestedEnumPasswordStrengthFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSharePermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionFilter<$PrismaModel> | $Enums.SharePermission
  }

  export type NestedEnumSharePermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionWithAggregatesFilter<$PrismaModel> | $Enums.SharePermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSharePermissionFilter<$PrismaModel>
    _max?: NestedEnumSharePermissionFilter<$PrismaModel>
  }

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type NestedEnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumThreatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatType | EnumThreatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatTypeFilter<$PrismaModel> | $Enums.ThreatType
  }

  export type NestedEnumThreatSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatSeverity | EnumThreatSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatSeverityFilter<$PrismaModel> | $Enums.ThreatSeverity
  }

  export type NestedEnumThreatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatType | EnumThreatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatType[] | ListEnumThreatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatTypeWithAggregatesFilter<$PrismaModel> | $Enums.ThreatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThreatTypeFilter<$PrismaModel>
    _max?: NestedEnumThreatTypeFilter<$PrismaModel>
  }

  export type NestedEnumThreatSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatSeverity | EnumThreatSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThreatSeverity[] | ListEnumThreatSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumThreatSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ThreatSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThreatSeverityFilter<$PrismaModel>
    _max?: NestedEnumThreatSeverityFilter<$PrismaModel>
  }

  export type NestedEnumRateLimitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRateLimitTypeFilter<$PrismaModel> | $Enums.RateLimitType
  }

  export type NestedEnumRateLimitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRateLimitTypeWithAggregatesFilter<$PrismaModel> | $Enums.RateLimitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRateLimitTypeFilter<$PrismaModel>
    _max?: NestedEnumRateLimitTypeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTemplateCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutPasswordTemplatesInput
  }

  export type PasswordTemplateUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateCreateOrConnectWithoutCompanyInput = {
    where: PasswordTemplateWhereUniqueInput
    create: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type PasswordTemplateCreateManyCompanyInputEnvelope = {
    data: PasswordTemplateCreateManyCompanyInput | PasswordTemplateCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type IpWhitelistCreateWithoutCompanyInput = {
    id?: string
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutIpWhitelistsInput
    creator?: UserCreateNestedOneWithoutCreatedIpWhitelistsInput
  }

  export type IpWhitelistUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type IpWhitelistCreateOrConnectWithoutCompanyInput = {
    where: IpWhitelistWhereUniqueInput
    create: XOR<IpWhitelistCreateWithoutCompanyInput, IpWhitelistUncheckedCreateWithoutCompanyInput>
  }

  export type IpWhitelistCreateManyCompanyInputEnvelope = {
    data: IpWhitelistCreateManyCompanyInput | IpWhitelistCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type GeographicRestrictionCreateWithoutCompanyInput = {
    id?: string
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutGeographicRestrictionsInput
    creator?: UserCreateNestedOneWithoutCreatedGeographicRestrictionsInput
  }

  export type GeographicRestrictionUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type GeographicRestrictionCreateOrConnectWithoutCompanyInput = {
    where: GeographicRestrictionWhereUniqueInput
    create: XOR<GeographicRestrictionCreateWithoutCompanyInput, GeographicRestrictionUncheckedCreateWithoutCompanyInput>
  }

  export type GeographicRestrictionCreateManyCompanyInputEnvelope = {
    data: GeographicRestrictionCreateManyCompanyInput | GeographicRestrictionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ThreatEventCreateWithoutCompanyInput = {
    id?: string
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutThreatEventsInput
  }

  export type ThreatEventUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId?: string | null
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type ThreatEventCreateOrConnectWithoutCompanyInput = {
    where: ThreatEventWhereUniqueInput
    create: XOR<ThreatEventCreateWithoutCompanyInput, ThreatEventUncheckedCreateWithoutCompanyInput>
  }

  export type ThreatEventCreateManyCompanyInputEnvelope = {
    data: ThreatEventCreateManyCompanyInput | ThreatEventCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type RateLimitCreateWithoutCompanyInput = {
    id?: string
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    count?: number
    windowStart?: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RateLimitUncheckedCreateWithoutCompanyInput = {
    id?: string
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    count?: number
    windowStart?: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RateLimitCreateOrConnectWithoutCompanyInput = {
    where: RateLimitWhereUniqueInput
    create: XOR<RateLimitCreateWithoutCompanyInput, RateLimitUncheckedCreateWithoutCompanyInput>
  }

  export type RateLimitCreateManyCompanyInputEnvelope = {
    data: RateLimitCreateManyCompanyInput | RateLimitCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PasswordPolicyCreateWithoutCompanyInput = {
    id?: string
    minLength?: number
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: number | null
    preventReuseCount?: number
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordPolicyUncheckedCreateWithoutCompanyInput = {
    id?: string
    minLength?: number
    requireUppercase?: boolean
    requireLowercase?: boolean
    requireNumbers?: boolean
    requireSpecial?: boolean
    expirationDays?: number | null
    preventReuseCount?: number
    requireChangeOnFirstLogin?: boolean
    requireChangeAfterDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordPolicyCreateOrConnectWithoutCompanyInput = {
    where: PasswordPolicyWhereUniqueInput
    create: XOR<PasswordPolicyCreateWithoutCompanyInput, PasswordPolicyUncheckedCreateWithoutCompanyInput>
  }

  export type DataRetentionPolicyCreateWithoutCompanyInput = {
    id?: string
    auditLogRetentionDays?: number | null
    passwordHistoryRetentionDays?: number | null
    sessionRetentionDays?: number | null
    deletedDataRetentionDays?: number | null
    autoDeleteEnabled?: boolean
    lastCleanupAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRetentionPolicyUncheckedCreateWithoutCompanyInput = {
    id?: string
    auditLogRetentionDays?: number | null
    passwordHistoryRetentionDays?: number | null
    sessionRetentionDays?: number | null
    deletedDataRetentionDays?: number | null
    autoDeleteEnabled?: boolean
    lastCleanupAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRetentionPolicyCreateOrConnectWithoutCompanyInput = {
    where: DataRetentionPolicyWhereUniqueInput
    create: XOR<DataRetentionPolicyCreateWithoutCompanyInput, DataRetentionPolicyUncheckedCreateWithoutCompanyInput>
  }

  export type DataExportCreateWithoutCompanyInput = {
    id?: string
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    user: UserCreateNestedOneWithoutDataExportsInput
  }

  export type DataExportUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataExportCreateOrConnectWithoutCompanyInput = {
    where: DataExportWhereUniqueInput
    create: XOR<DataExportCreateWithoutCompanyInput, DataExportUncheckedCreateWithoutCompanyInput>
  }

  export type DataExportCreateManyCompanyInputEnvelope = {
    data: DataExportCreateManyCompanyInput | DataExportCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DataDeletionRequestCreateWithoutCompanyInput = {
    id?: string
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
    user: UserCreateNestedOneWithoutDataDeletionRequestsInput
    processor?: UserCreateNestedOneWithoutProcessedDeletionsInput
  }

  export type DataDeletionRequestUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    processedBy?: string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestCreateOrConnectWithoutCompanyInput = {
    where: DataDeletionRequestWhereUniqueInput
    create: XOR<DataDeletionRequestCreateWithoutCompanyInput, DataDeletionRequestUncheckedCreateWithoutCompanyInput>
  }

  export type DataDeletionRequestCreateManyCompanyInputEnvelope = {
    data: DataDeletionRequestCreateManyCompanyInput | DataDeletionRequestCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogArchiveCreateWithoutCompanyInput = {
    id?: string
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    status?: string
    createdAt?: Date | string
    archiver?: UserCreateNestedOneWithoutAuditLogArchivesInput
  }

  export type AuditLogArchiveUncheckedCreateWithoutCompanyInput = {
    id?: string
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    archivedBy?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type AuditLogArchiveCreateOrConnectWithoutCompanyInput = {
    where: AuditLogArchiveWhereUniqueInput
    create: XOR<AuditLogArchiveCreateWithoutCompanyInput, AuditLogArchiveUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogArchiveCreateManyCompanyInputEnvelope = {
    data: AuditLogArchiveCreateManyCompanyInput | AuditLogArchiveCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogSearchCreateWithoutCompanyInput = {
    id?: string
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogSearchesInput
  }

  export type AuditLogSearchUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type AuditLogSearchCreateOrConnectWithoutCompanyInput = {
    where: AuditLogSearchWhereUniqueInput
    create: XOR<AuditLogSearchCreateWithoutCompanyInput, AuditLogSearchUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogSearchCreateManyCompanyInputEnvelope = {
    data: AuditLogSearchCreateManyCompanyInput | AuditLogSearchCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutReportsInput
    template?: ReportTemplateCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
  }

  export type ReportCreateOrConnectWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput>
  }

  export type ReportCreateManyCompanyInputEnvelope = {
    data: ReportCreateManyCompanyInput | ReportCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ReportTemplateCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutReportTemplatesInput
    reports?: ReportCreateNestedManyWithoutTemplateInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    userId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutTemplateInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutCompanyInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutCompanyInput, ReportTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type ReportTemplateCreateManyCompanyInputEnvelope = {
    data: ReportTemplateCreateManyCompanyInput | ReportTemplateCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutScheduledReportsInput
    template?: ReportTemplateCreateNestedOneWithoutScheduledReportsInput
  }

  export type ScheduledReportUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: string | null
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateOrConnectWithoutCompanyInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutCompanyInput, ScheduledReportUncheckedCreateWithoutCompanyInput>
  }

  export type ScheduledReportCreateManyCompanyInputEnvelope = {
    data: ScheduledReportCreateManyCompanyInput | ScheduledReportCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: StringNullableFilter<"User"> | string | null
  }

  export type PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PasswordTemplateWhereUniqueInput
    update: XOR<PasswordTemplateUpdateWithoutCompanyInput, PasswordTemplateUncheckedUpdateWithoutCompanyInput>
    create: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PasswordTemplateWhereUniqueInput
    data: XOR<PasswordTemplateUpdateWithoutCompanyInput, PasswordTemplateUncheckedUpdateWithoutCompanyInput>
  }

  export type PasswordTemplateUpdateManyWithWhereWithoutCompanyInput = {
    where: PasswordTemplateScalarWhereInput
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PasswordTemplateScalarWhereInput = {
    AND?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
    OR?: PasswordTemplateScalarWhereInput[]
    NOT?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
    id?: StringFilter<"PasswordTemplate"> | string
    name?: StringFilter<"PasswordTemplate"> | string
    description?: StringNullableFilter<"PasswordTemplate"> | string | null
    service?: StringNullableFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableFilter<"PasswordTemplate"> | string | null
    category?: StringNullableFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonFilter<"PasswordTemplate">
    usageCount?: IntFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
  }

  export type IpWhitelistUpsertWithWhereUniqueWithoutCompanyInput = {
    where: IpWhitelistWhereUniqueInput
    update: XOR<IpWhitelistUpdateWithoutCompanyInput, IpWhitelistUncheckedUpdateWithoutCompanyInput>
    create: XOR<IpWhitelistCreateWithoutCompanyInput, IpWhitelistUncheckedCreateWithoutCompanyInput>
  }

  export type IpWhitelistUpdateWithWhereUniqueWithoutCompanyInput = {
    where: IpWhitelistWhereUniqueInput
    data: XOR<IpWhitelistUpdateWithoutCompanyInput, IpWhitelistUncheckedUpdateWithoutCompanyInput>
  }

  export type IpWhitelistUpdateManyWithWhereWithoutCompanyInput = {
    where: IpWhitelistScalarWhereInput
    data: XOR<IpWhitelistUpdateManyMutationInput, IpWhitelistUncheckedUpdateManyWithoutCompanyInput>
  }

  export type IpWhitelistScalarWhereInput = {
    AND?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
    OR?: IpWhitelistScalarWhereInput[]
    NOT?: IpWhitelistScalarWhereInput | IpWhitelistScalarWhereInput[]
    id?: StringFilter<"IpWhitelist"> | string
    userId?: StringNullableFilter<"IpWhitelist"> | string | null
    companyId?: StringNullableFilter<"IpWhitelist"> | string | null
    ipAddress?: StringFilter<"IpWhitelist"> | string
    description?: StringNullableFilter<"IpWhitelist"> | string | null
    isActive?: BoolFilter<"IpWhitelist"> | boolean
    createdAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    updatedAt?: DateTimeFilter<"IpWhitelist"> | Date | string
    createdById?: StringNullableFilter<"IpWhitelist"> | string | null
  }

  export type GeographicRestrictionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: GeographicRestrictionWhereUniqueInput
    update: XOR<GeographicRestrictionUpdateWithoutCompanyInput, GeographicRestrictionUncheckedUpdateWithoutCompanyInput>
    create: XOR<GeographicRestrictionCreateWithoutCompanyInput, GeographicRestrictionUncheckedCreateWithoutCompanyInput>
  }

  export type GeographicRestrictionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: GeographicRestrictionWhereUniqueInput
    data: XOR<GeographicRestrictionUpdateWithoutCompanyInput, GeographicRestrictionUncheckedUpdateWithoutCompanyInput>
  }

  export type GeographicRestrictionUpdateManyWithWhereWithoutCompanyInput = {
    where: GeographicRestrictionScalarWhereInput
    data: XOR<GeographicRestrictionUpdateManyMutationInput, GeographicRestrictionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type GeographicRestrictionScalarWhereInput = {
    AND?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
    OR?: GeographicRestrictionScalarWhereInput[]
    NOT?: GeographicRestrictionScalarWhereInput | GeographicRestrictionScalarWhereInput[]
    id?: StringFilter<"GeographicRestriction"> | string
    userId?: StringNullableFilter<"GeographicRestriction"> | string | null
    companyId?: StringNullableFilter<"GeographicRestriction"> | string | null
    countryCode?: StringFilter<"GeographicRestriction"> | string
    action?: StringFilter<"GeographicRestriction"> | string
    isActive?: BoolFilter<"GeographicRestriction"> | boolean
    createdAt?: DateTimeFilter<"GeographicRestriction"> | Date | string
    updatedAt?: DateTimeFilter<"GeographicRestriction"> | Date | string
    createdById?: StringNullableFilter<"GeographicRestriction"> | string | null
  }

  export type ThreatEventUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ThreatEventWhereUniqueInput
    update: XOR<ThreatEventUpdateWithoutCompanyInput, ThreatEventUncheckedUpdateWithoutCompanyInput>
    create: XOR<ThreatEventCreateWithoutCompanyInput, ThreatEventUncheckedCreateWithoutCompanyInput>
  }

  export type ThreatEventUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ThreatEventWhereUniqueInput
    data: XOR<ThreatEventUpdateWithoutCompanyInput, ThreatEventUncheckedUpdateWithoutCompanyInput>
  }

  export type ThreatEventUpdateManyWithWhereWithoutCompanyInput = {
    where: ThreatEventScalarWhereInput
    data: XOR<ThreatEventUpdateManyMutationInput, ThreatEventUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ThreatEventScalarWhereInput = {
    AND?: ThreatEventScalarWhereInput | ThreatEventScalarWhereInput[]
    OR?: ThreatEventScalarWhereInput[]
    NOT?: ThreatEventScalarWhereInput | ThreatEventScalarWhereInput[]
    id?: StringFilter<"ThreatEvent"> | string
    userId?: StringNullableFilter<"ThreatEvent"> | string | null
    companyId?: StringNullableFilter<"ThreatEvent"> | string | null
    threatType?: EnumThreatTypeFilter<"ThreatEvent"> | $Enums.ThreatType
    severity?: EnumThreatSeverityFilter<"ThreatEvent"> | $Enums.ThreatSeverity
    ipAddress?: StringNullableFilter<"ThreatEvent"> | string | null
    userAgent?: StringNullableFilter<"ThreatEvent"> | string | null
    details?: JsonNullableFilter<"ThreatEvent">
    isResolved?: BoolFilter<"ThreatEvent"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ThreatEvent"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ThreatEvent"> | string | null
    createdAt?: DateTimeFilter<"ThreatEvent"> | Date | string
  }

  export type RateLimitUpsertWithWhereUniqueWithoutCompanyInput = {
    where: RateLimitWhereUniqueInput
    update: XOR<RateLimitUpdateWithoutCompanyInput, RateLimitUncheckedUpdateWithoutCompanyInput>
    create: XOR<RateLimitCreateWithoutCompanyInput, RateLimitUncheckedCreateWithoutCompanyInput>
  }

  export type RateLimitUpdateWithWhereUniqueWithoutCompanyInput = {
    where: RateLimitWhereUniqueInput
    data: XOR<RateLimitUpdateWithoutCompanyInput, RateLimitUncheckedUpdateWithoutCompanyInput>
  }

  export type RateLimitUpdateManyWithWhereWithoutCompanyInput = {
    where: RateLimitScalarWhereInput
    data: XOR<RateLimitUpdateManyMutationInput, RateLimitUncheckedUpdateManyWithoutCompanyInput>
  }

  export type RateLimitScalarWhereInput = {
    AND?: RateLimitScalarWhereInput | RateLimitScalarWhereInput[]
    OR?: RateLimitScalarWhereInput[]
    NOT?: RateLimitScalarWhereInput | RateLimitScalarWhereInput[]
    id?: StringFilter<"RateLimit"> | string
    identifier?: StringFilter<"RateLimit"> | string
    identifierType?: EnumRateLimitTypeFilter<"RateLimit"> | $Enums.RateLimitType
    action?: StringFilter<"RateLimit"> | string
    count?: IntFilter<"RateLimit"> | number
    windowStart?: DateTimeFilter<"RateLimit"> | Date | string
    windowEnd?: DateTimeFilter<"RateLimit"> | Date | string
    companyId?: StringNullableFilter<"RateLimit"> | string | null
    createdAt?: DateTimeFilter<"RateLimit"> | Date | string
    updatedAt?: DateTimeFilter<"RateLimit"> | Date | string
  }

  export type PasswordPolicyUpsertWithoutCompanyInput = {
    update: XOR<PasswordPolicyUpdateWithoutCompanyInput, PasswordPolicyUncheckedUpdateWithoutCompanyInput>
    create: XOR<PasswordPolicyCreateWithoutCompanyInput, PasswordPolicyUncheckedCreateWithoutCompanyInput>
    where?: PasswordPolicyWhereInput
  }

  export type PasswordPolicyUpdateToOneWithWhereWithoutCompanyInput = {
    where?: PasswordPolicyWhereInput
    data: XOR<PasswordPolicyUpdateWithoutCompanyInput, PasswordPolicyUncheckedUpdateWithoutCompanyInput>
  }

  export type PasswordPolicyUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    minLength?: IntFieldUpdateOperationsInput | number
    requireUppercase?: BoolFieldUpdateOperationsInput | boolean
    requireLowercase?: BoolFieldUpdateOperationsInput | boolean
    requireNumbers?: BoolFieldUpdateOperationsInput | boolean
    requireSpecial?: BoolFieldUpdateOperationsInput | boolean
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    preventReuseCount?: IntFieldUpdateOperationsInput | number
    requireChangeOnFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    requireChangeAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordPolicyUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    minLength?: IntFieldUpdateOperationsInput | number
    requireUppercase?: BoolFieldUpdateOperationsInput | boolean
    requireLowercase?: BoolFieldUpdateOperationsInput | boolean
    requireNumbers?: BoolFieldUpdateOperationsInput | boolean
    requireSpecial?: BoolFieldUpdateOperationsInput | boolean
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    preventReuseCount?: IntFieldUpdateOperationsInput | number
    requireChangeOnFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    requireChangeAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRetentionPolicyUpsertWithoutCompanyInput = {
    update: XOR<DataRetentionPolicyUpdateWithoutCompanyInput, DataRetentionPolicyUncheckedUpdateWithoutCompanyInput>
    create: XOR<DataRetentionPolicyCreateWithoutCompanyInput, DataRetentionPolicyUncheckedCreateWithoutCompanyInput>
    where?: DataRetentionPolicyWhereInput
  }

  export type DataRetentionPolicyUpdateToOneWithWhereWithoutCompanyInput = {
    where?: DataRetentionPolicyWhereInput
    data: XOR<DataRetentionPolicyUpdateWithoutCompanyInput, DataRetentionPolicyUncheckedUpdateWithoutCompanyInput>
  }

  export type DataRetentionPolicyUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditLogRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    passwordHistoryRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    sessionRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    deletedDataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastCleanupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRetentionPolicyUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditLogRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    passwordHistoryRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    sessionRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    deletedDataRetentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    autoDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastCleanupAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DataExportWhereUniqueInput
    update: XOR<DataExportUpdateWithoutCompanyInput, DataExportUncheckedUpdateWithoutCompanyInput>
    create: XOR<DataExportCreateWithoutCompanyInput, DataExportUncheckedCreateWithoutCompanyInput>
  }

  export type DataExportUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DataExportWhereUniqueInput
    data: XOR<DataExportUpdateWithoutCompanyInput, DataExportUncheckedUpdateWithoutCompanyInput>
  }

  export type DataExportUpdateManyWithWhereWithoutCompanyInput = {
    where: DataExportScalarWhereInput
    data: XOR<DataExportUpdateManyMutationInput, DataExportUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DataExportScalarWhereInput = {
    AND?: DataExportScalarWhereInput | DataExportScalarWhereInput[]
    OR?: DataExportScalarWhereInput[]
    NOT?: DataExportScalarWhereInput | DataExportScalarWhereInput[]
    id?: StringFilter<"DataExport"> | string
    userId?: StringFilter<"DataExport"> | string
    companyId?: StringNullableFilter<"DataExport"> | string | null
    exportType?: StringFilter<"DataExport"> | string
    status?: StringFilter<"DataExport"> | string
    filePath?: StringNullableFilter<"DataExport"> | string | null
    fileSize?: IntNullableFilter<"DataExport"> | number | null
    expiresAt?: DateTimeNullableFilter<"DataExport"> | Date | string | null
    requestedAt?: DateTimeFilter<"DataExport"> | Date | string
    completedAt?: DateTimeNullableFilter<"DataExport"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataExport"> | string | null
  }

  export type DataDeletionRequestUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DataDeletionRequestWhereUniqueInput
    update: XOR<DataDeletionRequestUpdateWithoutCompanyInput, DataDeletionRequestUncheckedUpdateWithoutCompanyInput>
    create: XOR<DataDeletionRequestCreateWithoutCompanyInput, DataDeletionRequestUncheckedCreateWithoutCompanyInput>
  }

  export type DataDeletionRequestUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DataDeletionRequestWhereUniqueInput
    data: XOR<DataDeletionRequestUpdateWithoutCompanyInput, DataDeletionRequestUncheckedUpdateWithoutCompanyInput>
  }

  export type DataDeletionRequestUpdateManyWithWhereWithoutCompanyInput = {
    where: DataDeletionRequestScalarWhereInput
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DataDeletionRequestScalarWhereInput = {
    AND?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
    OR?: DataDeletionRequestScalarWhereInput[]
    NOT?: DataDeletionRequestScalarWhereInput | DataDeletionRequestScalarWhereInput[]
    id?: StringFilter<"DataDeletionRequest"> | string
    userId?: StringFilter<"DataDeletionRequest"> | string
    companyId?: StringNullableFilter<"DataDeletionRequest"> | string | null
    requestType?: StringFilter<"DataDeletionRequest"> | string
    status?: StringFilter<"DataDeletionRequest"> | string
    requestedAt?: DateTimeFilter<"DataDeletionRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    processedBy?: StringNullableFilter<"DataDeletionRequest"> | string | null
    deletionScope?: JsonNullableFilter<"DataDeletionRequest">
    confirmationToken?: StringFilter<"DataDeletionRequest"> | string
    confirmedAt?: DateTimeNullableFilter<"DataDeletionRequest"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataDeletionRequest"> | string | null
  }

  export type AuditLogArchiveUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogArchiveWhereUniqueInput
    update: XOR<AuditLogArchiveUpdateWithoutCompanyInput, AuditLogArchiveUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogArchiveCreateWithoutCompanyInput, AuditLogArchiveUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogArchiveUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogArchiveWhereUniqueInput
    data: XOR<AuditLogArchiveUpdateWithoutCompanyInput, AuditLogArchiveUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogArchiveUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogArchiveScalarWhereInput
    data: XOR<AuditLogArchiveUpdateManyMutationInput, AuditLogArchiveUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogArchiveScalarWhereInput = {
    AND?: AuditLogArchiveScalarWhereInput | AuditLogArchiveScalarWhereInput[]
    OR?: AuditLogArchiveScalarWhereInput[]
    NOT?: AuditLogArchiveScalarWhereInput | AuditLogArchiveScalarWhereInput[]
    id?: StringFilter<"AuditLogArchive"> | string
    companyId?: StringNullableFilter<"AuditLogArchive"> | string | null
    archiveDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    startDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    endDate?: DateTimeFilter<"AuditLogArchive"> | Date | string
    logCount?: IntFilter<"AuditLogArchive"> | number
    filePath?: StringNullableFilter<"AuditLogArchive"> | string | null
    fileSize?: IntNullableFilter<"AuditLogArchive"> | number | null
    archivedBy?: StringNullableFilter<"AuditLogArchive"> | string | null
    status?: StringFilter<"AuditLogArchive"> | string
    createdAt?: DateTimeFilter<"AuditLogArchive"> | Date | string
  }

  export type AuditLogSearchUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogSearchWhereUniqueInput
    update: XOR<AuditLogSearchUpdateWithoutCompanyInput, AuditLogSearchUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogSearchCreateWithoutCompanyInput, AuditLogSearchUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogSearchUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogSearchWhereUniqueInput
    data: XOR<AuditLogSearchUpdateWithoutCompanyInput, AuditLogSearchUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogSearchUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogSearchScalarWhereInput
    data: XOR<AuditLogSearchUpdateManyMutationInput, AuditLogSearchUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogSearchScalarWhereInput = {
    AND?: AuditLogSearchScalarWhereInput | AuditLogSearchScalarWhereInput[]
    OR?: AuditLogSearchScalarWhereInput[]
    NOT?: AuditLogSearchScalarWhereInput | AuditLogSearchScalarWhereInput[]
    id?: StringFilter<"AuditLogSearch"> | string
    userId?: StringFilter<"AuditLogSearch"> | string
    companyId?: StringNullableFilter<"AuditLogSearch"> | string | null
    name?: StringNullableFilter<"AuditLogSearch"> | string | null
    searchQuery?: StringFilter<"AuditLogSearch"> | string
    filters?: JsonNullableFilter<"AuditLogSearch">
    createdAt?: DateTimeFilter<"AuditLogSearch"> | Date | string
    lastUsedAt?: DateTimeFilter<"AuditLogSearch"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCompanyInput, ReportUncheckedUpdateWithoutCompanyInput>
    create: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCompanyInput, ReportUncheckedUpdateWithoutCompanyInput>
  }

  export type ReportUpdateManyWithWhereWithoutCompanyInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    reportType?: StringFilter<"Report"> | string
    format?: StringFilter<"Report"> | string
    config?: JsonFilter<"Report">
    status?: StringFilter<"Report"> | string
    filePath?: StringNullableFilter<"Report"> | string | null
    fileSize?: IntNullableFilter<"Report"> | number | null
    generatedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    userId?: StringFilter<"Report"> | string
    companyId?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    templateId?: StringNullableFilter<"Report"> | string | null
  }

  export type ReportTemplateUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ReportTemplateWhereUniqueInput
    update: XOR<ReportTemplateUpdateWithoutCompanyInput, ReportTemplateUncheckedUpdateWithoutCompanyInput>
    create: XOR<ReportTemplateCreateWithoutCompanyInput, ReportTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type ReportTemplateUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ReportTemplateWhereUniqueInput
    data: XOR<ReportTemplateUpdateWithoutCompanyInput, ReportTemplateUncheckedUpdateWithoutCompanyInput>
  }

  export type ReportTemplateUpdateManyWithWhereWithoutCompanyInput = {
    where: ReportTemplateScalarWhereInput
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ReportTemplateScalarWhereInput = {
    AND?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
    OR?: ReportTemplateScalarWhereInput[]
    NOT?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    reportType?: StringFilter<"ReportTemplate"> | string
    category?: StringNullableFilter<"ReportTemplate"> | string | null
    config?: JsonFilter<"ReportTemplate">
    isSystem?: BoolFilter<"ReportTemplate"> | boolean
    isPublic?: BoolFilter<"ReportTemplate"> | boolean
    userId?: StringFilter<"ReportTemplate"> | string
    companyId?: StringNullableFilter<"ReportTemplate"> | string | null
    usageCount?: IntFilter<"ReportTemplate"> | number
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutCompanyInput, ScheduledReportUncheckedUpdateWithoutCompanyInput>
    create: XOR<ScheduledReportCreateWithoutCompanyInput, ScheduledReportUncheckedCreateWithoutCompanyInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutCompanyInput, ScheduledReportUncheckedUpdateWithoutCompanyInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutCompanyInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ScheduledReportScalarWhereInput = {
    AND?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
    OR?: ScheduledReportScalarWhereInput[]
    NOT?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
    id?: StringFilter<"ScheduledReport"> | string
    name?: StringFilter<"ScheduledReport"> | string
    description?: StringNullableFilter<"ScheduledReport"> | string | null
    reportType?: StringFilter<"ScheduledReport"> | string
    format?: StringFilter<"ScheduledReport"> | string
    config?: JsonFilter<"ScheduledReport">
    schedule?: JsonFilter<"ScheduledReport">
    recipients?: JsonNullableFilter<"ScheduledReport">
    templateId?: StringNullableFilter<"ScheduledReport"> | string | null
    isActive?: BoolFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    runCount?: IntFilter<"ScheduledReport"> | number
    userId?: StringFilter<"ScheduledReport"> | string
    companyId?: StringNullableFilter<"ScheduledReport"> | string | null
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type PasswordCreateWithoutOwnerInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutOwnerInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordCreateManyOwnerInputEnvelope = {
    data: PasswordCreateManyOwnerInput | PasswordCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PasswordShareCreateWithoutUserInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutSharedWithInput
    team?: TeamCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateWithoutUserInput = {
    id?: string
    passwordId: string
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareCreateOrConnectWithoutUserInput = {
    where: PasswordShareWhereUniqueInput
    create: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput>
  }

  export type PasswordShareCreateManyUserInputEnvelope = {
    data: PasswordShareCreateManyUserInput | PasswordShareCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ThreatEventCreateWithoutUserInput = {
    id?: string
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    company?: CompanyCreateNestedOneWithoutThreatEventsInput
  }

  export type ThreatEventUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type ThreatEventCreateOrConnectWithoutUserInput = {
    where: ThreatEventWhereUniqueInput
    create: XOR<ThreatEventCreateWithoutUserInput, ThreatEventUncheckedCreateWithoutUserInput>
  }

  export type ThreatEventCreateManyUserInputEnvelope = {
    data: ThreatEventCreateManyUserInput | ThreatEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    deviceFingerprint?: string | null
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    deviceFingerprint?: string | null
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MfaCredentialCreateWithoutUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialUncheckedCreateWithoutUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialCreateOrConnectWithoutUserInput = {
    where: MfaCredentialWhereUniqueInput
    create: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput>
  }

  export type MfaCredentialCreateManyUserInputEnvelope = {
    data: MfaCredentialCreateManyUserInput | MfaCredentialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecoveryCodeCreateWithoutUserInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeUncheckedCreateWithoutUserInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeCreateOrConnectWithoutUserInput = {
    where: RecoveryCodeWhereUniqueInput
    create: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput>
  }

  export type RecoveryCodeCreateManyUserInputEnvelope = {
    data: RecoveryCodeCreateManyUserInput | RecoveryCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordHistoryCreateWithoutChangedByUserInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
    passwordEntry: PasswordCreateNestedOneWithoutHistoryInput
  }

  export type PasswordHistoryUncheckedCreateWithoutChangedByUserInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateOrConnectWithoutChangedByUserInput = {
    where: PasswordHistoryWhereUniqueInput
    create: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput>
  }

  export type PasswordHistoryCreateManyChangedByUserInputEnvelope = {
    data: PasswordHistoryCreateManyChangedByUserInput | PasswordHistoryCreateManyChangedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordBreachCreateWithoutCheckedByUserInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutBreachesInput
    resolvedByUser?: UserCreateNestedOneWithoutPasswordBreachesResolvedInput
  }

  export type PasswordBreachUncheckedCreateWithoutCheckedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachCreateOrConnectWithoutCheckedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    create: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput>
  }

  export type PasswordBreachCreateManyCheckedByUserInputEnvelope = {
    data: PasswordBreachCreateManyCheckedByUserInput | PasswordBreachCreateManyCheckedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordBreachCreateWithoutResolvedByUserInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutBreachesInput
    checkedByUser: UserCreateNestedOneWithoutPasswordBreachesCheckedInput
  }

  export type PasswordBreachUncheckedCreateWithoutResolvedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
  }

  export type PasswordBreachCreateOrConnectWithoutResolvedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    create: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput>
  }

  export type PasswordBreachCreateManyResolvedByUserInputEnvelope = {
    data: PasswordBreachCreateManyResolvedByUserInput | PasswordBreachCreateManyResolvedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationPolicyCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyCreateOrConnectWithoutOwnerInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    create: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordRotationPolicyCreateManyOwnerInputEnvelope = {
    data: PasswordRotationPolicyCreateManyOwnerInput | PasswordRotationPolicyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationCreateWithoutRotatedByUserInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    password: PasswordCreateNestedOneWithoutRotationsInput
    policy?: PasswordRotationPolicyCreateNestedOneWithoutRotationsInput
  }

  export type PasswordRotationUncheckedCreateWithoutRotatedByUserInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationCreateOrConnectWithoutRotatedByUserInput = {
    where: PasswordRotationWhereUniqueInput
    create: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput>
  }

  export type PasswordRotationCreateManyRotatedByUserInputEnvelope = {
    data: PasswordRotationCreateManyRotatedByUserInput | PasswordRotationCreateManyRotatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type TemporaryPasswordShareCreateWithoutCreatorInput = {
    id?: string
    shareToken: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
    password: PasswordCreateNestedOneWithoutTemporarySharesInput
  }

  export type TemporaryPasswordShareUncheckedCreateWithoutCreatorInput = {
    id?: string
    passwordId: string
    shareToken: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TemporaryPasswordShareCreateOrConnectWithoutCreatorInput = {
    where: TemporaryPasswordShareWhereUniqueInput
    create: XOR<TemporaryPasswordShareCreateWithoutCreatorInput, TemporaryPasswordShareUncheckedCreateWithoutCreatorInput>
  }

  export type TemporaryPasswordShareCreateManyCreatorInputEnvelope = {
    data: TemporaryPasswordShareCreateManyCreatorInput | TemporaryPasswordShareCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SavedSearchCreateWithoutUserInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchCreateOrConnectWithoutUserInput = {
    where: SavedSearchWhereUniqueInput
    create: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput>
  }

  export type SavedSearchCreateManyUserInputEnvelope = {
    data: SavedSearchCreateManyUserInput | SavedSearchCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchHistoryCreateWithoutUserInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryCreateOrConnectWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryCreateManyUserInputEnvelope = {
    data: SearchHistoryCreateManyUserInput | SearchHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTemplateCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutTemplatesInput
  }

  export type PasswordTemplateUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateCreateOrConnectWithoutOwnerInput = {
    where: PasswordTemplateWhereUniqueInput
    create: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordTemplateCreateManyOwnerInputEnvelope = {
    data: PasswordTemplateCreateManyOwnerInput | PasswordTemplateCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutReportsInput
    template?: ReportTemplateCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
  }

  export type ReportCreateOrConnectWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportCreateManyCreatedByInputEnvelope = {
    data: ReportCreateManyCreatedByInput | ReportCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutReportTemplatesInput
    reports?: ReportCreateNestedManyWithoutTemplateInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    companyId?: string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutTemplateInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutCreatedByInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutCreatedByInput, ReportTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportTemplateCreateManyCreatedByInputEnvelope = {
    data: ReportTemplateCreateManyCreatedByInput | ReportTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutScheduledReportsInput
    template?: ReportTemplateCreateNestedOneWithoutScheduledReportsInput
  }

  export type ScheduledReportUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: string | null
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateOrConnectWithoutCreatedByInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutCreatedByInput, ScheduledReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ScheduledReportCreateManyCreatedByInputEnvelope = {
    data: ScheduledReportCreateManyCreatedByInput | ScheduledReportCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutCreatedByInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
  }

  export type RoleCreateManyCreatedByInputEnvelope = {
    data: RoleCreateManyCreatedByInput | RoleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type DataExportCreateWithoutUserInput = {
    id?: string
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
    company?: CompanyCreateNestedOneWithoutDataExportsInput
  }

  export type DataExportUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataExportCreateOrConnectWithoutUserInput = {
    where: DataExportWhereUniqueInput
    create: XOR<DataExportCreateWithoutUserInput, DataExportUncheckedCreateWithoutUserInput>
  }

  export type DataExportCreateManyUserInputEnvelope = {
    data: DataExportCreateManyUserInput | DataExportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DataDeletionRequestCreateWithoutUserInput = {
    id?: string
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
    company?: CompanyCreateNestedOneWithoutDataDeletionRequestsInput
    processor?: UserCreateNestedOneWithoutProcessedDeletionsInput
  }

  export type DataDeletionRequestUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    processedBy?: string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestCreateOrConnectWithoutUserInput = {
    where: DataDeletionRequestWhereUniqueInput
    create: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput>
  }

  export type DataDeletionRequestCreateManyUserInputEnvelope = {
    data: DataDeletionRequestCreateManyUserInput | DataDeletionRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DataDeletionRequestCreateWithoutProcessorInput = {
    id?: string
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
    user: UserCreateNestedOneWithoutDataDeletionRequestsInput
    company?: CompanyCreateNestedOneWithoutDataDeletionRequestsInput
  }

  export type DataDeletionRequestUncheckedCreateWithoutProcessorInput = {
    id?: string
    userId: string
    companyId?: string | null
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestCreateOrConnectWithoutProcessorInput = {
    where: DataDeletionRequestWhereUniqueInput
    create: XOR<DataDeletionRequestCreateWithoutProcessorInput, DataDeletionRequestUncheckedCreateWithoutProcessorInput>
  }

  export type DataDeletionRequestCreateManyProcessorInputEnvelope = {
    data: DataDeletionRequestCreateManyProcessorInput | DataDeletionRequestCreateManyProcessorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogArchiveCreateWithoutArchiverInput = {
    id?: string
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    status?: string
    createdAt?: Date | string
    company?: CompanyCreateNestedOneWithoutAuditLogArchivesInput
  }

  export type AuditLogArchiveUncheckedCreateWithoutArchiverInput = {
    id?: string
    companyId?: string | null
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type AuditLogArchiveCreateOrConnectWithoutArchiverInput = {
    where: AuditLogArchiveWhereUniqueInput
    create: XOR<AuditLogArchiveCreateWithoutArchiverInput, AuditLogArchiveUncheckedCreateWithoutArchiverInput>
  }

  export type AuditLogArchiveCreateManyArchiverInputEnvelope = {
    data: AuditLogArchiveCreateManyArchiverInput | AuditLogArchiveCreateManyArchiverInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogSearchCreateWithoutUserInput = {
    id?: string
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutAuditLogSearchesInput
  }

  export type AuditLogSearchUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type AuditLogSearchCreateOrConnectWithoutUserInput = {
    where: AuditLogSearchWhereUniqueInput
    create: XOR<AuditLogSearchCreateWithoutUserInput, AuditLogSearchUncheckedCreateWithoutUserInput>
  }

  export type AuditLogSearchCreateManyUserInputEnvelope = {
    data: AuditLogSearchCreateManyUserInput | AuditLogSearchCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailVerificationTokenCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenCreateOrConnectWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenCreateManyUserInputEnvelope = {
    data: EmailVerificationTokenCreateManyUserInput | EmailVerificationTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SecurityQuestionCreateWithoutUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionUncheckedCreateWithoutUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionCreateOrConnectWithoutUserInput = {
    where: SecurityQuestionWhereUniqueInput
    create: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput>
  }

  export type SecurityQuestionCreateManyUserInputEnvelope = {
    data: SecurityQuestionCreateManyUserInput | SecurityQuestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IpWhitelistCreateWithoutUserInput = {
    id?: string
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutIpWhitelistsInput
    creator?: UserCreateNestedOneWithoutCreatedIpWhitelistsInput
  }

  export type IpWhitelistUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type IpWhitelistCreateOrConnectWithoutUserInput = {
    where: IpWhitelistWhereUniqueInput
    create: XOR<IpWhitelistCreateWithoutUserInput, IpWhitelistUncheckedCreateWithoutUserInput>
  }

  export type IpWhitelistCreateManyUserInputEnvelope = {
    data: IpWhitelistCreateManyUserInput | IpWhitelistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GeographicRestrictionCreateWithoutUserInput = {
    id?: string
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutGeographicRestrictionsInput
    creator?: UserCreateNestedOneWithoutCreatedGeographicRestrictionsInput
  }

  export type GeographicRestrictionUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type GeographicRestrictionCreateOrConnectWithoutUserInput = {
    where: GeographicRestrictionWhereUniqueInput
    create: XOR<GeographicRestrictionCreateWithoutUserInput, GeographicRestrictionUncheckedCreateWithoutUserInput>
  }

  export type GeographicRestrictionCreateManyUserInputEnvelope = {
    data: GeographicRestrictionCreateManyUserInput | GeographicRestrictionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IpWhitelistCreateWithoutCreatorInput = {
    id?: string
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutIpWhitelistsInput
    company?: CompanyCreateNestedOneWithoutIpWhitelistsInput
  }

  export type IpWhitelistUncheckedCreateWithoutCreatorInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IpWhitelistCreateOrConnectWithoutCreatorInput = {
    where: IpWhitelistWhereUniqueInput
    create: XOR<IpWhitelistCreateWithoutCreatorInput, IpWhitelistUncheckedCreateWithoutCreatorInput>
  }

  export type IpWhitelistCreateManyCreatorInputEnvelope = {
    data: IpWhitelistCreateManyCreatorInput | IpWhitelistCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type GeographicRestrictionCreateWithoutCreatorInput = {
    id?: string
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutGeographicRestrictionsInput
    company?: CompanyCreateNestedOneWithoutGeographicRestrictionsInput
  }

  export type GeographicRestrictionUncheckedCreateWithoutCreatorInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeographicRestrictionCreateOrConnectWithoutCreatorInput = {
    where: GeographicRestrictionWhereUniqueInput
    create: XOR<GeographicRestrictionCreateWithoutCreatorInput, GeographicRestrictionUncheckedCreateWithoutCreatorInput>
  }

  export type GeographicRestrictionCreateManyCreatorInputEnvelope = {
    data: GeographicRestrictionCreateManyCreatorInput | GeographicRestrictionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PasswordUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PasswordWhereUniqueInput
    update: XOR<PasswordUpdateWithoutOwnerInput, PasswordUncheckedUpdateWithoutOwnerInput>
    create: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PasswordWhereUniqueInput
    data: XOR<PasswordUpdateWithoutOwnerInput, PasswordUncheckedUpdateWithoutOwnerInput>
  }

  export type PasswordUpdateManyWithWhereWithoutOwnerInput = {
    where: PasswordScalarWhereInput
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PasswordScalarWhereInput = {
    AND?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
    OR?: PasswordScalarWhereInput[]
    NOT?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
    id?: StringFilter<"Password"> | string
    name?: StringFilter<"Password"> | string
    username?: StringFilter<"Password"> | string
    password?: StringFilter<"Password"> | string
    url?: StringNullableFilter<"Password"> | string | null
    notes?: StringNullableFilter<"Password"> | string | null
    folderId?: StringNullableFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"Password"> | boolean
    totpSecret?: StringNullableFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableFilter<"Password"> | Date | string | null
    isFavorite?: BoolFilter<"Password"> | boolean
    ownerId?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableFilter<"Password"> | string | null
  }

  export type PasswordShareUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordShareWhereUniqueInput
    update: XOR<PasswordShareUpdateWithoutUserInput, PasswordShareUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput>
  }

  export type PasswordShareUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordShareWhereUniqueInput
    data: XOR<PasswordShareUpdateWithoutUserInput, PasswordShareUncheckedUpdateWithoutUserInput>
  }

  export type PasswordShareUpdateManyWithWhereWithoutUserInput = {
    where: PasswordShareScalarWhereInput
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordShareScalarWhereInput = {
    AND?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
    OR?: PasswordShareScalarWhereInput[]
    NOT?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
    id?: StringFilter<"PasswordShare"> | string
    passwordId?: StringFilter<"PasswordShare"> | string
    userId?: StringNullableFilter<"PasswordShare"> | string | null
    teamId?: StringNullableFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PasswordShare"> | Date | string | null
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ThreatEventUpsertWithWhereUniqueWithoutUserInput = {
    where: ThreatEventWhereUniqueInput
    update: XOR<ThreatEventUpdateWithoutUserInput, ThreatEventUncheckedUpdateWithoutUserInput>
    create: XOR<ThreatEventCreateWithoutUserInput, ThreatEventUncheckedCreateWithoutUserInput>
  }

  export type ThreatEventUpdateWithWhereUniqueWithoutUserInput = {
    where: ThreatEventWhereUniqueInput
    data: XOR<ThreatEventUpdateWithoutUserInput, ThreatEventUncheckedUpdateWithoutUserInput>
  }

  export type ThreatEventUpdateManyWithWhereWithoutUserInput = {
    where: ThreatEventScalarWhereInput
    data: XOR<ThreatEventUpdateManyMutationInput, ThreatEventUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    deviceType?: StringNullableFilter<"Session"> | string | null
    deviceFingerprint?: StringNullableFilter<"Session"> | string | null
    isTrusted?: BoolFilter<"Session"> | boolean
    requireMfa?: BoolFilter<"Session"> | boolean
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type MfaCredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: MfaCredentialWhereUniqueInput
    update: XOR<MfaCredentialUpdateWithoutUserInput, MfaCredentialUncheckedUpdateWithoutUserInput>
    create: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput>
  }

  export type MfaCredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: MfaCredentialWhereUniqueInput
    data: XOR<MfaCredentialUpdateWithoutUserInput, MfaCredentialUncheckedUpdateWithoutUserInput>
  }

  export type MfaCredentialUpdateManyWithWhereWithoutUserInput = {
    where: MfaCredentialScalarWhereInput
    data: XOR<MfaCredentialUpdateManyMutationInput, MfaCredentialUncheckedUpdateManyWithoutUserInput>
  }

  export type MfaCredentialScalarWhereInput = {
    AND?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
    OR?: MfaCredentialScalarWhereInput[]
    NOT?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
    id?: StringFilter<"MfaCredential"> | string
    userId?: StringFilter<"MfaCredential"> | string
    credentialId?: StringFilter<"MfaCredential"> | string
    publicKey?: StringFilter<"MfaCredential"> | string
    counter?: BigIntFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableFilter<"MfaCredential"> | string | null
    backedUp?: BoolFilter<"MfaCredential"> | boolean
    transports?: StringNullableFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MfaCredential"> | Date | string | null
  }

  export type RecoveryCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: RecoveryCodeWhereUniqueInput
    update: XOR<RecoveryCodeUpdateWithoutUserInput, RecoveryCodeUncheckedUpdateWithoutUserInput>
    create: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput>
  }

  export type RecoveryCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: RecoveryCodeWhereUniqueInput
    data: XOR<RecoveryCodeUpdateWithoutUserInput, RecoveryCodeUncheckedUpdateWithoutUserInput>
  }

  export type RecoveryCodeUpdateManyWithWhereWithoutUserInput = {
    where: RecoveryCodeScalarWhereInput
    data: XOR<RecoveryCodeUpdateManyMutationInput, RecoveryCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type RecoveryCodeScalarWhereInput = {
    AND?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
    OR?: RecoveryCodeScalarWhereInput[]
    NOT?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
    id?: StringFilter<"RecoveryCode"> | string
    userId?: StringFilter<"RecoveryCode"> | string
    codeHash?: StringFilter<"RecoveryCode"> | string
    used?: BoolFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RecoveryCode"> | Date | string
  }

  export type PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput = {
    where: PasswordHistoryWhereUniqueInput
    update: XOR<PasswordHistoryUpdateWithoutChangedByUserInput, PasswordHistoryUncheckedUpdateWithoutChangedByUserInput>
    create: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput>
  }

  export type PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput = {
    where: PasswordHistoryWhereUniqueInput
    data: XOR<PasswordHistoryUpdateWithoutChangedByUserInput, PasswordHistoryUncheckedUpdateWithoutChangedByUserInput>
  }

  export type PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput = {
    where: PasswordHistoryScalarWhereInput
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyWithoutChangedByUserInput>
  }

  export type PasswordHistoryScalarWhereInput = {
    AND?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
    OR?: PasswordHistoryScalarWhereInput[]
    NOT?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
    id?: StringFilter<"PasswordHistory"> | string
    passwordId?: StringFilter<"PasswordHistory"> | string
    name?: StringFilter<"PasswordHistory"> | string
    username?: StringFilter<"PasswordHistory"> | string
    password?: StringFilter<"PasswordHistory"> | string
    url?: StringNullableFilter<"PasswordHistory"> | string | null
    notes?: StringNullableFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringFilter<"PasswordHistory"> | string
    changeType?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
  }

  export type PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    update: XOR<PasswordBreachUpdateWithoutCheckedByUserInput, PasswordBreachUncheckedUpdateWithoutCheckedByUserInput>
    create: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput>
  }

  export type PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    data: XOR<PasswordBreachUpdateWithoutCheckedByUserInput, PasswordBreachUncheckedUpdateWithoutCheckedByUserInput>
  }

  export type PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput = {
    where: PasswordBreachScalarWhereInput
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyWithoutCheckedByUserInput>
  }

  export type PasswordBreachScalarWhereInput = {
    AND?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
    OR?: PasswordBreachScalarWhereInput[]
    NOT?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
    id?: StringFilter<"PasswordBreach"> | string
    passwordId?: StringFilter<"PasswordBreach"> | string
    isBreached?: BoolFilter<"PasswordBreach"> | boolean
    breachCount?: IntFilter<"PasswordBreach"> | number
    hashPrefix?: StringFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringFilter<"PasswordBreach"> | string
    resolved?: BoolFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableFilter<"PasswordBreach"> | string | null
  }

  export type PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    update: XOR<PasswordBreachUpdateWithoutResolvedByUserInput, PasswordBreachUncheckedUpdateWithoutResolvedByUserInput>
    create: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput>
  }

  export type PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    data: XOR<PasswordBreachUpdateWithoutResolvedByUserInput, PasswordBreachUncheckedUpdateWithoutResolvedByUserInput>
  }

  export type PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput = {
    where: PasswordBreachScalarWhereInput
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyWithoutResolvedByUserInput>
  }

  export type PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    update: XOR<PasswordRotationPolicyUpdateWithoutOwnerInput, PasswordRotationPolicyUncheckedUpdateWithoutOwnerInput>
    create: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    data: XOR<PasswordRotationPolicyUpdateWithoutOwnerInput, PasswordRotationPolicyUncheckedUpdateWithoutOwnerInput>
  }

  export type PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput = {
    where: PasswordRotationPolicyScalarWhereInput
    data: XOR<PasswordRotationPolicyUpdateManyMutationInput, PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PasswordRotationPolicyScalarWhereInput = {
    AND?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
    OR?: PasswordRotationPolicyScalarWhereInput[]
    NOT?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
    id?: StringFilter<"PasswordRotationPolicy"> | string
    name?: StringFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
  }

  export type PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput = {
    where: PasswordRotationWhereUniqueInput
    update: XOR<PasswordRotationUpdateWithoutRotatedByUserInput, PasswordRotationUncheckedUpdateWithoutRotatedByUserInput>
    create: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput>
  }

  export type PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput = {
    where: PasswordRotationWhereUniqueInput
    data: XOR<PasswordRotationUpdateWithoutRotatedByUserInput, PasswordRotationUncheckedUpdateWithoutRotatedByUserInput>
  }

  export type PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput = {
    where: PasswordRotationScalarWhereInput
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyWithoutRotatedByUserInput>
  }

  export type PasswordRotationScalarWhereInput = {
    AND?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
    OR?: PasswordRotationScalarWhereInput[]
    NOT?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
    id?: StringFilter<"PasswordRotation"> | string
    passwordId?: StringFilter<"PasswordRotation"> | string
    policyId?: StringNullableFilter<"PasswordRotation"> | string | null
    rotationType?: StringFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableFilter<"PasswordRotation"> | string | null
    newPassword?: StringFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    status?: StringFilter<"PasswordRotation"> | string
    notes?: StringNullableFilter<"PasswordRotation"> | string | null
  }

  export type TemporaryPasswordShareUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TemporaryPasswordShareWhereUniqueInput
    update: XOR<TemporaryPasswordShareUpdateWithoutCreatorInput, TemporaryPasswordShareUncheckedUpdateWithoutCreatorInput>
    create: XOR<TemporaryPasswordShareCreateWithoutCreatorInput, TemporaryPasswordShareUncheckedCreateWithoutCreatorInput>
  }

  export type TemporaryPasswordShareUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TemporaryPasswordShareWhereUniqueInput
    data: XOR<TemporaryPasswordShareUpdateWithoutCreatorInput, TemporaryPasswordShareUncheckedUpdateWithoutCreatorInput>
  }

  export type TemporaryPasswordShareUpdateManyWithWhereWithoutCreatorInput = {
    where: TemporaryPasswordShareScalarWhereInput
    data: XOR<TemporaryPasswordShareUpdateManyMutationInput, TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TemporaryPasswordShareScalarWhereInput = {
    AND?: TemporaryPasswordShareScalarWhereInput | TemporaryPasswordShareScalarWhereInput[]
    OR?: TemporaryPasswordShareScalarWhereInput[]
    NOT?: TemporaryPasswordShareScalarWhereInput | TemporaryPasswordShareScalarWhereInput[]
    id?: StringFilter<"TemporaryPasswordShare"> | string
    passwordId?: StringFilter<"TemporaryPasswordShare"> | string
    shareToken?: StringFilter<"TemporaryPasswordShare"> | string
    createdBy?: StringFilter<"TemporaryPasswordShare"> | string
    accessCount?: IntFilter<"TemporaryPasswordShare"> | number
    maxAccesses?: IntNullableFilter<"TemporaryPasswordShare"> | number | null
    isOneTime?: BoolFilter<"TemporaryPasswordShare"> | boolean
    includeTotp?: BoolFilter<"TemporaryPasswordShare"> | boolean
    expiresAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    accessedAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"TemporaryPasswordShare"> | Date | string | null
    createdAt?: DateTimeFilter<"TemporaryPasswordShare"> | Date | string
  }

  export type SavedSearchUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedSearchWhereUniqueInput
    update: XOR<SavedSearchUpdateWithoutUserInput, SavedSearchUncheckedUpdateWithoutUserInput>
    create: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput>
  }

  export type SavedSearchUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedSearchWhereUniqueInput
    data: XOR<SavedSearchUpdateWithoutUserInput, SavedSearchUncheckedUpdateWithoutUserInput>
  }

  export type SavedSearchUpdateManyWithWhereWithoutUserInput = {
    where: SavedSearchScalarWhereInput
    data: XOR<SavedSearchUpdateManyMutationInput, SavedSearchUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedSearchScalarWhereInput = {
    AND?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
    OR?: SavedSearchScalarWhereInput[]
    NOT?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
    id?: StringFilter<"SavedSearch"> | string
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    query?: StringNullableFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SavedSearch"> | Date | string | null
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutUserInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchHistoryScalarWhereInput = {
    AND?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    OR?: SearchHistoryScalarWhereInput[]
    NOT?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringNullableFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
  }

  export type PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PasswordTemplateWhereUniqueInput
    update: XOR<PasswordTemplateUpdateWithoutOwnerInput, PasswordTemplateUncheckedUpdateWithoutOwnerInput>
    create: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PasswordTemplateWhereUniqueInput
    data: XOR<PasswordTemplateUpdateWithoutOwnerInput, PasswordTemplateUncheckedUpdateWithoutOwnerInput>
  }

  export type PasswordTemplateUpdateManyWithWhereWithoutOwnerInput = {
    where: PasswordTemplateScalarWhereInput
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCreatedByInput, ReportUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCreatedByInput, ReportUncheckedUpdateWithoutCreatedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutCreatedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ReportTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ReportTemplateWhereUniqueInput
    update: XOR<ReportTemplateUpdateWithoutCreatedByInput, ReportTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ReportTemplateCreateWithoutCreatedByInput, ReportTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ReportTemplateWhereUniqueInput
    data: XOR<ReportTemplateUpdateWithoutCreatedByInput, ReportTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type ReportTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: ReportTemplateScalarWhereInput
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutCreatedByInput, ScheduledReportUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ScheduledReportCreateWithoutCreatedByInput, ScheduledReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutCreatedByInput, ScheduledReportUncheckedUpdateWithoutCreatedByInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutCreatedByInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutCreatedByInput, RoleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutCreatedByInput, RoleUncheckedUpdateWithoutCreatedByInput>
  }

  export type RoleUpdateManyWithWhereWithoutCreatedByInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    createdById?: StringNullableFilter<"Role"> | string | null
  }

  export type DataExportUpsertWithWhereUniqueWithoutUserInput = {
    where: DataExportWhereUniqueInput
    update: XOR<DataExportUpdateWithoutUserInput, DataExportUncheckedUpdateWithoutUserInput>
    create: XOR<DataExportCreateWithoutUserInput, DataExportUncheckedCreateWithoutUserInput>
  }

  export type DataExportUpdateWithWhereUniqueWithoutUserInput = {
    where: DataExportWhereUniqueInput
    data: XOR<DataExportUpdateWithoutUserInput, DataExportUncheckedUpdateWithoutUserInput>
  }

  export type DataExportUpdateManyWithWhereWithoutUserInput = {
    where: DataExportScalarWhereInput
    data: XOR<DataExportUpdateManyMutationInput, DataExportUncheckedUpdateManyWithoutUserInput>
  }

  export type DataDeletionRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DataDeletionRequestWhereUniqueInput
    update: XOR<DataDeletionRequestUpdateWithoutUserInput, DataDeletionRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DataDeletionRequestCreateWithoutUserInput, DataDeletionRequestUncheckedCreateWithoutUserInput>
  }

  export type DataDeletionRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DataDeletionRequestWhereUniqueInput
    data: XOR<DataDeletionRequestUpdateWithoutUserInput, DataDeletionRequestUncheckedUpdateWithoutUserInput>
  }

  export type DataDeletionRequestUpdateManyWithWhereWithoutUserInput = {
    where: DataDeletionRequestScalarWhereInput
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DataDeletionRequestUpsertWithWhereUniqueWithoutProcessorInput = {
    where: DataDeletionRequestWhereUniqueInput
    update: XOR<DataDeletionRequestUpdateWithoutProcessorInput, DataDeletionRequestUncheckedUpdateWithoutProcessorInput>
    create: XOR<DataDeletionRequestCreateWithoutProcessorInput, DataDeletionRequestUncheckedCreateWithoutProcessorInput>
  }

  export type DataDeletionRequestUpdateWithWhereUniqueWithoutProcessorInput = {
    where: DataDeletionRequestWhereUniqueInput
    data: XOR<DataDeletionRequestUpdateWithoutProcessorInput, DataDeletionRequestUncheckedUpdateWithoutProcessorInput>
  }

  export type DataDeletionRequestUpdateManyWithWhereWithoutProcessorInput = {
    where: DataDeletionRequestScalarWhereInput
    data: XOR<DataDeletionRequestUpdateManyMutationInput, DataDeletionRequestUncheckedUpdateManyWithoutProcessorInput>
  }

  export type AuditLogArchiveUpsertWithWhereUniqueWithoutArchiverInput = {
    where: AuditLogArchiveWhereUniqueInput
    update: XOR<AuditLogArchiveUpdateWithoutArchiverInput, AuditLogArchiveUncheckedUpdateWithoutArchiverInput>
    create: XOR<AuditLogArchiveCreateWithoutArchiverInput, AuditLogArchiveUncheckedCreateWithoutArchiverInput>
  }

  export type AuditLogArchiveUpdateWithWhereUniqueWithoutArchiverInput = {
    where: AuditLogArchiveWhereUniqueInput
    data: XOR<AuditLogArchiveUpdateWithoutArchiverInput, AuditLogArchiveUncheckedUpdateWithoutArchiverInput>
  }

  export type AuditLogArchiveUpdateManyWithWhereWithoutArchiverInput = {
    where: AuditLogArchiveScalarWhereInput
    data: XOR<AuditLogArchiveUpdateManyMutationInput, AuditLogArchiveUncheckedUpdateManyWithoutArchiverInput>
  }

  export type AuditLogSearchUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogSearchWhereUniqueInput
    update: XOR<AuditLogSearchUpdateWithoutUserInput, AuditLogSearchUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogSearchCreateWithoutUserInput, AuditLogSearchUncheckedCreateWithoutUserInput>
  }

  export type AuditLogSearchUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogSearchWhereUniqueInput
    data: XOR<AuditLogSearchUpdateWithoutUserInput, AuditLogSearchUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogSearchUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogSearchScalarWhereInput
    data: XOR<AuditLogSearchUpdateManyMutationInput, AuditLogSearchUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    update: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    data: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: EmailVerificationTokenScalarWhereInput
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailVerificationTokenScalarWhereInput = {
    AND?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
    OR?: EmailVerificationTokenScalarWhereInput[]
    NOT?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
    id?: StringFilter<"EmailVerificationToken"> | string
    token?: StringFilter<"EmailVerificationToken"> | string
    userId?: StringFilter<"EmailVerificationToken"> | string
    email?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type SecurityQuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: SecurityQuestionWhereUniqueInput
    update: XOR<SecurityQuestionUpdateWithoutUserInput, SecurityQuestionUncheckedUpdateWithoutUserInput>
    create: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput>
  }

  export type SecurityQuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: SecurityQuestionWhereUniqueInput
    data: XOR<SecurityQuestionUpdateWithoutUserInput, SecurityQuestionUncheckedUpdateWithoutUserInput>
  }

  export type SecurityQuestionUpdateManyWithWhereWithoutUserInput = {
    where: SecurityQuestionScalarWhereInput
    data: XOR<SecurityQuestionUpdateManyMutationInput, SecurityQuestionUncheckedUpdateManyWithoutUserInput>
  }

  export type SecurityQuestionScalarWhereInput = {
    AND?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
    OR?: SecurityQuestionScalarWhereInput[]
    NOT?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
    id?: StringFilter<"SecurityQuestion"> | string
    userId?: StringFilter<"SecurityQuestion"> | string
    question?: StringFilter<"SecurityQuestion"> | string
    answerHash?: StringFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
  }

  export type IpWhitelistUpsertWithWhereUniqueWithoutUserInput = {
    where: IpWhitelistWhereUniqueInput
    update: XOR<IpWhitelistUpdateWithoutUserInput, IpWhitelistUncheckedUpdateWithoutUserInput>
    create: XOR<IpWhitelistCreateWithoutUserInput, IpWhitelistUncheckedCreateWithoutUserInput>
  }

  export type IpWhitelistUpdateWithWhereUniqueWithoutUserInput = {
    where: IpWhitelistWhereUniqueInput
    data: XOR<IpWhitelistUpdateWithoutUserInput, IpWhitelistUncheckedUpdateWithoutUserInput>
  }

  export type IpWhitelistUpdateManyWithWhereWithoutUserInput = {
    where: IpWhitelistScalarWhereInput
    data: XOR<IpWhitelistUpdateManyMutationInput, IpWhitelistUncheckedUpdateManyWithoutUserInput>
  }

  export type GeographicRestrictionUpsertWithWhereUniqueWithoutUserInput = {
    where: GeographicRestrictionWhereUniqueInput
    update: XOR<GeographicRestrictionUpdateWithoutUserInput, GeographicRestrictionUncheckedUpdateWithoutUserInput>
    create: XOR<GeographicRestrictionCreateWithoutUserInput, GeographicRestrictionUncheckedCreateWithoutUserInput>
  }

  export type GeographicRestrictionUpdateWithWhereUniqueWithoutUserInput = {
    where: GeographicRestrictionWhereUniqueInput
    data: XOR<GeographicRestrictionUpdateWithoutUserInput, GeographicRestrictionUncheckedUpdateWithoutUserInput>
  }

  export type GeographicRestrictionUpdateManyWithWhereWithoutUserInput = {
    where: GeographicRestrictionScalarWhereInput
    data: XOR<GeographicRestrictionUpdateManyMutationInput, GeographicRestrictionUncheckedUpdateManyWithoutUserInput>
  }

  export type IpWhitelistUpsertWithWhereUniqueWithoutCreatorInput = {
    where: IpWhitelistWhereUniqueInput
    update: XOR<IpWhitelistUpdateWithoutCreatorInput, IpWhitelistUncheckedUpdateWithoutCreatorInput>
    create: XOR<IpWhitelistCreateWithoutCreatorInput, IpWhitelistUncheckedCreateWithoutCreatorInput>
  }

  export type IpWhitelistUpdateWithWhereUniqueWithoutCreatorInput = {
    where: IpWhitelistWhereUniqueInput
    data: XOR<IpWhitelistUpdateWithoutCreatorInput, IpWhitelistUncheckedUpdateWithoutCreatorInput>
  }

  export type IpWhitelistUpdateManyWithWhereWithoutCreatorInput = {
    where: IpWhitelistScalarWhereInput
    data: XOR<IpWhitelistUpdateManyMutationInput, IpWhitelistUncheckedUpdateManyWithoutCreatorInput>
  }

  export type GeographicRestrictionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GeographicRestrictionWhereUniqueInput
    update: XOR<GeographicRestrictionUpdateWithoutCreatorInput, GeographicRestrictionUncheckedUpdateWithoutCreatorInput>
    create: XOR<GeographicRestrictionCreateWithoutCreatorInput, GeographicRestrictionUncheckedCreateWithoutCreatorInput>
  }

  export type GeographicRestrictionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GeographicRestrictionWhereUniqueInput
    data: XOR<GeographicRestrictionUpdateWithoutCreatorInput, GeographicRestrictionUncheckedUpdateWithoutCreatorInput>
  }

  export type GeographicRestrictionUpdateManyWithWhereWithoutCreatorInput = {
    where: GeographicRestrictionScalarWhereInput
    data: XOR<GeographicRestrictionUpdateManyMutationInput, GeographicRestrictionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutOwnedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOwnedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOwnedPasswordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
  }

  export type FolderCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
  }

  export type FolderUncheckedCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type FolderCreateOrConnectWithoutPasswordsInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
  }

  export type PasswordShareCreateWithoutPasswordInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user?: UserCreateNestedOneWithoutSharedPasswordsInput
    team?: TeamCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateWithoutPasswordInput = {
    id?: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareCreateOrConnectWithoutPasswordInput = {
    where: PasswordShareWhereUniqueInput
    create: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordShareCreateManyPasswordInputEnvelope = {
    data: PasswordShareCreateManyPasswordInput | PasswordShareCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type TemporaryPasswordShareCreateWithoutPasswordInput = {
    id?: string
    shareToken: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTemporaryPasswordSharesInput
  }

  export type TemporaryPasswordShareUncheckedCreateWithoutPasswordInput = {
    id?: string
    shareToken: string
    createdBy: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TemporaryPasswordShareCreateOrConnectWithoutPasswordInput = {
    where: TemporaryPasswordShareWhereUniqueInput
    create: XOR<TemporaryPasswordShareCreateWithoutPasswordInput, TemporaryPasswordShareUncheckedCreateWithoutPasswordInput>
  }

  export type TemporaryPasswordShareCreateManyPasswordInputEnvelope = {
    data: TemporaryPasswordShareCreateManyPasswordInput | TemporaryPasswordShareCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTagCreateWithoutPasswordInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordTagUncheckedCreateWithoutPasswordInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordTagCreateOrConnectWithoutPasswordInput = {
    where: PasswordTagWhereUniqueInput
    create: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordTagCreateManyPasswordInputEnvelope = {
    data: PasswordTagCreateManyPasswordInput | PasswordTagCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordHistoryCreateWithoutPasswordEntryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
    changedByUser: UserCreateNestedOneWithoutPasswordHistoryInput
  }

  export type PasswordHistoryUncheckedCreateWithoutPasswordEntryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateOrConnectWithoutPasswordEntryInput = {
    where: PasswordHistoryWhereUniqueInput
    create: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput>
  }

  export type PasswordHistoryCreateManyPasswordEntryInputEnvelope = {
    data: PasswordHistoryCreateManyPasswordEntryInput | PasswordHistoryCreateManyPasswordEntryInput[]
    skipDuplicates?: boolean
  }

  export type PasswordBreachCreateWithoutPasswordInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    checkedByUser: UserCreateNestedOneWithoutPasswordBreachesCheckedInput
    resolvedByUser?: UserCreateNestedOneWithoutPasswordBreachesResolvedInput
  }

  export type PasswordBreachUncheckedCreateWithoutPasswordInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachCreateOrConnectWithoutPasswordInput = {
    where: PasswordBreachWhereUniqueInput
    create: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordBreachCreateManyPasswordInputEnvelope = {
    data: PasswordBreachCreateManyPasswordInput | PasswordBreachCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationCreateWithoutPasswordInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    policy?: PasswordRotationPolicyCreateNestedOneWithoutRotationsInput
    rotatedByUser: UserCreateNestedOneWithoutPasswordRotationsInput
  }

  export type PasswordRotationUncheckedCreateWithoutPasswordInput = {
    id?: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationCreateOrConnectWithoutPasswordInput = {
    where: PasswordRotationWhereUniqueInput
    create: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordRotationCreateManyPasswordInputEnvelope = {
    data: PasswordRotationCreateManyPasswordInput | PasswordRotationCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationPolicyCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutRotationPoliciesInput
    rotations?: PasswordRotationCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyCreateOrConnectWithoutPasswordsInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    create: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
  }

  export type UserUpsertWithoutOwnedPasswordsInput = {
    update: XOR<UserUpdateWithoutOwnedPasswordsInput, UserUncheckedUpdateWithoutOwnedPasswordsInput>
    create: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedPasswordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedPasswordsInput, UserUncheckedUpdateWithoutOwnedPasswordsInput>
  }

  export type UserUpdateWithoutOwnedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type FolderUpsertWithoutPasswordsInput = {
    update: XOR<FolderUpdateWithoutPasswordsInput, FolderUncheckedUpdateWithoutPasswordsInput>
    create: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutPasswordsInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutPasswordsInput, FolderUncheckedUpdateWithoutPasswordsInput>
  }

  export type FolderUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
  }

  export type FolderUncheckedUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PasswordShareUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordShareWhereUniqueInput
    update: XOR<PasswordShareUpdateWithoutPasswordInput, PasswordShareUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordShareUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordShareWhereUniqueInput
    data: XOR<PasswordShareUpdateWithoutPasswordInput, PasswordShareUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordShareUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordShareScalarWhereInput
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyWithoutPasswordInput>
  }

  export type TemporaryPasswordShareUpsertWithWhereUniqueWithoutPasswordInput = {
    where: TemporaryPasswordShareWhereUniqueInput
    update: XOR<TemporaryPasswordShareUpdateWithoutPasswordInput, TemporaryPasswordShareUncheckedUpdateWithoutPasswordInput>
    create: XOR<TemporaryPasswordShareCreateWithoutPasswordInput, TemporaryPasswordShareUncheckedCreateWithoutPasswordInput>
  }

  export type TemporaryPasswordShareUpdateWithWhereUniqueWithoutPasswordInput = {
    where: TemporaryPasswordShareWhereUniqueInput
    data: XOR<TemporaryPasswordShareUpdateWithoutPasswordInput, TemporaryPasswordShareUncheckedUpdateWithoutPasswordInput>
  }

  export type TemporaryPasswordShareUpdateManyWithWhereWithoutPasswordInput = {
    where: TemporaryPasswordShareScalarWhereInput
    data: XOR<TemporaryPasswordShareUpdateManyMutationInput, TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordTagUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordTagWhereUniqueInput
    update: XOR<PasswordTagUpdateWithoutPasswordInput, PasswordTagUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordTagUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordTagWhereUniqueInput
    data: XOR<PasswordTagUpdateWithoutPasswordInput, PasswordTagUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordTagUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordTagScalarWhereInput
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordTagScalarWhereInput = {
    AND?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
    OR?: PasswordTagScalarWhereInput[]
    NOT?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
    id?: StringFilter<"PasswordTag"> | string
    passwordId?: StringFilter<"PasswordTag"> | string
    tagId?: StringFilter<"PasswordTag"> | string
    createdAt?: DateTimeFilter<"PasswordTag"> | Date | string
  }

  export type PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput = {
    where: PasswordHistoryWhereUniqueInput
    update: XOR<PasswordHistoryUpdateWithoutPasswordEntryInput, PasswordHistoryUncheckedUpdateWithoutPasswordEntryInput>
    create: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput>
  }

  export type PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput = {
    where: PasswordHistoryWhereUniqueInput
    data: XOR<PasswordHistoryUpdateWithoutPasswordEntryInput, PasswordHistoryUncheckedUpdateWithoutPasswordEntryInput>
  }

  export type PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput = {
    where: PasswordHistoryScalarWhereInput
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryInput>
  }

  export type PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordBreachWhereUniqueInput
    update: XOR<PasswordBreachUpdateWithoutPasswordInput, PasswordBreachUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordBreachWhereUniqueInput
    data: XOR<PasswordBreachUpdateWithoutPasswordInput, PasswordBreachUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordBreachUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordBreachScalarWhereInput
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordRotationWhereUniqueInput
    update: XOR<PasswordRotationUpdateWithoutPasswordInput, PasswordRotationUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordRotationWhereUniqueInput
    data: XOR<PasswordRotationUpdateWithoutPasswordInput, PasswordRotationUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordRotationUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordRotationScalarWhereInput
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordRotationPolicyUpsertWithoutPasswordsInput = {
    update: XOR<PasswordRotationPolicyUpdateWithoutPasswordsInput, PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput>
    create: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
    where?: PasswordRotationPolicyWhereInput
  }

  export type PasswordRotationPolicyUpdateToOneWithWhereWithoutPasswordsInput = {
    where?: PasswordRotationPolicyWhereInput
    data: XOR<PasswordRotationPolicyUpdateWithoutPasswordsInput, PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput>
  }

  export type PasswordRotationPolicyUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutRotationPoliciesNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordCreateWithoutHistoryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutHistoryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutHistoryInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutPasswordHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPasswordHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPasswordHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
  }

  export type PasswordUpsertWithoutHistoryInput = {
    update: XOR<PasswordUpdateWithoutHistoryInput, PasswordUncheckedUpdateWithoutHistoryInput>
    create: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutHistoryInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutHistoryInput, PasswordUncheckedUpdateWithoutHistoryInput>
  }

  export type PasswordUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type UserUpsertWithoutPasswordHistoryInput = {
    update: XOR<UserUpdateWithoutPasswordHistoryInput, UserUncheckedUpdateWithoutPasswordHistoryInput>
    create: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordHistoryInput, UserUncheckedUpdateWithoutPasswordHistoryInput>
  }

  export type UserUpdateWithoutPasswordHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PasswordCreateWithoutBreachesInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutBreachesInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutBreachesInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
  }

  export type UserCreateWithoutPasswordBreachesCheckedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPasswordBreachesCheckedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPasswordBreachesCheckedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
  }

  export type UserCreateWithoutPasswordBreachesResolvedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPasswordBreachesResolvedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPasswordBreachesResolvedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
  }

  export type PasswordUpsertWithoutBreachesInput = {
    update: XOR<PasswordUpdateWithoutBreachesInput, PasswordUncheckedUpdateWithoutBreachesInput>
    create: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutBreachesInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutBreachesInput, PasswordUncheckedUpdateWithoutBreachesInput>
  }

  export type PasswordUpdateWithoutBreachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutBreachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type UserUpsertWithoutPasswordBreachesCheckedInput = {
    update: XOR<UserUpdateWithoutPasswordBreachesCheckedInput, UserUncheckedUpdateWithoutPasswordBreachesCheckedInput>
    create: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordBreachesCheckedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordBreachesCheckedInput, UserUncheckedUpdateWithoutPasswordBreachesCheckedInput>
  }

  export type UserUpdateWithoutPasswordBreachesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordBreachesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutPasswordBreachesResolvedInput = {
    update: XOR<UserUpdateWithoutPasswordBreachesResolvedInput, UserUncheckedUpdateWithoutPasswordBreachesResolvedInput>
    create: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordBreachesResolvedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordBreachesResolvedInput, UserUncheckedUpdateWithoutPasswordBreachesResolvedInput>
  }

  export type UserUpdateWithoutPasswordBreachesResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordBreachesResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutRotationPoliciesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRotationPoliciesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRotationPoliciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
  }

  export type PasswordCreateWithoutRotationPolicyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
  }

  export type PasswordUncheckedCreateWithoutRotationPolicyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutRotationPolicyInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput>
  }

  export type PasswordCreateManyRotationPolicyInputEnvelope = {
    data: PasswordCreateManyRotationPolicyInput | PasswordCreateManyRotationPolicyInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationCreateWithoutPolicyInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    password: PasswordCreateNestedOneWithoutRotationsInput
    rotatedByUser: UserCreateNestedOneWithoutPasswordRotationsInput
  }

  export type PasswordRotationUncheckedCreateWithoutPolicyInput = {
    id?: string
    passwordId: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationCreateOrConnectWithoutPolicyInput = {
    where: PasswordRotationWhereUniqueInput
    create: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput>
  }

  export type PasswordRotationCreateManyPolicyInputEnvelope = {
    data: PasswordRotationCreateManyPolicyInput | PasswordRotationCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRotationPoliciesInput = {
    update: XOR<UserUpdateWithoutRotationPoliciesInput, UserUncheckedUpdateWithoutRotationPoliciesInput>
    create: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRotationPoliciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRotationPoliciesInput, UserUncheckedUpdateWithoutRotationPoliciesInput>
  }

  export type UserUpdateWithoutRotationPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRotationPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput = {
    where: PasswordWhereUniqueInput
    update: XOR<PasswordUpdateWithoutRotationPolicyInput, PasswordUncheckedUpdateWithoutRotationPolicyInput>
    create: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput>
  }

  export type PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput = {
    where: PasswordWhereUniqueInput
    data: XOR<PasswordUpdateWithoutRotationPolicyInput, PasswordUncheckedUpdateWithoutRotationPolicyInput>
  }

  export type PasswordUpdateManyWithWhereWithoutRotationPolicyInput = {
    where: PasswordScalarWhereInput
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyWithoutRotationPolicyInput>
  }

  export type PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput = {
    where: PasswordRotationWhereUniqueInput
    update: XOR<PasswordRotationUpdateWithoutPolicyInput, PasswordRotationUncheckedUpdateWithoutPolicyInput>
    create: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput>
  }

  export type PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput = {
    where: PasswordRotationWhereUniqueInput
    data: XOR<PasswordRotationUpdateWithoutPolicyInput, PasswordRotationUncheckedUpdateWithoutPolicyInput>
  }

  export type PasswordRotationUpdateManyWithWhereWithoutPolicyInput = {
    where: PasswordRotationScalarWhereInput
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyWithoutPolicyInput>
  }

  export type PasswordCreateWithoutRotationsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutRotationsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutRotationsInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
  }

  export type PasswordRotationPolicyCreateWithoutRotationsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutRotationPoliciesInput
    passwords?: PasswordCreateNestedManyWithoutRotationPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateWithoutRotationsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput
  }

  export type PasswordRotationPolicyCreateOrConnectWithoutRotationsInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    create: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
  }

  export type UserCreateWithoutPasswordRotationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPasswordRotationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPasswordRotationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
  }

  export type PasswordUpsertWithoutRotationsInput = {
    update: XOR<PasswordUpdateWithoutRotationsInput, PasswordUncheckedUpdateWithoutRotationsInput>
    create: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutRotationsInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutRotationsInput, PasswordUncheckedUpdateWithoutRotationsInput>
  }

  export type PasswordUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordRotationPolicyUpsertWithoutRotationsInput = {
    update: XOR<PasswordRotationPolicyUpdateWithoutRotationsInput, PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput>
    create: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
    where?: PasswordRotationPolicyWhereInput
  }

  export type PasswordRotationPolicyUpdateToOneWithWhereWithoutRotationsInput = {
    where?: PasswordRotationPolicyWhereInput
    data: XOR<PasswordRotationPolicyUpdateWithoutRotationsInput, PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput>
  }

  export type PasswordRotationPolicyUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutRotationPoliciesNestedInput
    passwords?: PasswordUpdateManyWithoutRotationPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput
  }

  export type UserUpsertWithoutPasswordRotationsInput = {
    update: XOR<UserUpdateWithoutPasswordRotationsInput, UserUncheckedUpdateWithoutPasswordRotationsInput>
    create: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordRotationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordRotationsInput, UserUncheckedUpdateWithoutPasswordRotationsInput>
  }

  export type UserUpdateWithoutPasswordRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type FolderCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FolderCreateNestedOneWithoutChildrenInput
    passwords?: PasswordCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutChildrenInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
  }

  export type FolderCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderCreateNestedManyWithoutParentInput
    passwords?: PasswordCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    passwords?: PasswordUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutParentInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderCreateManyParentInputEnvelope = {
    data: FolderCreateManyParentInput | FolderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PasswordCreateWithoutFolderInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutFolderInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput>
  }

  export type PasswordCreateManyFolderInputEnvelope = {
    data: PasswordCreateManyFolderInput | PasswordCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type FolderUpsertWithoutChildrenInput = {
    update: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    passwords?: PasswordUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUpsertWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
  }

  export type FolderUpdateManyWithWhereWithoutParentInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutParentInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    icon?: StringNullableFilter<"Folder"> | string | null
    color?: StringNullableFilter<"Folder"> | string | null
    parentId?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
  }

  export type PasswordUpsertWithWhereUniqueWithoutFolderInput = {
    where: PasswordWhereUniqueInput
    update: XOR<PasswordUpdateWithoutFolderInput, PasswordUncheckedUpdateWithoutFolderInput>
    create: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput>
  }

  export type PasswordUpdateWithWhereUniqueWithoutFolderInput = {
    where: PasswordWhereUniqueInput
    data: XOR<PasswordUpdateWithoutFolderInput, PasswordUncheckedUpdateWithoutFolderInput>
  }

  export type PasswordUpdateManyWithWhereWithoutFolderInput = {
    where: PasswordScalarWhereInput
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyWithoutFolderInput>
  }

  export type PasswordCreateWithoutSharedWithInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutSharedWithInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutSharedWithInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
  }

  export type UserCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSharedPasswordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
  }

  export type TeamCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSharedPasswordsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
  }

  export type PasswordUpsertWithoutSharedWithInput = {
    update: XOR<PasswordUpdateWithoutSharedWithInput, PasswordUncheckedUpdateWithoutSharedWithInput>
    create: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutSharedWithInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutSharedWithInput, PasswordUncheckedUpdateWithoutSharedWithInput>
  }

  export type PasswordUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type UserUpsertWithoutSharedPasswordsInput = {
    update: XOR<UserUpdateWithoutSharedPasswordsInput, UserUncheckedUpdateWithoutSharedPasswordsInput>
    create: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedPasswordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedPasswordsInput, UserUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type UserUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TeamUpsertWithoutSharedPasswordsInput = {
    update: XOR<TeamUpdateWithoutSharedPasswordsInput, TeamUncheckedUpdateWithoutSharedPasswordsInput>
    create: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSharedPasswordsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSharedPasswordsInput, TeamUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type TeamUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type PasswordCreateWithoutTemporarySharesInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutTemporarySharesInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutTemporarySharesInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutTemporarySharesInput, PasswordUncheckedCreateWithoutTemporarySharesInput>
  }

  export type UserCreateWithoutTemporaryPasswordSharesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTemporaryPasswordSharesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTemporaryPasswordSharesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTemporaryPasswordSharesInput, UserUncheckedCreateWithoutTemporaryPasswordSharesInput>
  }

  export type PasswordUpsertWithoutTemporarySharesInput = {
    update: XOR<PasswordUpdateWithoutTemporarySharesInput, PasswordUncheckedUpdateWithoutTemporarySharesInput>
    create: XOR<PasswordCreateWithoutTemporarySharesInput, PasswordUncheckedCreateWithoutTemporarySharesInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutTemporarySharesInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutTemporarySharesInput, PasswordUncheckedUpdateWithoutTemporarySharesInput>
  }

  export type PasswordUpdateWithoutTemporarySharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutTemporarySharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type UserUpsertWithoutTemporaryPasswordSharesInput = {
    update: XOR<UserUpdateWithoutTemporaryPasswordSharesInput, UserUncheckedUpdateWithoutTemporaryPasswordSharesInput>
    create: XOR<UserCreateWithoutTemporaryPasswordSharesInput, UserUncheckedCreateWithoutTemporaryPasswordSharesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTemporaryPasswordSharesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTemporaryPasswordSharesInput, UserUncheckedUpdateWithoutTemporaryPasswordSharesInput>
  }

  export type UserUpdateWithoutTemporaryPasswordSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTemporaryPasswordSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PasswordShareCreateWithoutTeamInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutSharedWithInput
    user?: UserCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateWithoutTeamInput = {
    id?: string
    passwordId: string
    userId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareCreateOrConnectWithoutTeamInput = {
    where: PasswordShareWhereUniqueInput
    create: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput>
  }

  export type PasswordShareCreateManyTeamInputEnvelope = {
    data: PasswordShareCreateManyTeamInput | PasswordShareCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type PasswordShareUpsertWithWhereUniqueWithoutTeamInput = {
    where: PasswordShareWhereUniqueInput
    update: XOR<PasswordShareUpdateWithoutTeamInput, PasswordShareUncheckedUpdateWithoutTeamInput>
    create: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput>
  }

  export type PasswordShareUpdateWithWhereUniqueWithoutTeamInput = {
    where: PasswordShareWhereUniqueInput
    data: XOR<PasswordShareUpdateWithoutTeamInput, PasswordShareUncheckedUpdateWithoutTeamInput>
  }

  export type PasswordShareUpdateManyWithWhereWithoutTeamInput = {
    where: PasswordShareScalarWhereInput
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedPasswords?: PasswordShareCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedPasswords?: PasswordShareUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PasswordTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    password: PasswordCreateNestedOneWithoutTagsInput
  }

  export type PasswordTagUncheckedCreateWithoutTagInput = {
    id?: string
    passwordId: string
    createdAt?: Date | string
  }

  export type PasswordTagCreateOrConnectWithoutTagInput = {
    where: PasswordTagWhereUniqueInput
    create: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput>
  }

  export type PasswordTagCreateManyTagInputEnvelope = {
    data: PasswordTagCreateManyTagInput | PasswordTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PasswordTagWhereUniqueInput
    update: XOR<PasswordTagUpdateWithoutTagInput, PasswordTagUncheckedUpdateWithoutTagInput>
    create: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput>
  }

  export type PasswordTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PasswordTagWhereUniqueInput
    data: XOR<PasswordTagUpdateWithoutTagInput, PasswordTagUncheckedUpdateWithoutTagInput>
  }

  export type PasswordTagUpdateManyWithWhereWithoutTagInput = {
    where: PasswordTagScalarWhereInput
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyWithoutTagInput>
  }

  export type PasswordCreateWithoutTagsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    temporaryShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutTagsInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPasswordsInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type TagUncheckedCreateWithoutPasswordsInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type TagCreateOrConnectWithoutPasswordsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
  }

  export type PasswordUpsertWithoutTagsInput = {
    update: XOR<PasswordUpdateWithoutTagsInput, PasswordUncheckedUpdateWithoutTagsInput>
    create: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutTagsInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutTagsInput, PasswordUncheckedUpdateWithoutTagsInput>
  }

  export type PasswordUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type TagUpsertWithoutPasswordsInput = {
    update: XOR<TagUpdateWithoutPasswordsInput, TagUncheckedUpdateWithoutPasswordsInput>
    create: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPasswordsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPasswordsInput, TagUncheckedUpdateWithoutPasswordsInput>
  }

  export type TagUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyCreateWithoutAuditLogArchivesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogArchivesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogArchivesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogArchivesInput, CompanyUncheckedCreateWithoutAuditLogArchivesInput>
  }

  export type UserCreateWithoutAuditLogArchivesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogArchivesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogArchivesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogArchivesInput, UserUncheckedCreateWithoutAuditLogArchivesInput>
  }

  export type CompanyUpsertWithoutAuditLogArchivesInput = {
    update: XOR<CompanyUpdateWithoutAuditLogArchivesInput, CompanyUncheckedUpdateWithoutAuditLogArchivesInput>
    create: XOR<CompanyCreateWithoutAuditLogArchivesInput, CompanyUncheckedCreateWithoutAuditLogArchivesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogArchivesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogArchivesInput, CompanyUncheckedUpdateWithoutAuditLogArchivesInput>
  }

  export type CompanyUpdateWithoutAuditLogArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutAuditLogArchivesInput = {
    update: XOR<UserUpdateWithoutAuditLogArchivesInput, UserUncheckedUpdateWithoutAuditLogArchivesInput>
    create: XOR<UserCreateWithoutAuditLogArchivesInput, UserUncheckedCreateWithoutAuditLogArchivesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogArchivesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogArchivesInput, UserUncheckedUpdateWithoutAuditLogArchivesInput>
  }

  export type UserUpdateWithoutAuditLogArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAuditLogSearchesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogSearchesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogSearchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogSearchesInput, UserUncheckedCreateWithoutAuditLogSearchesInput>
  }

  export type CompanyCreateWithoutAuditLogSearchesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogSearchesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogSearchesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogSearchesInput, CompanyUncheckedCreateWithoutAuditLogSearchesInput>
  }

  export type UserUpsertWithoutAuditLogSearchesInput = {
    update: XOR<UserUpdateWithoutAuditLogSearchesInput, UserUncheckedUpdateWithoutAuditLogSearchesInput>
    create: XOR<UserCreateWithoutAuditLogSearchesInput, UserUncheckedCreateWithoutAuditLogSearchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogSearchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogSearchesInput, UserUncheckedUpdateWithoutAuditLogSearchesInput>
  }

  export type UserUpdateWithoutAuditLogSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutAuditLogSearchesInput = {
    update: XOR<CompanyUpdateWithoutAuditLogSearchesInput, CompanyUncheckedUpdateWithoutAuditLogSearchesInput>
    create: XOR<CompanyCreateWithoutAuditLogSearchesInput, CompanyUncheckedCreateWithoutAuditLogSearchesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogSearchesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogSearchesInput, CompanyUncheckedUpdateWithoutAuditLogSearchesInput>
  }

  export type CompanyUpdateWithoutAuditLogSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutThreatEventsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutThreatEventsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutThreatEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThreatEventsInput, UserUncheckedCreateWithoutThreatEventsInput>
  }

  export type CompanyCreateWithoutThreatEventsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutThreatEventsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutThreatEventsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutThreatEventsInput, CompanyUncheckedCreateWithoutThreatEventsInput>
  }

  export type UserUpsertWithoutThreatEventsInput = {
    update: XOR<UserUpdateWithoutThreatEventsInput, UserUncheckedUpdateWithoutThreatEventsInput>
    create: XOR<UserCreateWithoutThreatEventsInput, UserUncheckedCreateWithoutThreatEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutThreatEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutThreatEventsInput, UserUncheckedUpdateWithoutThreatEventsInput>
  }

  export type UserUpdateWithoutThreatEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutThreatEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutThreatEventsInput = {
    update: XOR<CompanyUpdateWithoutThreatEventsInput, CompanyUncheckedUpdateWithoutThreatEventsInput>
    create: XOR<CompanyCreateWithoutThreatEventsInput, CompanyUncheckedCreateWithoutThreatEventsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutThreatEventsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutThreatEventsInput, CompanyUncheckedUpdateWithoutThreatEventsInput>
  }

  export type CompanyUpdateWithoutThreatEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutThreatEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutRateLimitsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutRateLimitsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutRateLimitsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutRateLimitsInput, CompanyUncheckedCreateWithoutRateLimitsInput>
  }

  export type CompanyUpsertWithoutRateLimitsInput = {
    update: XOR<CompanyUpdateWithoutRateLimitsInput, CompanyUncheckedUpdateWithoutRateLimitsInput>
    create: XOR<CompanyCreateWithoutRateLimitsInput, CompanyUncheckedCreateWithoutRateLimitsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutRateLimitsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutRateLimitsInput, CompanyUncheckedUpdateWithoutRateLimitsInput>
  }

  export type CompanyUpdateWithoutRateLimitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutRateLimitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutCreatedRolesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedRolesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedRolesInput = {
    update: XOR<UserUpdateWithoutCreatedRolesInput, UserUncheckedUpdateWithoutCreatedRolesInput>
    create: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRolesInput, UserUncheckedUpdateWithoutCreatedRolesInput>
  }

  export type UserUpdateWithoutCreatedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedRolesInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMfaCredentialsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMfaCredentialsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMfaCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
  }

  export type UserUpsertWithoutMfaCredentialsInput = {
    update: XOR<UserUpdateWithoutMfaCredentialsInput, UserUncheckedUpdateWithoutMfaCredentialsInput>
    create: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMfaCredentialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMfaCredentialsInput, UserUncheckedUpdateWithoutMfaCredentialsInput>
  }

  export type UserUpdateWithoutMfaCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMfaCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutRecoveryCodesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRecoveryCodesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRecoveryCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
  }

  export type UserUpsertWithoutRecoveryCodesInput = {
    update: XOR<UserUpdateWithoutRecoveryCodesInput, UserUncheckedUpdateWithoutRecoveryCodesInput>
    create: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecoveryCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecoveryCodesInput, UserUncheckedUpdateWithoutRecoveryCodesInput>
  }

  export type UserUpdateWithoutRecoveryCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRecoveryCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSavedSearchesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSavedSearchesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSavedSearchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
  }

  export type UserUpsertWithoutSavedSearchesInput = {
    update: XOR<UserUpdateWithoutSavedSearchesInput, UserUncheckedUpdateWithoutSavedSearchesInput>
    create: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedSearchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedSearchesInput, UserUncheckedUpdateWithoutSavedSearchesInput>
  }

  export type UserUpdateWithoutSavedSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSearchHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSearchHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSearchHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
  }

  export type UserUpsertWithoutSearchHistoryInput = {
    update: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPasswordTemplatesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPasswordTemplatesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPasswordTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
  }

  export type CompanyCreateWithoutTemplatesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTemplatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
  }

  export type UserUpsertWithoutPasswordTemplatesInput = {
    update: XOR<UserUpdateWithoutPasswordTemplatesInput, UserUncheckedUpdateWithoutPasswordTemplatesInput>
    create: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordTemplatesInput, UserUncheckedUpdateWithoutPasswordTemplatesInput>
  }

  export type UserUpdateWithoutPasswordTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutTemplatesInput = {
    update: XOR<CompanyUpdateWithoutTemplatesInput, CompanyUncheckedUpdateWithoutTemplatesInput>
    create: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTemplatesInput, CompanyUncheckedUpdateWithoutTemplatesInput>
  }

  export type CompanyUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutEmailVerificationTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutEmailVerificationTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutEmailVerificationTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
  }

  export type UserUpsertWithoutEmailVerificationTokensInput = {
    update: XOR<UserUpdateWithoutEmailVerificationTokensInput, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
    create: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailVerificationTokensInput, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
  }

  export type UserUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSecurityQuestionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSecurityQuestionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSecurityQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
  }

  export type UserUpsertWithoutSecurityQuestionsInput = {
    update: XOR<UserUpdateWithoutSecurityQuestionsInput, UserUncheckedUpdateWithoutSecurityQuestionsInput>
    create: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityQuestionsInput, UserUncheckedUpdateWithoutSecurityQuestionsInput>
  }

  export type UserUpdateWithoutSecurityQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutIpWhitelistsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutIpWhitelistsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutIpWhitelistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIpWhitelistsInput, UserUncheckedCreateWithoutIpWhitelistsInput>
  }

  export type CompanyCreateWithoutIpWhitelistsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutIpWhitelistsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutIpWhitelistsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutIpWhitelistsInput, CompanyUncheckedCreateWithoutIpWhitelistsInput>
  }

  export type UserCreateWithoutCreatedIpWhitelistsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedIpWhitelistsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedIpWhitelistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedIpWhitelistsInput, UserUncheckedCreateWithoutCreatedIpWhitelistsInput>
  }

  export type UserUpsertWithoutIpWhitelistsInput = {
    update: XOR<UserUpdateWithoutIpWhitelistsInput, UserUncheckedUpdateWithoutIpWhitelistsInput>
    create: XOR<UserCreateWithoutIpWhitelistsInput, UserUncheckedCreateWithoutIpWhitelistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIpWhitelistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIpWhitelistsInput, UserUncheckedUpdateWithoutIpWhitelistsInput>
  }

  export type UserUpdateWithoutIpWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutIpWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutIpWhitelistsInput = {
    update: XOR<CompanyUpdateWithoutIpWhitelistsInput, CompanyUncheckedUpdateWithoutIpWhitelistsInput>
    create: XOR<CompanyCreateWithoutIpWhitelistsInput, CompanyUncheckedCreateWithoutIpWhitelistsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutIpWhitelistsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutIpWhitelistsInput, CompanyUncheckedUpdateWithoutIpWhitelistsInput>
  }

  export type CompanyUpdateWithoutIpWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutIpWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCreatedIpWhitelistsInput = {
    update: XOR<UserUpdateWithoutCreatedIpWhitelistsInput, UserUncheckedUpdateWithoutCreatedIpWhitelistsInput>
    create: XOR<UserCreateWithoutCreatedIpWhitelistsInput, UserUncheckedCreateWithoutCreatedIpWhitelistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedIpWhitelistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedIpWhitelistsInput, UserUncheckedUpdateWithoutCreatedIpWhitelistsInput>
  }

  export type UserUpdateWithoutCreatedIpWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedIpWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutGeographicRestrictionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutGeographicRestrictionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutGeographicRestrictionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeographicRestrictionsInput, UserUncheckedCreateWithoutGeographicRestrictionsInput>
  }

  export type CompanyCreateWithoutGeographicRestrictionsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutGeographicRestrictionsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutGeographicRestrictionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutGeographicRestrictionsInput, CompanyUncheckedCreateWithoutGeographicRestrictionsInput>
  }

  export type UserCreateWithoutCreatedGeographicRestrictionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedGeographicRestrictionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedGeographicRestrictionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGeographicRestrictionsInput, UserUncheckedCreateWithoutCreatedGeographicRestrictionsInput>
  }

  export type UserUpsertWithoutGeographicRestrictionsInput = {
    update: XOR<UserUpdateWithoutGeographicRestrictionsInput, UserUncheckedUpdateWithoutGeographicRestrictionsInput>
    create: XOR<UserCreateWithoutGeographicRestrictionsInput, UserUncheckedCreateWithoutGeographicRestrictionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeographicRestrictionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeographicRestrictionsInput, UserUncheckedUpdateWithoutGeographicRestrictionsInput>
  }

  export type UserUpdateWithoutGeographicRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutGeographicRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutGeographicRestrictionsInput = {
    update: XOR<CompanyUpdateWithoutGeographicRestrictionsInput, CompanyUncheckedUpdateWithoutGeographicRestrictionsInput>
    create: XOR<CompanyCreateWithoutGeographicRestrictionsInput, CompanyUncheckedCreateWithoutGeographicRestrictionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutGeographicRestrictionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutGeographicRestrictionsInput, CompanyUncheckedUpdateWithoutGeographicRestrictionsInput>
  }

  export type CompanyUpdateWithoutGeographicRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutGeographicRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCreatedGeographicRestrictionsInput = {
    update: XOR<UserUpdateWithoutCreatedGeographicRestrictionsInput, UserUncheckedUpdateWithoutCreatedGeographicRestrictionsInput>
    create: XOR<UserCreateWithoutCreatedGeographicRestrictionsInput, UserUncheckedCreateWithoutCreatedGeographicRestrictionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGeographicRestrictionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGeographicRestrictionsInput, UserUncheckedUpdateWithoutCreatedGeographicRestrictionsInput>
  }

  export type UserUpdateWithoutCreatedGeographicRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGeographicRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyCreateWithoutPasswordPolicyInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPasswordPolicyInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPasswordPolicyInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPasswordPolicyInput, CompanyUncheckedCreateWithoutPasswordPolicyInput>
  }

  export type CompanyUpsertWithoutPasswordPolicyInput = {
    update: XOR<CompanyUpdateWithoutPasswordPolicyInput, CompanyUncheckedUpdateWithoutPasswordPolicyInput>
    create: XOR<CompanyCreateWithoutPasswordPolicyInput, CompanyUncheckedCreateWithoutPasswordPolicyInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPasswordPolicyInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPasswordPolicyInput, CompanyUncheckedUpdateWithoutPasswordPolicyInput>
  }

  export type CompanyUpdateWithoutPasswordPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPasswordPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutDataRetentionPolicyInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDataRetentionPolicyInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDataRetentionPolicyInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDataRetentionPolicyInput, CompanyUncheckedCreateWithoutDataRetentionPolicyInput>
  }

  export type CompanyUpsertWithoutDataRetentionPolicyInput = {
    update: XOR<CompanyUpdateWithoutDataRetentionPolicyInput, CompanyUncheckedUpdateWithoutDataRetentionPolicyInput>
    create: XOR<CompanyCreateWithoutDataRetentionPolicyInput, CompanyUncheckedCreateWithoutDataRetentionPolicyInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDataRetentionPolicyInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDataRetentionPolicyInput, CompanyUncheckedUpdateWithoutDataRetentionPolicyInput>
  }

  export type CompanyUpdateWithoutDataRetentionPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDataRetentionPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutDataExportsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDataExportsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDataExportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataExportsInput, UserUncheckedCreateWithoutDataExportsInput>
  }

  export type CompanyCreateWithoutDataExportsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDataExportsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDataExportsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDataExportsInput, CompanyUncheckedCreateWithoutDataExportsInput>
  }

  export type UserUpsertWithoutDataExportsInput = {
    update: XOR<UserUpdateWithoutDataExportsInput, UserUncheckedUpdateWithoutDataExportsInput>
    create: XOR<UserCreateWithoutDataExportsInput, UserUncheckedCreateWithoutDataExportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataExportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataExportsInput, UserUncheckedUpdateWithoutDataExportsInput>
  }

  export type UserUpdateWithoutDataExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDataExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutDataExportsInput = {
    update: XOR<CompanyUpdateWithoutDataExportsInput, CompanyUncheckedUpdateWithoutDataExportsInput>
    create: XOR<CompanyCreateWithoutDataExportsInput, CompanyUncheckedCreateWithoutDataExportsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDataExportsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDataExportsInput, CompanyUncheckedUpdateWithoutDataExportsInput>
  }

  export type CompanyUpdateWithoutDataExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDataExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutDataDeletionRequestsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDataDeletionRequestsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDataDeletionRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataDeletionRequestsInput, UserUncheckedCreateWithoutDataDeletionRequestsInput>
  }

  export type CompanyCreateWithoutDataDeletionRequestsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDataDeletionRequestsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDataDeletionRequestsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDataDeletionRequestsInput, CompanyUncheckedCreateWithoutDataDeletionRequestsInput>
  }

  export type UserCreateWithoutProcessedDeletionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutProcessedDeletionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProcessedDeletionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessedDeletionsInput, UserUncheckedCreateWithoutProcessedDeletionsInput>
  }

  export type UserUpsertWithoutDataDeletionRequestsInput = {
    update: XOR<UserUpdateWithoutDataDeletionRequestsInput, UserUncheckedUpdateWithoutDataDeletionRequestsInput>
    create: XOR<UserCreateWithoutDataDeletionRequestsInput, UserUncheckedCreateWithoutDataDeletionRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataDeletionRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataDeletionRequestsInput, UserUncheckedUpdateWithoutDataDeletionRequestsInput>
  }

  export type UserUpdateWithoutDataDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDataDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutDataDeletionRequestsInput = {
    update: XOR<CompanyUpdateWithoutDataDeletionRequestsInput, CompanyUncheckedUpdateWithoutDataDeletionRequestsInput>
    create: XOR<CompanyCreateWithoutDataDeletionRequestsInput, CompanyUncheckedCreateWithoutDataDeletionRequestsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDataDeletionRequestsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDataDeletionRequestsInput, CompanyUncheckedUpdateWithoutDataDeletionRequestsInput>
  }

  export type CompanyUpdateWithoutDataDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDataDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutProcessedDeletionsInput = {
    update: XOR<UserUpdateWithoutProcessedDeletionsInput, UserUncheckedUpdateWithoutProcessedDeletionsInput>
    create: XOR<UserCreateWithoutProcessedDeletionsInput, UserUncheckedCreateWithoutProcessedDeletionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessedDeletionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessedDeletionsInput, UserUncheckedUpdateWithoutProcessedDeletionsInput>
  }

  export type UserUpdateWithoutProcessedDeletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessedDeletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type CompanyCreateWithoutReportsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutReportsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
  }

  export type ReportTemplateCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutReportTemplatesInput
    company?: CompanyCreateNestedOneWithoutReportTemplatesInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    userId: string
    companyId?: string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutReportsInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutReportsInput = {
    update: XOR<CompanyUpdateWithoutReportsInput, CompanyUncheckedUpdateWithoutReportsInput>
    create: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutReportsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutReportsInput, CompanyUncheckedUpdateWithoutReportsInput>
  }

  export type CompanyUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ReportTemplateUpsertWithoutReportsInput = {
    update: XOR<ReportTemplateUpdateWithoutReportsInput, ReportTemplateUncheckedUpdateWithoutReportsInput>
    create: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    where?: ReportTemplateWhereInput
  }

  export type ReportTemplateUpdateToOneWithWhereWithoutReportsInput = {
    where?: ReportTemplateWhereInput
    data: XOR<ReportTemplateUpdateWithoutReportsInput, ReportTemplateUncheckedUpdateWithoutReportsInput>
  }

  export type ReportTemplateUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutReportTemplatesNestedInput
    company?: CompanyUpdateOneWithoutReportTemplatesNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type UserCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReportTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportTemplatesInput, UserUncheckedCreateWithoutReportTemplatesInput>
  }

  export type CompanyCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutReportTemplatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutReportTemplatesInput, CompanyUncheckedCreateWithoutReportTemplatesInput>
  }

  export type ReportCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutReportsInput
    company?: CompanyCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutTemplateInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput>
  }

  export type ReportCreateManyTemplateInputEnvelope = {
    data: ReportCreateManyTemplateInput | ReportCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutScheduledReportsInput
    company?: CompanyCreateNestedOneWithoutScheduledReportsInput
  }

  export type ScheduledReportUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateOrConnectWithoutTemplateInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutTemplateInput, ScheduledReportUncheckedCreateWithoutTemplateInput>
  }

  export type ScheduledReportCreateManyTemplateInputEnvelope = {
    data: ScheduledReportCreateManyTemplateInput | ScheduledReportCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReportTemplatesInput = {
    update: XOR<UserUpdateWithoutReportTemplatesInput, UserUncheckedUpdateWithoutReportTemplatesInput>
    create: XOR<UserCreateWithoutReportTemplatesInput, UserUncheckedCreateWithoutReportTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportTemplatesInput, UserUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type UserUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutReportTemplatesInput = {
    update: XOR<CompanyUpdateWithoutReportTemplatesInput, CompanyUncheckedUpdateWithoutReportTemplatesInput>
    create: XOR<CompanyCreateWithoutReportTemplatesInput, CompanyUncheckedCreateWithoutReportTemplatesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutReportTemplatesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutReportTemplatesInput, CompanyUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type CompanyUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutTemplateInput, ReportUncheckedUpdateWithoutTemplateInput>
    create: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutTemplateInput, ReportUncheckedUpdateWithoutTemplateInput>
  }

  export type ReportUpdateManyWithWhereWithoutTemplateInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutTemplateInput>
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutTemplateInput, ScheduledReportUncheckedUpdateWithoutTemplateInput>
    create: XOR<ScheduledReportCreateWithoutTemplateInput, ScheduledReportUncheckedCreateWithoutTemplateInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutTemplateInput, ScheduledReportUncheckedUpdateWithoutTemplateInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutTemplateInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutTemplateInput>
  }

  export type UserCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    reports?: ReportCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCreatedByInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedCreateNestedManyWithoutCreatorInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    reports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutUserInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutUserInput
    processedDeletions?: DataDeletionRequestUncheckedCreateNestedManyWithoutProcessorInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutArchiverInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutUserInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutUserInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutUserInput
    createdIpWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCreatorInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutScheduledReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
  }

  export type CompanyCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
    ipWhitelists?: IpWhitelistUncheckedCreateNestedManyWithoutCompanyInput
    geographicRestrictions?: GeographicRestrictionUncheckedCreateNestedManyWithoutCompanyInput
    threatEvents?: ThreatEventUncheckedCreateNestedManyWithoutCompanyInput
    rateLimits?: RateLimitUncheckedCreateNestedManyWithoutCompanyInput
    passwordPolicy?: PasswordPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedCreateNestedOneWithoutCompanyInput
    dataExports?: DataExportUncheckedCreateNestedManyWithoutCompanyInput
    dataDeletionRequests?: DataDeletionRequestUncheckedCreateNestedManyWithoutCompanyInput
    auditLogArchives?: AuditLogArchiveUncheckedCreateNestedManyWithoutCompanyInput
    auditLogSearches?: AuditLogSearchUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutScheduledReportsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutScheduledReportsInput, CompanyUncheckedCreateWithoutScheduledReportsInput>
  }

  export type ReportTemplateCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutReportTemplatesInput
    company?: CompanyCreateNestedOneWithoutReportTemplatesInput
    reports?: ReportCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    userId: string
    companyId?: string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutScheduledReportsInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutScheduledReportsInput, ReportTemplateUncheckedCreateWithoutScheduledReportsInput>
  }

  export type UserUpsertWithoutScheduledReportsInput = {
    update: XOR<UserUpdateWithoutScheduledReportsInput, UserUncheckedUpdateWithoutScheduledReportsInput>
    create: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduledReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduledReportsInput, UserUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type UserUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutScheduledReportsInput = {
    update: XOR<CompanyUpdateWithoutScheduledReportsInput, CompanyUncheckedUpdateWithoutScheduledReportsInput>
    create: XOR<CompanyCreateWithoutScheduledReportsInput, CompanyUncheckedCreateWithoutScheduledReportsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutScheduledReportsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutScheduledReportsInput, CompanyUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type CompanyUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCompanyNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCompanyNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutCompanyNestedInput
    rateLimits?: RateLimitUncheckedUpdateManyWithoutCompanyNestedInput
    passwordPolicy?: PasswordPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataRetentionPolicy?: DataRetentionPolicyUncheckedUpdateOneWithoutCompanyNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutCompanyNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ReportTemplateUpsertWithoutScheduledReportsInput = {
    update: XOR<ReportTemplateUpdateWithoutScheduledReportsInput, ReportTemplateUncheckedUpdateWithoutScheduledReportsInput>
    create: XOR<ReportTemplateCreateWithoutScheduledReportsInput, ReportTemplateUncheckedCreateWithoutScheduledReportsInput>
    where?: ReportTemplateWhereInput
  }

  export type ReportTemplateUpdateToOneWithWhereWithoutScheduledReportsInput = {
    where?: ReportTemplateWhereInput
    data: XOR<ReportTemplateUpdateWithoutScheduledReportsInput, ReportTemplateUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type ReportTemplateUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutReportTemplatesNestedInput
    company?: CompanyUpdateOneWithoutReportTemplatesNestedInput
    reports?: ReportUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
  }

  export type PasswordTemplateCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IpWhitelistCreateManyCompanyInput = {
    id?: string
    userId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type GeographicRestrictionCreateManyCompanyInput = {
    id?: string
    userId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type ThreatEventCreateManyCompanyInput = {
    id?: string
    userId?: string | null
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type RateLimitCreateManyCompanyInput = {
    id?: string
    identifier: string
    identifierType: $Enums.RateLimitType
    action: string
    count?: number
    windowStart?: Date | string
    windowEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataExportCreateManyCompanyInput = {
    id?: string
    userId: string
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestCreateManyCompanyInput = {
    id?: string
    userId: string
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    processedBy?: string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type AuditLogArchiveCreateManyCompanyInput = {
    id?: string
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    archivedBy?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type AuditLogSearchCreateManyCompanyInput = {
    id?: string
    userId: string
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type ReportCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
  }

  export type ReportTemplateCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    userId: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: string | null
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordTemplateUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutPasswordTemplatesNestedInput
  }

  export type PasswordTemplateUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpWhitelistUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutIpWhitelistsNestedInput
    creator?: UserUpdateOneWithoutCreatedIpWhitelistsNestedInput
  }

  export type IpWhitelistUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IpWhitelistUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GeographicRestrictionUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeographicRestrictionsNestedInput
    creator?: UserUpdateOneWithoutCreatedGeographicRestrictionsNestedInput
  }

  export type GeographicRestrictionUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GeographicRestrictionUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreatEventUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutThreatEventsNestedInput
  }

  export type ThreatEventUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatEventUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    identifierType?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    identifierType?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    identifierType?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    windowEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDataExportsNestedInput
  }

  export type DataExportUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataExportUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDataDeletionRequestsNestedInput
    processor?: UserUpdateOneWithoutProcessedDeletionsNestedInput
  }

  export type DataDeletionRequestUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogArchiveUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiver?: UserUpdateOneWithoutAuditLogArchivesNestedInput
  }

  export type AuditLogArchiveUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    archivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogArchiveUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    archivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogSearchUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogSearchesNestedInput
  }

  export type AuditLogSearchUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogSearchUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    template?: ReportTemplateUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportTemplateUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutReportTemplatesNestedInput
    reports?: ReportUpdateManyWithoutTemplateNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutTemplateNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutScheduledReportsNestedInput
    template?: ReportTemplateUpdateOneWithoutScheduledReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordCreateManyOwnerInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
  }

  export type PasswordShareCreateManyUserInput = {
    id?: string
    passwordId: string
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type ThreatEventCreateManyUserInput = {
    id?: string
    companyId?: string | null
    threatType: $Enums.ThreatType
    severity?: $Enums.ThreatSeverity
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    deviceFingerprint?: string | null
    isTrusted?: boolean
    requireMfa?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type MfaCredentialCreateManyUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type RecoveryCodeCreateManyUserInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateManyChangedByUserInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordBreachCreateManyCheckedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachCreateManyResolvedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
  }

  export type PasswordRotationPolicyCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordRotationCreateManyRotatedByUserInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type TemporaryPasswordShareCreateManyCreatorInput = {
    id?: string
    passwordId: string
    shareToken: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SavedSearchCreateManyUserInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SearchHistoryCreateManyUserInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type PasswordTemplateCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: string | null
  }

  export type ReportTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    category?: string | null
    config: JsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isPublic?: boolean
    companyId?: string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: string | null
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type RoleCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataExportCreateManyUserInput = {
    id?: string
    companyId?: string | null
    exportType: string
    status?: string
    filePath?: string | null
    fileSize?: number | null
    expiresAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestCreateManyUserInput = {
    id?: string
    companyId?: string | null
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    processedBy?: string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type DataDeletionRequestCreateManyProcessorInput = {
    id?: string
    userId: string
    companyId?: string | null
    requestType: string
    status?: string
    requestedAt?: Date | string
    processedAt?: Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken: string
    confirmedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type AuditLogArchiveCreateManyArchiverInput = {
    id?: string
    companyId?: string | null
    archiveDate?: Date | string
    startDate: Date | string
    endDate: Date | string
    logCount: number
    filePath?: string | null
    fileSize?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type AuditLogSearchCreateManyUserInput = {
    id?: string
    companyId?: string | null
    name?: string | null
    searchQuery: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type EmailVerificationTokenCreateManyUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SecurityQuestionCreateManyUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IpWhitelistCreateManyUserInput = {
    id?: string
    companyId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type GeographicRestrictionCreateManyUserInput = {
    id?: string
    companyId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type IpWhitelistCreateManyCreatorInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    ipAddress: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeographicRestrictionCreateManyCreatorInput = {
    id?: string
    userId?: string | null
    companyId?: string | null
    countryCode: string
    action?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordShareUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutSharedWithNestedInput
    team?: TeamUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutThreatEventsNestedInput
  }

  export type ThreatEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    threatType?: EnumThreatTypeFieldUpdateOperationsInput | $Enums.ThreatType
    severity?: EnumThreatSeverityFieldUpdateOperationsInput | $Enums.ThreatSeverity
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    requireMfa?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    requireMfa?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    requireMfa?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MfaCredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecoveryCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUpdateWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordEntry?: PasswordUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type PasswordHistoryUncheckedUpdateWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordBreachUpdateWithoutCheckedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutBreachesNestedInput
    resolvedByUser?: UserUpdateOneWithoutPasswordBreachesResolvedNestedInput
  }

  export type PasswordBreachUncheckedUpdateWithoutCheckedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachUncheckedUpdateManyWithoutCheckedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachUpdateWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutBreachesNestedInput
    checkedByUser?: UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput
  }

  export type PasswordBreachUncheckedUpdateWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordBreachUncheckedUpdateManyWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordRotationPolicyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationUpdateWithoutRotatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    password?: PasswordUpdateOneRequiredWithoutRotationsNestedInput
    policy?: PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateWithoutRotatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyWithoutRotatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemporaryPasswordShareUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: PasswordUpdateOneRequiredWithoutTemporarySharesNestedInput
  }

  export type TemporaryPasswordShareUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedSearchUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutTemplatesNestedInput
  }

  export type PasswordTemplateUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutReportsNestedInput
    template?: ReportTemplateUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutReportTemplatesNestedInput
    reports?: ReportUpdateManyWithoutTemplateNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutTemplateNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    config?: JsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutScheduledReportsNestedInput
    template?: ReportTemplateUpdateOneWithoutScheduledReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    reports?: ReportUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    threatEvents?: ThreatEventUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    temporaryPasswordShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutCreatorNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    dataExports?: DataExportUncheckedUpdateManyWithoutUserNestedInput
    dataDeletionRequests?: DataDeletionRequestUncheckedUpdateManyWithoutUserNestedInput
    processedDeletions?: DataDeletionRequestUncheckedUpdateManyWithoutProcessorNestedInput
    auditLogArchives?: AuditLogArchiveUncheckedUpdateManyWithoutArchiverNestedInput
    auditLogSearches?: AuditLogSearchUncheckedUpdateManyWithoutUserNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
    ipWhitelists?: IpWhitelistUncheckedUpdateManyWithoutUserNestedInput
    geographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutUserNestedInput
    createdIpWhitelists?: IpWhitelistUncheckedUpdateManyWithoutCreatorNestedInput
    createdGeographicRestrictions?: GeographicRestrictionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutDataExportsNestedInput
  }

  export type DataExportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataExportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    exportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutDataDeletionRequestsNestedInput
    processor?: UserUpdateOneWithoutProcessedDeletionsNestedInput
  }

  export type DataDeletionRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDataDeletionRequestsNestedInput
    company?: CompanyUpdateOneWithoutDataDeletionRequestsNestedInput
  }

  export type DataDeletionRequestUncheckedUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataDeletionRequestUncheckedUpdateManyWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletionScope?: NullableJsonNullValueInput | InputJsonValue
    confirmationToken?: StringFieldUpdateOperationsInput | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogArchiveUpdateWithoutArchiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutAuditLogArchivesNestedInput
  }

  export type AuditLogArchiveUncheckedUpdateWithoutArchiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogArchiveUncheckedUpdateManyWithoutArchiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    archiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logCount?: IntFieldUpdateOperationsInput | number
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogSearchUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutAuditLogSearchesNestedInput
  }

  export type AuditLogSearchUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogSearchUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    searchQuery?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpWhitelistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutIpWhitelistsNestedInput
    creator?: UserUpdateOneWithoutCreatedIpWhitelistsNestedInput
  }

  export type IpWhitelistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IpWhitelistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GeographicRestrictionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutGeographicRestrictionsNestedInput
    creator?: UserUpdateOneWithoutCreatedGeographicRestrictionsNestedInput
  }

  export type GeographicRestrictionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GeographicRestrictionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IpWhitelistUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutIpWhitelistsNestedInput
    company?: CompanyUpdateOneWithoutIpWhitelistsNestedInput
  }

  export type IpWhitelistUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IpWhitelistUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeographicRestrictionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeographicRestrictionsNestedInput
    company?: CompanyUpdateOneWithoutGeographicRestrictionsNestedInput
  }

  export type GeographicRestrictionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeographicRestrictionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordShareCreateManyPasswordInput = {
    id?: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type TemporaryPasswordShareCreateManyPasswordInput = {
    id?: string
    shareToken: string
    createdBy: string
    accessCount?: number
    maxAccesses?: number | null
    isOneTime?: boolean
    includeTotp?: boolean
    expiresAt?: Date | string | null
    accessedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordTagCreateManyPasswordInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateManyPasswordEntryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordBreachCreateManyPasswordInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordRotationCreateManyPasswordInput = {
    id?: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordShareUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutSharedPasswordsNestedInput
    team?: TeamUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemporaryPasswordShareUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTemporaryPasswordSharesNestedInput
  }

  export type TemporaryPasswordShareUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    accessCount?: IntFieldUpdateOperationsInput | number
    maxAccesses?: NullableIntFieldUpdateOperationsInput | number | null
    isOneTime?: BoolFieldUpdateOperationsInput | boolean
    includeTotp?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutPasswordsNestedInput
  }

  export type PasswordTagUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUpdateWithoutPasswordEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUser?: UserUpdateOneRequiredWithoutPasswordHistoryNestedInput
  }

  export type PasswordHistoryUncheckedUpdateWithoutPasswordEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordBreachUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkedByUser?: UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput
    resolvedByUser?: UserUpdateOneWithoutPasswordBreachesResolvedNestedInput
  }

  export type PasswordBreachUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    policy?: PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput
    rotatedByUser?: UserUpdateOneRequiredWithoutPasswordRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordCreateManyRotationPolicyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordRotationCreateManyPolicyInput = {
    id?: string
    passwordId: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordUpdateWithoutRotationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateWithoutRotationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateManyWithoutRotationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    password?: PasswordUpdateOneRequiredWithoutRotationsNestedInput
    rotatedByUser?: UserUpdateOneRequiredWithoutPasswordRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FolderCreateManyParentInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordCreateManyFolderInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
  }

  export type FolderUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUpdateManyWithoutParentNestedInput
    passwords?: PasswordUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    passwords?: PasswordUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    temporaryShares?: TemporaryPasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type PasswordShareCreateManyTeamInput = {
    id?: string
    passwordId: string
    userId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordShareUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutSharedWithNestedInput
    user?: UserUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordTagCreateManyTagInput = {
    id?: string
    passwordId: string
    createdAt?: Date | string
  }

  export type PasswordTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: PasswordUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PasswordTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    status?: string
    filePath?: string | null
    fileSize?: number | null
    generatedAt?: Date | string | null
    expiresAt?: Date | string | null
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: string
    format?: string
    config: JsonNullValueInput | InputJsonValue
    schedule: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    runCount?: number
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutReportsNestedInput
    company?: CompanyUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutScheduledReportsNestedInput
    company?: CompanyUpdateOneWithoutScheduledReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    schedule?: JsonNullValueInput | InputJsonValue
    recipients?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}