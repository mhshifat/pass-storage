
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Password
 * 
 */
export type Password = $Result.DefaultSelection<Prisma.$PasswordPayload>
/**
 * Model PasswordHistory
 * 
 */
export type PasswordHistory = $Result.DefaultSelection<Prisma.$PasswordHistoryPayload>
/**
 * Model PasswordBreach
 * 
 */
export type PasswordBreach = $Result.DefaultSelection<Prisma.$PasswordBreachPayload>
/**
 * Model PasswordRotationPolicy
 * 
 */
export type PasswordRotationPolicy = $Result.DefaultSelection<Prisma.$PasswordRotationPolicyPayload>
/**
 * Model PasswordRotation
 * 
 */
export type PasswordRotation = $Result.DefaultSelection<Prisma.$PasswordRotationPayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model PasswordShare
 * 
 */
export type PasswordShare = $Result.DefaultSelection<Prisma.$PasswordSharePayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model PasswordTag
 * 
 */
export type PasswordTag = $Result.DefaultSelection<Prisma.$PasswordTagPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model MfaCredential
 * 
 */
export type MfaCredential = $Result.DefaultSelection<Prisma.$MfaCredentialPayload>
/**
 * Model RecoveryCode
 * 
 */
export type RecoveryCode = $Result.DefaultSelection<Prisma.$RecoveryCodePayload>
/**
 * Model SavedSearch
 * 
 */
export type SavedSearch = $Result.DefaultSelection<Prisma.$SavedSearchPayload>
/**
 * Model SearchHistory
 * 
 */
export type SearchHistory = $Result.DefaultSelection<Prisma.$SearchHistoryPayload>
/**
 * Model PasswordTemplate
 * 
 */
export type PasswordTemplate = $Result.DefaultSelection<Prisma.$PasswordTemplatePayload>
/**
 * Model EmailVerificationToken
 * 
 */
export type EmailVerificationToken = $Result.DefaultSelection<Prisma.$EmailVerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model SecurityQuestion
 * 
 */
export type SecurityQuestion = $Result.DefaultSelection<Prisma.$SecurityQuestionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  USER: 'USER',
  AUDITOR: 'AUDITOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TeamRole: {
  MANAGER: 'MANAGER',
  MEMBER: 'MEMBER'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const SharePermission: {
  READ: 'READ',
  WRITE: 'WRITE',
  ADMIN: 'ADMIN'
};

export type SharePermission = (typeof SharePermission)[keyof typeof SharePermission]


export const PasswordStrength: {
  WEAK: 'WEAK',
  MEDIUM: 'MEDIUM',
  STRONG: 'STRONG'
};

export type PasswordStrength = (typeof PasswordStrength)[keyof typeof PasswordStrength]


export const AuditStatus: {
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  WARNING: 'WARNING',
  BLOCKED: 'BLOCKED'
};

export type AuditStatus = (typeof AuditStatus)[keyof typeof AuditStatus]


export const MfaMethod: {
  TOTP: 'TOTP',
  SMS: 'SMS',
  EMAIL: 'EMAIL',
  WEBAUTHN: 'WEBAUTHN'
};

export type MfaMethod = (typeof MfaMethod)[keyof typeof MfaMethod]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type SharePermission = $Enums.SharePermission

export const SharePermission: typeof $Enums.SharePermission

export type PasswordStrength = $Enums.PasswordStrength

export const PasswordStrength: typeof $Enums.PasswordStrength

export type AuditStatus = $Enums.AuditStatus

export const AuditStatus: typeof $Enums.AuditStatus

export type MfaMethod = $Enums.MfaMethod

export const MfaMethod: typeof $Enums.MfaMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password`: Exposes CRUD operations for the **Password** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passwords
    * const passwords = await prisma.password.findMany()
    * ```
    */
  get password(): Prisma.PasswordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordHistory`: Exposes CRUD operations for the **PasswordHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordHistories
    * const passwordHistories = await prisma.passwordHistory.findMany()
    * ```
    */
  get passwordHistory(): Prisma.PasswordHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordBreach`: Exposes CRUD operations for the **PasswordBreach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordBreaches
    * const passwordBreaches = await prisma.passwordBreach.findMany()
    * ```
    */
  get passwordBreach(): Prisma.PasswordBreachDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordRotationPolicy`: Exposes CRUD operations for the **PasswordRotationPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordRotationPolicies
    * const passwordRotationPolicies = await prisma.passwordRotationPolicy.findMany()
    * ```
    */
  get passwordRotationPolicy(): Prisma.PasswordRotationPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordRotation`: Exposes CRUD operations for the **PasswordRotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordRotations
    * const passwordRotations = await prisma.passwordRotation.findMany()
    * ```
    */
  get passwordRotation(): Prisma.PasswordRotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordShare`: Exposes CRUD operations for the **PasswordShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordShares
    * const passwordShares = await prisma.passwordShare.findMany()
    * ```
    */
  get passwordShare(): Prisma.PasswordShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordTag`: Exposes CRUD operations for the **PasswordTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordTags
    * const passwordTags = await prisma.passwordTag.findMany()
    * ```
    */
  get passwordTag(): Prisma.PasswordTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mfaCredential`: Exposes CRUD operations for the **MfaCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MfaCredentials
    * const mfaCredentials = await prisma.mfaCredential.findMany()
    * ```
    */
  get mfaCredential(): Prisma.MfaCredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recoveryCode`: Exposes CRUD operations for the **RecoveryCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryCodes
    * const recoveryCodes = await prisma.recoveryCode.findMany()
    * ```
    */
  get recoveryCode(): Prisma.RecoveryCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedSearch`: Exposes CRUD operations for the **SavedSearch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedSearches
    * const savedSearches = await prisma.savedSearch.findMany()
    * ```
    */
  get savedSearch(): Prisma.SavedSearchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchHistory`: Exposes CRUD operations for the **SearchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchHistories
    * const searchHistories = await prisma.searchHistory.findMany()
    * ```
    */
  get searchHistory(): Prisma.SearchHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordTemplate`: Exposes CRUD operations for the **PasswordTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordTemplates
    * const passwordTemplates = await prisma.passwordTemplate.findMany()
    * ```
    */
  get passwordTemplate(): Prisma.PasswordTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerificationToken`: Exposes CRUD operations for the **EmailVerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerificationTokens
    * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
    * ```
    */
  get emailVerificationToken(): Prisma.EmailVerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityQuestion`: Exposes CRUD operations for the **SecurityQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityQuestions
    * const securityQuestions = await prisma.securityQuestion.findMany()
    * ```
    */
  get securityQuestion(): Prisma.SecurityQuestionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.1
   * Query Engine version: f09f2815f091dbba658cdcd2264306d88bb5bda6
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Password: 'Password',
    PasswordHistory: 'PasswordHistory',
    PasswordBreach: 'PasswordBreach',
    PasswordRotationPolicy: 'PasswordRotationPolicy',
    PasswordRotation: 'PasswordRotation',
    Folder: 'Folder',
    PasswordShare: 'PasswordShare',
    Team: 'Team',
    TeamMember: 'TeamMember',
    Tag: 'Tag',
    PasswordTag: 'PasswordTag',
    AuditLog: 'AuditLog',
    Settings: 'Settings',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    MfaCredential: 'MfaCredential',
    RecoveryCode: 'RecoveryCode',
    SavedSearch: 'SavedSearch',
    SearchHistory: 'SearchHistory',
    PasswordTemplate: 'PasswordTemplate',
    EmailVerificationToken: 'EmailVerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    SecurityQuestion: 'SecurityQuestion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "user" | "account" | "session" | "password" | "passwordHistory" | "passwordBreach" | "passwordRotationPolicy" | "passwordRotation" | "folder" | "passwordShare" | "team" | "teamMember" | "tag" | "passwordTag" | "auditLog" | "settings" | "role" | "permission" | "rolePermission" | "mfaCredential" | "recoveryCode" | "savedSearch" | "searchHistory" | "passwordTemplate" | "emailVerificationToken" | "passwordResetToken" | "securityQuestion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Password: {
        payload: Prisma.$PasswordPayload<ExtArgs>
        fields: Prisma.PasswordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          findFirst: {
            args: Prisma.PasswordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          findMany: {
            args: Prisma.PasswordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          create: {
            args: Prisma.PasswordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          createMany: {
            args: Prisma.PasswordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          delete: {
            args: Prisma.PasswordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          update: {
            args: Prisma.PasswordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          deleteMany: {
            args: Prisma.PasswordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>[]
          }
          upsert: {
            args: Prisma.PasswordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordPayload>
          }
          aggregate: {
            args: Prisma.PasswordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword>
          }
          groupBy: {
            args: Prisma.PasswordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordCountAggregateOutputType> | number
          }
        }
      }
      PasswordHistory: {
        payload: Prisma.$PasswordHistoryPayload<ExtArgs>
        fields: Prisma.PasswordHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          findFirst: {
            args: Prisma.PasswordHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          findMany: {
            args: Prisma.PasswordHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          create: {
            args: Prisma.PasswordHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          createMany: {
            args: Prisma.PasswordHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          delete: {
            args: Prisma.PasswordHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          update: {
            args: Prisma.PasswordHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PasswordHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PasswordHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          aggregate: {
            args: Prisma.PasswordHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordHistory>
          }
          groupBy: {
            args: Prisma.PasswordHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistoryCountAggregateOutputType> | number
          }
        }
      }
      PasswordBreach: {
        payload: Prisma.$PasswordBreachPayload<ExtArgs>
        fields: Prisma.PasswordBreachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordBreachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordBreachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          findFirst: {
            args: Prisma.PasswordBreachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordBreachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          findMany: {
            args: Prisma.PasswordBreachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>[]
          }
          create: {
            args: Prisma.PasswordBreachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          createMany: {
            args: Prisma.PasswordBreachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordBreachCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>[]
          }
          delete: {
            args: Prisma.PasswordBreachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          update: {
            args: Prisma.PasswordBreachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          deleteMany: {
            args: Prisma.PasswordBreachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordBreachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordBreachUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>[]
          }
          upsert: {
            args: Prisma.PasswordBreachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordBreachPayload>
          }
          aggregate: {
            args: Prisma.PasswordBreachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordBreach>
          }
          groupBy: {
            args: Prisma.PasswordBreachGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordBreachGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordBreachCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordBreachCountAggregateOutputType> | number
          }
        }
      }
      PasswordRotationPolicy: {
        payload: Prisma.$PasswordRotationPolicyPayload<ExtArgs>
        fields: Prisma.PasswordRotationPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordRotationPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordRotationPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          findFirst: {
            args: Prisma.PasswordRotationPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordRotationPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          findMany: {
            args: Prisma.PasswordRotationPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>[]
          }
          create: {
            args: Prisma.PasswordRotationPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          createMany: {
            args: Prisma.PasswordRotationPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordRotationPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>[]
          }
          delete: {
            args: Prisma.PasswordRotationPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          update: {
            args: Prisma.PasswordRotationPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PasswordRotationPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordRotationPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordRotationPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>[]
          }
          upsert: {
            args: Prisma.PasswordRotationPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPolicyPayload>
          }
          aggregate: {
            args: Prisma.PasswordRotationPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordRotationPolicy>
          }
          groupBy: {
            args: Prisma.PasswordRotationPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordRotationPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationPolicyCountAggregateOutputType> | number
          }
        }
      }
      PasswordRotation: {
        payload: Prisma.$PasswordRotationPayload<ExtArgs>
        fields: Prisma.PasswordRotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordRotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordRotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          findFirst: {
            args: Prisma.PasswordRotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordRotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          findMany: {
            args: Prisma.PasswordRotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>[]
          }
          create: {
            args: Prisma.PasswordRotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          createMany: {
            args: Prisma.PasswordRotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordRotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>[]
          }
          delete: {
            args: Prisma.PasswordRotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          update: {
            args: Prisma.PasswordRotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          deleteMany: {
            args: Prisma.PasswordRotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordRotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordRotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>[]
          }
          upsert: {
            args: Prisma.PasswordRotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordRotationPayload>
          }
          aggregate: {
            args: Prisma.PasswordRotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordRotation>
          }
          groupBy: {
            args: Prisma.PasswordRotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordRotationCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordRotationCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      PasswordShare: {
        payload: Prisma.$PasswordSharePayload<ExtArgs>
        fields: Prisma.PasswordShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          findFirst: {
            args: Prisma.PasswordShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          findMany: {
            args: Prisma.PasswordShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>[]
          }
          create: {
            args: Prisma.PasswordShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          createMany: {
            args: Prisma.PasswordShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>[]
          }
          delete: {
            args: Prisma.PasswordShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          update: {
            args: Prisma.PasswordShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          deleteMany: {
            args: Prisma.PasswordShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>[]
          }
          upsert: {
            args: Prisma.PasswordShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordSharePayload>
          }
          aggregate: {
            args: Prisma.PasswordShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordShare>
          }
          groupBy: {
            args: Prisma.PasswordShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordShareCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordShareCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      PasswordTag: {
        payload: Prisma.$PasswordTagPayload<ExtArgs>
        fields: Prisma.PasswordTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          findFirst: {
            args: Prisma.PasswordTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          findMany: {
            args: Prisma.PasswordTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>[]
          }
          create: {
            args: Prisma.PasswordTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          createMany: {
            args: Prisma.PasswordTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>[]
          }
          delete: {
            args: Prisma.PasswordTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          update: {
            args: Prisma.PasswordTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          deleteMany: {
            args: Prisma.PasswordTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>[]
          }
          upsert: {
            args: Prisma.PasswordTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTagPayload>
          }
          aggregate: {
            args: Prisma.PasswordTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordTag>
          }
          groupBy: {
            args: Prisma.PasswordTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordTagCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordTagCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      MfaCredential: {
        payload: Prisma.$MfaCredentialPayload<ExtArgs>
        fields: Prisma.MfaCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MfaCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MfaCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          findFirst: {
            args: Prisma.MfaCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MfaCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          findMany: {
            args: Prisma.MfaCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>[]
          }
          create: {
            args: Prisma.MfaCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          createMany: {
            args: Prisma.MfaCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MfaCredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>[]
          }
          delete: {
            args: Prisma.MfaCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          update: {
            args: Prisma.MfaCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          deleteMany: {
            args: Prisma.MfaCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MfaCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MfaCredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>[]
          }
          upsert: {
            args: Prisma.MfaCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaCredentialPayload>
          }
          aggregate: {
            args: Prisma.MfaCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMfaCredential>
          }
          groupBy: {
            args: Prisma.MfaCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MfaCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MfaCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<MfaCredentialCountAggregateOutputType> | number
          }
        }
      }
      RecoveryCode: {
        payload: Prisma.$RecoveryCodePayload<ExtArgs>
        fields: Prisma.RecoveryCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          findFirst: {
            args: Prisma.RecoveryCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          findMany: {
            args: Prisma.RecoveryCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>[]
          }
          create: {
            args: Prisma.RecoveryCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          createMany: {
            args: Prisma.RecoveryCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecoveryCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>[]
          }
          delete: {
            args: Prisma.RecoveryCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          update: {
            args: Prisma.RecoveryCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          deleteMany: {
            args: Prisma.RecoveryCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecoveryCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>[]
          }
          upsert: {
            args: Prisma.RecoveryCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryCodePayload>
          }
          aggregate: {
            args: Prisma.RecoveryCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryCode>
          }
          groupBy: {
            args: Prisma.RecoveryCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryCodeCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryCodeCountAggregateOutputType> | number
          }
        }
      }
      SavedSearch: {
        payload: Prisma.$SavedSearchPayload<ExtArgs>
        fields: Prisma.SavedSearchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedSearchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedSearchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          findFirst: {
            args: Prisma.SavedSearchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedSearchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          findMany: {
            args: Prisma.SavedSearchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          create: {
            args: Prisma.SavedSearchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          createMany: {
            args: Prisma.SavedSearchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedSearchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          delete: {
            args: Prisma.SavedSearchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          update: {
            args: Prisma.SavedSearchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          deleteMany: {
            args: Prisma.SavedSearchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedSearchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedSearchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>[]
          }
          upsert: {
            args: Prisma.SavedSearchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedSearchPayload>
          }
          aggregate: {
            args: Prisma.SavedSearchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedSearch>
          }
          groupBy: {
            args: Prisma.SavedSearchGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedSearchGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedSearchCountArgs<ExtArgs>
            result: $Utils.Optional<SavedSearchCountAggregateOutputType> | number
          }
        }
      }
      SearchHistory: {
        payload: Prisma.$SearchHistoryPayload<ExtArgs>
        fields: Prisma.SearchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findFirst: {
            args: Prisma.SearchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findMany: {
            args: Prisma.SearchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          create: {
            args: Prisma.SearchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          createMany: {
            args: Prisma.SearchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          delete: {
            args: Prisma.SearchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          update: {
            args: Prisma.SearchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SearchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SearchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          aggregate: {
            args: Prisma.SearchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchHistory>
          }
          groupBy: {
            args: Prisma.SearchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryCountAggregateOutputType> | number
          }
        }
      }
      PasswordTemplate: {
        payload: Prisma.$PasswordTemplatePayload<ExtArgs>
        fields: Prisma.PasswordTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          findFirst: {
            args: Prisma.PasswordTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          findMany: {
            args: Prisma.PasswordTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>[]
          }
          create: {
            args: Prisma.PasswordTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          createMany: {
            args: Prisma.PasswordTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>[]
          }
          delete: {
            args: Prisma.PasswordTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          update: {
            args: Prisma.PasswordTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          deleteMany: {
            args: Prisma.PasswordTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>[]
          }
          upsert: {
            args: Prisma.PasswordTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordTemplatePayload>
          }
          aggregate: {
            args: Prisma.PasswordTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordTemplate>
          }
          groupBy: {
            args: Prisma.PasswordTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailVerificationToken: {
        payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>
        fields: Prisma.EmailVerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          update: {
            args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerificationToken>
          }
          groupBy: {
            args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      SecurityQuestion: {
        payload: Prisma.$SecurityQuestionPayload<ExtArgs>
        fields: Prisma.SecurityQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          findFirst: {
            args: Prisma.SecurityQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          findMany: {
            args: Prisma.SecurityQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>[]
          }
          create: {
            args: Prisma.SecurityQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          createMany: {
            args: Prisma.SecurityQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>[]
          }
          delete: {
            args: Prisma.SecurityQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          update: {
            args: Prisma.SecurityQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          deleteMany: {
            args: Prisma.SecurityQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>[]
          }
          upsert: {
            args: Prisma.SecurityQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityQuestionPayload>
          }
          aggregate: {
            args: Prisma.SecurityQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityQuestion>
          }
          groupBy: {
            args: Prisma.SecurityQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityQuestionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    password?: PasswordOmit
    passwordHistory?: PasswordHistoryOmit
    passwordBreach?: PasswordBreachOmit
    passwordRotationPolicy?: PasswordRotationPolicyOmit
    passwordRotation?: PasswordRotationOmit
    folder?: FolderOmit
    passwordShare?: PasswordShareOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    tag?: TagOmit
    passwordTag?: PasswordTagOmit
    auditLog?: AuditLogOmit
    settings?: SettingsOmit
    role?: RoleOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    mfaCredential?: MfaCredentialOmit
    recoveryCode?: RecoveryCodeOmit
    savedSearch?: SavedSearchOmit
    searchHistory?: SearchHistoryOmit
    passwordTemplate?: PasswordTemplateOmit
    emailVerificationToken?: EmailVerificationTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    securityQuestion?: SecurityQuestionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    templates: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    templates?: boolean | CompanyCountOutputTypeCountTemplatesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTemplateWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedPasswords: number
    sharedPasswords: number
    teamMemberships: number
    auditLogs: number
    sessions: number
    accounts: number
    mfaCredentials: number
    recoveryCodes: number
    passwordHistory: number
    passwordBreachesChecked: number
    passwordBreachesResolved: number
    rotationPolicies: number
    passwordRotations: number
    savedSearches: number
    searchHistory: number
    passwordTemplates: number
    createdUsers: number
    createdRoles: number
    emailVerificationTokens: number
    passwordResetTokens: number
    securityQuestions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPasswords?: boolean | UserCountOutputTypeCountOwnedPasswordsArgs
    sharedPasswords?: boolean | UserCountOutputTypeCountSharedPasswordsArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    mfaCredentials?: boolean | UserCountOutputTypeCountMfaCredentialsArgs
    recoveryCodes?: boolean | UserCountOutputTypeCountRecoveryCodesArgs
    passwordHistory?: boolean | UserCountOutputTypeCountPasswordHistoryArgs
    passwordBreachesChecked?: boolean | UserCountOutputTypeCountPasswordBreachesCheckedArgs
    passwordBreachesResolved?: boolean | UserCountOutputTypeCountPasswordBreachesResolvedArgs
    rotationPolicies?: boolean | UserCountOutputTypeCountRotationPoliciesArgs
    passwordRotations?: boolean | UserCountOutputTypeCountPasswordRotationsArgs
    savedSearches?: boolean | UserCountOutputTypeCountSavedSearchesArgs
    searchHistory?: boolean | UserCountOutputTypeCountSearchHistoryArgs
    passwordTemplates?: boolean | UserCountOutputTypeCountPasswordTemplatesArgs
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    createdRoles?: boolean | UserCountOutputTypeCountCreatedRolesArgs
    emailVerificationTokens?: boolean | UserCountOutputTypeCountEmailVerificationTokensArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    securityQuestions?: boolean | UserCountOutputTypeCountSecurityQuestionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMfaCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MfaCredentialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecoveryCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordBreachesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordBreachesResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRotationPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationPolicyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedSearchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSecurityQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityQuestionWhereInput
  }


  /**
   * Count Type PasswordCountOutputType
   */

  export type PasswordCountOutputType = {
    sharedWith: number
    tags: number
    history: number
    breaches: number
    rotations: number
  }

  export type PasswordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedWith?: boolean | PasswordCountOutputTypeCountSharedWithArgs
    tags?: boolean | PasswordCountOutputTypeCountTagsArgs
    history?: boolean | PasswordCountOutputTypeCountHistoryArgs
    breaches?: boolean | PasswordCountOutputTypeCountBreachesArgs
    rotations?: boolean | PasswordCountOutputTypeCountRotationsArgs
  }

  // Custom InputTypes
  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordCountOutputType
     */
    select?: PasswordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountSharedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTagWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountBreachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
  }

  /**
   * PasswordCountOutputType without action
   */
  export type PasswordCountOutputTypeCountRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
  }


  /**
   * Count Type PasswordRotationPolicyCountOutputType
   */

  export type PasswordRotationPolicyCountOutputType = {
    passwords: number
    rotations: number
  }

  export type PasswordRotationPolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwords?: boolean | PasswordRotationPolicyCountOutputTypeCountPasswordsArgs
    rotations?: boolean | PasswordRotationPolicyCountOutputTypeCountRotationsArgs
  }

  // Custom InputTypes
  /**
   * PasswordRotationPolicyCountOutputType without action
   */
  export type PasswordRotationPolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicyCountOutputType
     */
    select?: PasswordRotationPolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PasswordRotationPolicyCountOutputType without action
   */
  export type PasswordRotationPolicyCountOutputTypeCountPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
  }

  /**
   * PasswordRotationPolicyCountOutputType without action
   */
  export type PasswordRotationPolicyCountOutputTypeCountRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    children: number
    passwords: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FolderCountOutputTypeCountChildrenArgs
    passwords?: boolean | FolderCountOutputTypeCountPasswordsArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    sharedPasswords: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    sharedPasswords?: boolean | TeamCountOutputTypeCountSharedPasswordsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    passwords: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwords?: boolean | TagCountOutputTypeCountPasswordsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTagWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    subdomain: string
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    templates?: boolean | Company$templatesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subdomain" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    templates?: boolean | Company$templatesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      templates: Prisma.$PasswordTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subdomain: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templates<T extends Company$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly subdomain: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.templates
   */
  export type Company$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    where?: PasswordTemplateWhereInput
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    cursor?: PasswordTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    recoveryEmail: string | null
    recoveryEmailVerified: Date | null
    image: string | null
    password: string | null
    phoneNumber: string | null
    bio: string | null
    role: string | null
    isActive: boolean | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaMethod: $Enums.MfaMethod | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    createdById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    recoveryEmail: string | null
    recoveryEmailVerified: Date | null
    image: string | null
    password: string | null
    phoneNumber: string | null
    bio: string | null
    role: string | null
    isActive: boolean | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    mfaMethod: $Enums.MfaMethod | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    createdById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    recoveryEmail: number
    recoveryEmailVerified: number
    image: number
    password: number
    phoneNumber: number
    bio: number
    preferences: number
    role: number
    isActive: number
    mfaEnabled: number
    mfaSecret: number
    mfaMethod: number
    companyId: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    createdById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    recoveryEmail?: true
    recoveryEmailVerified?: true
    image?: true
    password?: true
    phoneNumber?: true
    bio?: true
    role?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaMethod?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    createdById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    recoveryEmail?: true
    recoveryEmailVerified?: true
    image?: true
    password?: true
    phoneNumber?: true
    bio?: true
    role?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaMethod?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    createdById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    recoveryEmail?: true
    recoveryEmailVerified?: true
    image?: true
    password?: true
    phoneNumber?: true
    bio?: true
    preferences?: true
    role?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaMethod?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    createdById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: Date | null
    recoveryEmail: string | null
    recoveryEmailVerified: Date | null
    image: string | null
    password: string | null
    phoneNumber: string | null
    bio: string | null
    preferences: JsonValue | null
    role: string
    isActive: boolean
    mfaEnabled: boolean
    mfaSecret: string | null
    mfaMethod: $Enums.MfaMethod | null
    companyId: string | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    createdById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    ownedPasswords?: boolean | User$ownedPasswordsArgs<ExtArgs>
    sharedPasswords?: boolean | User$sharedPasswordsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    mfaCredentials?: boolean | User$mfaCredentialsArgs<ExtArgs>
    recoveryCodes?: boolean | User$recoveryCodesArgs<ExtArgs>
    passwordHistory?: boolean | User$passwordHistoryArgs<ExtArgs>
    passwordBreachesChecked?: boolean | User$passwordBreachesCheckedArgs<ExtArgs>
    passwordBreachesResolved?: boolean | User$passwordBreachesResolvedArgs<ExtArgs>
    rotationPolicies?: boolean | User$rotationPoliciesArgs<ExtArgs>
    passwordRotations?: boolean | User$passwordRotationsArgs<ExtArgs>
    savedSearches?: boolean | User$savedSearchesArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    passwordTemplates?: boolean | User$passwordTemplatesArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    createdRoles?: boolean | User$createdRolesArgs<ExtArgs>
    emailVerificationTokens?: boolean | User$emailVerificationTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    securityQuestions?: boolean | User$securityQuestionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    recoveryEmail?: boolean
    recoveryEmailVerified?: boolean
    image?: boolean
    password?: boolean
    phoneNumber?: boolean
    bio?: boolean
    preferences?: boolean
    role?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaMethod?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    createdById?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "recoveryEmail" | "recoveryEmailVerified" | "image" | "password" | "phoneNumber" | "bio" | "preferences" | "role" | "isActive" | "mfaEnabled" | "mfaSecret" | "mfaMethod" | "companyId" | "createdAt" | "updatedAt" | "lastLoginAt" | "createdById", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    ownedPasswords?: boolean | User$ownedPasswordsArgs<ExtArgs>
    sharedPasswords?: boolean | User$sharedPasswordsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    mfaCredentials?: boolean | User$mfaCredentialsArgs<ExtArgs>
    recoveryCodes?: boolean | User$recoveryCodesArgs<ExtArgs>
    passwordHistory?: boolean | User$passwordHistoryArgs<ExtArgs>
    passwordBreachesChecked?: boolean | User$passwordBreachesCheckedArgs<ExtArgs>
    passwordBreachesResolved?: boolean | User$passwordBreachesResolvedArgs<ExtArgs>
    rotationPolicies?: boolean | User$rotationPoliciesArgs<ExtArgs>
    passwordRotations?: boolean | User$passwordRotationsArgs<ExtArgs>
    savedSearches?: boolean | User$savedSearchesArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    passwordTemplates?: boolean | User$passwordTemplatesArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    createdRoles?: boolean | User$createdRolesArgs<ExtArgs>
    emailVerificationTokens?: boolean | User$emailVerificationTokensArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    securityQuestions?: boolean | User$securityQuestionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      ownedPasswords: Prisma.$PasswordPayload<ExtArgs>[]
      sharedPasswords: Prisma.$PasswordSharePayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      mfaCredentials: Prisma.$MfaCredentialPayload<ExtArgs>[]
      recoveryCodes: Prisma.$RecoveryCodePayload<ExtArgs>[]
      passwordHistory: Prisma.$PasswordHistoryPayload<ExtArgs>[]
      passwordBreachesChecked: Prisma.$PasswordBreachPayload<ExtArgs>[]
      passwordBreachesResolved: Prisma.$PasswordBreachPayload<ExtArgs>[]
      rotationPolicies: Prisma.$PasswordRotationPolicyPayload<ExtArgs>[]
      passwordRotations: Prisma.$PasswordRotationPayload<ExtArgs>[]
      savedSearches: Prisma.$SavedSearchPayload<ExtArgs>[]
      searchHistory: Prisma.$SearchHistoryPayload<ExtArgs>[]
      passwordTemplates: Prisma.$PasswordTemplatePayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      createdRoles: Prisma.$RolePayload<ExtArgs>[]
      emailVerificationTokens: Prisma.$EmailVerificationTokenPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      securityQuestions: Prisma.$SecurityQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: Date | null
      recoveryEmail: string | null
      recoveryEmailVerified: Date | null
      image: string | null
      password: string | null
      phoneNumber: string | null
      bio: string | null
      preferences: Prisma.JsonValue | null
      role: string
      isActive: boolean
      mfaEnabled: boolean
      mfaSecret: string | null
      mfaMethod: $Enums.MfaMethod | null
      companyId: string | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      createdById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedPasswords<T extends User$ownedPasswordsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedPasswordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedPasswords<T extends User$sharedPasswordsArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedPasswordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mfaCredentials<T extends User$mfaCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$mfaCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recoveryCodes<T extends User$recoveryCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$recoveryCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordHistory<T extends User$passwordHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordBreachesChecked<T extends User$passwordBreachesCheckedArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordBreachesCheckedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordBreachesResolved<T extends User$passwordBreachesResolvedArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordBreachesResolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotationPolicies<T extends User$rotationPoliciesArgs<ExtArgs> = {}>(args?: Subset<T, User$rotationPoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordRotations<T extends User$passwordRotationsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordRotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedSearches<T extends User$savedSearchesArgs<ExtArgs> = {}>(args?: Subset<T, User$savedSearchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchHistory<T extends User$searchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$searchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordTemplates<T extends User$passwordTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdRoles<T extends User$createdRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailVerificationTokens<T extends User$emailVerificationTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$emailVerificationTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityQuestions<T extends User$securityQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$securityQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly recoveryEmail: FieldRef<"User", 'String'>
    readonly recoveryEmailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly mfaEnabled: FieldRef<"User", 'Boolean'>
    readonly mfaSecret: FieldRef<"User", 'String'>
    readonly mfaMethod: FieldRef<"User", 'MfaMethod'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.ownedPasswords
   */
  export type User$ownedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    cursor?: PasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * User.sharedPasswords
   */
  export type User$sharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    cursor?: PasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.mfaCredentials
   */
  export type User$mfaCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    where?: MfaCredentialWhereInput
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    cursor?: MfaCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * User.recoveryCodes
   */
  export type User$recoveryCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    where?: RecoveryCodeWhereInput
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    cursor?: RecoveryCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * User.passwordHistory
   */
  export type User$passwordHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    cursor?: PasswordHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * User.passwordBreachesChecked
   */
  export type User$passwordBreachesCheckedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    cursor?: PasswordBreachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * User.passwordBreachesResolved
   */
  export type User$passwordBreachesResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    cursor?: PasswordBreachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * User.rotationPolicies
   */
  export type User$rotationPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    where?: PasswordRotationPolicyWhereInput
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    cursor?: PasswordRotationPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * User.passwordRotations
   */
  export type User$passwordRotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    cursor?: PasswordRotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * User.savedSearches
   */
  export type User$savedSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    where?: SavedSearchWhereInput
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    cursor?: SavedSearchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * User.searchHistory
   */
  export type User$searchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * User.passwordTemplates
   */
  export type User$passwordTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    where?: PasswordTemplateWhereInput
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    cursor?: PasswordTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.createdRoles
   */
  export type User$createdRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * User.emailVerificationTokens
   */
  export type User$emailVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    where?: EmailVerificationTokenWhereInput
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    cursor?: EmailVerificationTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.securityQuestions
   */
  export type User$securityQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    where?: SecurityQuestionWhereInput
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    cursor?: SecurityQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceName: string | null
    deviceType: string | null
    isTrusted: boolean | null
    lastActiveAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    ipAddress: string | null
    userAgent: string | null
    deviceName: string | null
    deviceType: string | null
    isTrusted: boolean | null
    lastActiveAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    ipAddress: number
    userAgent: number
    deviceName: number
    deviceType: number
    isTrusted: number
    lastActiveAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    deviceName?: true
    deviceType?: true
    isTrusted?: true
    lastActiveAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    deviceName?: true
    deviceType?: true
    isTrusted?: true
    lastActiveAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    deviceName?: true
    deviceType?: true
    isTrusted?: true
    lastActiveAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    ipAddress: string | null
    userAgent: string | null
    deviceName: string | null
    deviceType: string | null
    isTrusted: boolean
    lastActiveAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    isTrusted?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    isTrusted?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    isTrusted?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceName?: boolean
    deviceType?: boolean
    isTrusted?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "ipAddress" | "userAgent" | "deviceName" | "deviceType" | "isTrusted" | "lastActiveAt" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      ipAddress: string | null
      userAgent: string | null
      deviceName: string | null
      deviceType: string | null
      isTrusted: boolean
      lastActiveAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly deviceName: FieldRef<"Session", 'String'>
    readonly deviceType: FieldRef<"Session", 'String'>
    readonly isTrusted: FieldRef<"Session", 'Boolean'>
    readonly lastActiveAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Password
   */

  export type AggregatePassword = {
    _count: PasswordCountAggregateOutputType | null
    _min: PasswordMinAggregateOutputType | null
    _max: PasswordMaxAggregateOutputType | null
  }

  export type PasswordMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    isFavorite: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rotationPolicyId: string | null
  }

  export type PasswordMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    isFavorite: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rotationPolicyId: string | null
  }

  export type PasswordCountAggregateOutputType = {
    id: number
    name: number
    username: number
    password: number
    url: number
    notes: number
    folderId: number
    strength: number
    hasTotp: number
    totpSecret: number
    expiresAt: number
    isFavorite: number
    ownerId: number
    createdAt: number
    updatedAt: number
    rotationPolicyId: number
    _all: number
  }


  export type PasswordMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    isFavorite?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    rotationPolicyId?: true
  }

  export type PasswordMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    isFavorite?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    rotationPolicyId?: true
  }

  export type PasswordCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    isFavorite?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    rotationPolicyId?: true
    _all?: true
  }

  export type PasswordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Password to aggregate.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passwords
    **/
    _count?: true | PasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordMaxAggregateInputType
  }

  export type GetPasswordAggregateType<T extends PasswordAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword[P]>
      : GetScalarType<T[P], AggregatePassword[P]>
  }




  export type PasswordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithAggregationInput | PasswordOrderByWithAggregationInput[]
    by: PasswordScalarFieldEnum[] | PasswordScalarFieldEnum
    having?: PasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordCountAggregateInputType | true
    _min?: PasswordMinAggregateInputType
    _max?: PasswordMaxAggregateInputType
  }

  export type PasswordGroupByOutputType = {
    id: string
    name: string
    username: string
    password: string
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret: string | null
    expiresAt: Date | null
    isFavorite: boolean
    ownerId: string
    createdAt: Date
    updatedAt: Date
    rotationPolicyId: string | null
    _count: PasswordCountAggregateOutputType | null
    _min: PasswordMinAggregateOutputType | null
    _max: PasswordMaxAggregateOutputType | null
  }

  type GetPasswordGroupByPayload<T extends PasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordGroupByOutputType[P]>
        }
      >
    >


  export type PasswordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    sharedWith?: boolean | Password$sharedWithArgs<ExtArgs>
    tags?: boolean | Password$tagsArgs<ExtArgs>
    history?: boolean | Password$historyArgs<ExtArgs>
    breaches?: boolean | Password$breachesArgs<ExtArgs>
    rotations?: boolean | Password$rotationsArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
    _count?: boolean | PasswordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }, ExtArgs["result"]["password"]>

  export type PasswordSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    isFavorite?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotationPolicyId?: boolean
  }

  export type PasswordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "password" | "url" | "notes" | "folderId" | "strength" | "hasTotp" | "totpSecret" | "expiresAt" | "isFavorite" | "ownerId" | "createdAt" | "updatedAt" | "rotationPolicyId", ExtArgs["result"]["password"]>
  export type PasswordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    sharedWith?: boolean | Password$sharedWithArgs<ExtArgs>
    tags?: boolean | Password$tagsArgs<ExtArgs>
    history?: boolean | Password$historyArgs<ExtArgs>
    breaches?: boolean | Password$breachesArgs<ExtArgs>
    rotations?: boolean | Password$rotationsArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
    _count?: boolean | PasswordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PasswordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }
  export type PasswordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Password$folderArgs<ExtArgs>
    rotationPolicy?: boolean | Password$rotationPolicyArgs<ExtArgs>
  }

  export type $PasswordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Password"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      folder: Prisma.$FolderPayload<ExtArgs> | null
      sharedWith: Prisma.$PasswordSharePayload<ExtArgs>[]
      tags: Prisma.$PasswordTagPayload<ExtArgs>[]
      history: Prisma.$PasswordHistoryPayload<ExtArgs>[]
      breaches: Prisma.$PasswordBreachPayload<ExtArgs>[]
      rotations: Prisma.$PasswordRotationPayload<ExtArgs>[]
      rotationPolicy: Prisma.$PasswordRotationPolicyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      password: string
      url: string | null
      notes: string | null
      folderId: string | null
      strength: $Enums.PasswordStrength
      hasTotp: boolean
      totpSecret: string | null
      expiresAt: Date | null
      isFavorite: boolean
      ownerId: string
      createdAt: Date
      updatedAt: Date
      rotationPolicyId: string | null
    }, ExtArgs["result"]["password"]>
    composites: {}
  }

  type PasswordGetPayload<S extends boolean | null | undefined | PasswordDefaultArgs> = $Result.GetResult<Prisma.$PasswordPayload, S>

  type PasswordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordCountAggregateInputType | true
    }

  export interface PasswordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Password'], meta: { name: 'Password' } }
    /**
     * Find zero or one Password that matches the filter.
     * @param {PasswordFindUniqueArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordFindUniqueArgs>(args: SelectSubset<T, PasswordFindUniqueArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordFindUniqueOrThrowArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindFirstArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordFindFirstArgs>(args?: SelectSubset<T, PasswordFindFirstArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindFirstOrThrowArgs} args - Arguments to find a Password
     * @example
     * // Get one Password
     * const password = await prisma.password.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passwords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passwords
     * const passwords = await prisma.password.findMany()
     * 
     * // Get first 10 Passwords
     * const passwords = await prisma.password.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordWithIdOnly = await prisma.password.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordFindManyArgs>(args?: SelectSubset<T, PasswordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password.
     * @param {PasswordCreateArgs} args - Arguments to create a Password.
     * @example
     * // Create one Password
     * const Password = await prisma.password.create({
     *   data: {
     *     // ... data to create a Password
     *   }
     * })
     * 
     */
    create<T extends PasswordCreateArgs>(args: SelectSubset<T, PasswordCreateArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passwords.
     * @param {PasswordCreateManyArgs} args - Arguments to create many Passwords.
     * @example
     * // Create many Passwords
     * const password = await prisma.password.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordCreateManyArgs>(args?: SelectSubset<T, PasswordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passwords and returns the data saved in the database.
     * @param {PasswordCreateManyAndReturnArgs} args - Arguments to create many Passwords.
     * @example
     * // Create many Passwords
     * const password = await prisma.password.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passwords and only return the `id`
     * const passwordWithIdOnly = await prisma.password.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Password.
     * @param {PasswordDeleteArgs} args - Arguments to delete one Password.
     * @example
     * // Delete one Password
     * const Password = await prisma.password.delete({
     *   where: {
     *     // ... filter to delete one Password
     *   }
     * })
     * 
     */
    delete<T extends PasswordDeleteArgs>(args: SelectSubset<T, PasswordDeleteArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password.
     * @param {PasswordUpdateArgs} args - Arguments to update one Password.
     * @example
     * // Update one Password
     * const password = await prisma.password.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordUpdateArgs>(args: SelectSubset<T, PasswordUpdateArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passwords.
     * @param {PasswordDeleteManyArgs} args - Arguments to filter Passwords to delete.
     * @example
     * // Delete a few Passwords
     * const { count } = await prisma.password.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordDeleteManyArgs>(args?: SelectSubset<T, PasswordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passwords
     * const password = await prisma.password.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordUpdateManyArgs>(args: SelectSubset<T, PasswordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passwords and returns the data updated in the database.
     * @param {PasswordUpdateManyAndReturnArgs} args - Arguments to update many Passwords.
     * @example
     * // Update many Passwords
     * const password = await prisma.password.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passwords and only return the `id`
     * const passwordWithIdOnly = await prisma.password.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Password.
     * @param {PasswordUpsertArgs} args - Arguments to update or create a Password.
     * @example
     * // Update or create a Password
     * const password = await prisma.password.upsert({
     *   create: {
     *     // ... data to create a Password
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password we want to update
     *   }
     * })
     */
    upsert<T extends PasswordUpsertArgs>(args: SelectSubset<T, PasswordUpsertArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordCountArgs} args - Arguments to filter Passwords to count.
     * @example
     * // Count the number of Passwords
     * const count = await prisma.password.count({
     *   where: {
     *     // ... the filter for the Passwords we want to count
     *   }
     * })
    **/
    count<T extends PasswordCountArgs>(
      args?: Subset<T, PasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordAggregateArgs>(args: Subset<T, PasswordAggregateArgs>): Prisma.PrismaPromise<GetPasswordAggregateType<T>>

    /**
     * Group by Password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordGroupByArgs['orderBy'] }
        : { orderBy?: PasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Password model
   */
  readonly fields: PasswordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Password.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends Password$folderArgs<ExtArgs> = {}>(args?: Subset<T, Password$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sharedWith<T extends Password$sharedWithArgs<ExtArgs> = {}>(args?: Subset<T, Password$sharedWithArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Password$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Password$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends Password$historyArgs<ExtArgs> = {}>(args?: Subset<T, Password$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    breaches<T extends Password$breachesArgs<ExtArgs> = {}>(args?: Subset<T, Password$breachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotations<T extends Password$rotationsArgs<ExtArgs> = {}>(args?: Subset<T, Password$rotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotationPolicy<T extends Password$rotationPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Password$rotationPolicyArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Password model
   */
  interface PasswordFieldRefs {
    readonly id: FieldRef<"Password", 'String'>
    readonly name: FieldRef<"Password", 'String'>
    readonly username: FieldRef<"Password", 'String'>
    readonly password: FieldRef<"Password", 'String'>
    readonly url: FieldRef<"Password", 'String'>
    readonly notes: FieldRef<"Password", 'String'>
    readonly folderId: FieldRef<"Password", 'String'>
    readonly strength: FieldRef<"Password", 'PasswordStrength'>
    readonly hasTotp: FieldRef<"Password", 'Boolean'>
    readonly totpSecret: FieldRef<"Password", 'String'>
    readonly expiresAt: FieldRef<"Password", 'DateTime'>
    readonly isFavorite: FieldRef<"Password", 'Boolean'>
    readonly ownerId: FieldRef<"Password", 'String'>
    readonly createdAt: FieldRef<"Password", 'DateTime'>
    readonly updatedAt: FieldRef<"Password", 'DateTime'>
    readonly rotationPolicyId: FieldRef<"Password", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Password findUnique
   */
  export type PasswordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password findUniqueOrThrow
   */
  export type PasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password findFirst
   */
  export type PasswordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passwords.
     */
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password findFirstOrThrow
   */
  export type PasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Password to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passwords.
     */
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password findMany
   */
  export type PasswordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter, which Passwords to fetch.
     */
    where?: PasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passwords to fetch.
     */
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passwords.
     */
    cursor?: PasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passwords.
     */
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Password create
   */
  export type PasswordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * The data needed to create a Password.
     */
    data: XOR<PasswordCreateInput, PasswordUncheckedCreateInput>
  }

  /**
   * Password createMany
   */
  export type PasswordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passwords.
     */
    data: PasswordCreateManyInput | PasswordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Password createManyAndReturn
   */
  export type PasswordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data used to create many Passwords.
     */
    data: PasswordCreateManyInput | PasswordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Password update
   */
  export type PasswordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * The data needed to update a Password.
     */
    data: XOR<PasswordUpdateInput, PasswordUncheckedUpdateInput>
    /**
     * Choose, which Password to update.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password updateMany
   */
  export type PasswordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passwords.
     */
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyInput>
    /**
     * Filter which Passwords to update
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to update.
     */
    limit?: number
  }

  /**
   * Password updateManyAndReturn
   */
  export type PasswordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * The data used to update Passwords.
     */
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyInput>
    /**
     * Filter which Passwords to update
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Password upsert
   */
  export type PasswordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * The filter to search for the Password to update in case it exists.
     */
    where: PasswordWhereUniqueInput
    /**
     * In case the Password found by the `where` argument doesn't exist, create a new Password with this data.
     */
    create: XOR<PasswordCreateInput, PasswordUncheckedCreateInput>
    /**
     * In case the Password was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordUpdateInput, PasswordUncheckedUpdateInput>
  }

  /**
   * Password delete
   */
  export type PasswordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    /**
     * Filter which Password to delete.
     */
    where: PasswordWhereUniqueInput
  }

  /**
   * Password deleteMany
   */
  export type PasswordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passwords to delete
     */
    where?: PasswordWhereInput
    /**
     * Limit how many Passwords to delete.
     */
    limit?: number
  }

  /**
   * Password.folder
   */
  export type Password$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Password.sharedWith
   */
  export type Password$sharedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    cursor?: PasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * Password.tags
   */
  export type Password$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    where?: PasswordTagWhereInput
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    cursor?: PasswordTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * Password.history
   */
  export type Password$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    cursor?: PasswordHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * Password.breaches
   */
  export type Password$breachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    cursor?: PasswordBreachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * Password.rotations
   */
  export type Password$rotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    cursor?: PasswordRotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * Password.rotationPolicy
   */
  export type Password$rotationPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    where?: PasswordRotationPolicyWhereInput
  }

  /**
   * Password without action
   */
  export type PasswordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
  }


  /**
   * Model PasswordHistory
   */

  export type AggregatePasswordHistory = {
    _count: PasswordHistoryCountAggregateOutputType | null
    _min: PasswordHistoryMinAggregateOutputType | null
    _max: PasswordHistoryMaxAggregateOutputType | null
  }

  export type PasswordHistoryMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    changedBy: string | null
    changeType: string | null
    createdAt: Date | null
  }

  export type PasswordHistoryMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    name: string | null
    username: string | null
    password: string | null
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength | null
    hasTotp: boolean | null
    totpSecret: string | null
    expiresAt: Date | null
    changedBy: string | null
    changeType: string | null
    createdAt: Date | null
  }

  export type PasswordHistoryCountAggregateOutputType = {
    id: number
    passwordId: number
    name: number
    username: number
    password: number
    url: number
    notes: number
    folderId: number
    strength: number
    hasTotp: number
    totpSecret: number
    expiresAt: number
    changedBy: number
    changeType: number
    createdAt: number
    _all: number
  }


  export type PasswordHistoryMinAggregateInputType = {
    id?: true
    passwordId?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
  }

  export type PasswordHistoryMaxAggregateInputType = {
    id?: true
    passwordId?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
  }

  export type PasswordHistoryCountAggregateInputType = {
    id?: true
    passwordId?: true
    name?: true
    username?: true
    password?: true
    url?: true
    notes?: true
    folderId?: true
    strength?: true
    hasTotp?: true
    totpSecret?: true
    expiresAt?: true
    changedBy?: true
    changeType?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistory to aggregate.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordHistories
    **/
    _count?: true | PasswordHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordHistoryMaxAggregateInputType
  }

  export type GetPasswordHistoryAggregateType<T extends PasswordHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordHistory[P]>
      : GetScalarType<T[P], AggregatePasswordHistory[P]>
  }




  export type PasswordHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithAggregationInput | PasswordHistoryOrderByWithAggregationInput[]
    by: PasswordHistoryScalarFieldEnum[] | PasswordHistoryScalarFieldEnum
    having?: PasswordHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordHistoryCountAggregateInputType | true
    _min?: PasswordHistoryMinAggregateInputType
    _max?: PasswordHistoryMaxAggregateInputType
  }

  export type PasswordHistoryGroupByOutputType = {
    id: string
    passwordId: string
    name: string
    username: string
    password: string
    url: string | null
    notes: string | null
    folderId: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret: string | null
    expiresAt: Date | null
    changedBy: string
    changeType: string
    createdAt: Date
    _count: PasswordHistoryCountAggregateOutputType | null
    _min: PasswordHistoryMinAggregateOutputType | null
    _max: PasswordHistoryMaxAggregateOutputType | null
  }

  type GetPasswordHistoryGroupByPayload<T extends PasswordHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PasswordHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectScalar = {
    id?: boolean
    passwordId?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    url?: boolean
    notes?: boolean
    folderId?: boolean
    strength?: boolean
    hasTotp?: boolean
    totpSecret?: boolean
    expiresAt?: boolean
    changedBy?: boolean
    changeType?: boolean
    createdAt?: boolean
  }

  export type PasswordHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "name" | "username" | "password" | "url" | "notes" | "folderId" | "strength" | "hasTotp" | "totpSecret" | "expiresAt" | "changedBy" | "changeType" | "createdAt", ExtArgs["result"]["passwordHistory"]>
  export type PasswordHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordEntry?: boolean | PasswordDefaultArgs<ExtArgs>
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordHistory"
    objects: {
      passwordEntry: Prisma.$PasswordPayload<ExtArgs>
      changedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      name: string
      username: string
      password: string
      url: string | null
      notes: string | null
      folderId: string | null
      strength: $Enums.PasswordStrength
      hasTotp: boolean
      totpSecret: string | null
      expiresAt: Date | null
      changedBy: string
      changeType: string
      createdAt: Date
    }, ExtArgs["result"]["passwordHistory"]>
    composites: {}
  }

  type PasswordHistoryGetPayload<S extends boolean | null | undefined | PasswordHistoryDefaultArgs> = $Result.GetResult<Prisma.$PasswordHistoryPayload, S>

  type PasswordHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordHistoryCountAggregateInputType | true
    }

  export interface PasswordHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordHistory'], meta: { name: 'PasswordHistory' } }
    /**
     * Find zero or one PasswordHistory that matches the filter.
     * @param {PasswordHistoryFindUniqueArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordHistoryFindUniqueArgs>(args: SelectSubset<T, PasswordHistoryFindUniqueArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordHistoryFindUniqueOrThrowArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindFirstArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordHistoryFindFirstArgs>(args?: SelectSubset<T, PasswordHistoryFindFirstArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindFirstOrThrowArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordHistories
     * const passwordHistories = await prisma.passwordHistory.findMany()
     * 
     * // Get first 10 PasswordHistories
     * const passwordHistories = await prisma.passwordHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordHistoryFindManyArgs>(args?: SelectSubset<T, PasswordHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordHistory.
     * @param {PasswordHistoryCreateArgs} args - Arguments to create a PasswordHistory.
     * @example
     * // Create one PasswordHistory
     * const PasswordHistory = await prisma.passwordHistory.create({
     *   data: {
     *     // ... data to create a PasswordHistory
     *   }
     * })
     * 
     */
    create<T extends PasswordHistoryCreateArgs>(args: SelectSubset<T, PasswordHistoryCreateArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordHistories.
     * @param {PasswordHistoryCreateManyArgs} args - Arguments to create many PasswordHistories.
     * @example
     * // Create many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordHistoryCreateManyArgs>(args?: SelectSubset<T, PasswordHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordHistories and returns the data saved in the database.
     * @param {PasswordHistoryCreateManyAndReturnArgs} args - Arguments to create many PasswordHistories.
     * @example
     * // Create many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordHistories and only return the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordHistory.
     * @param {PasswordHistoryDeleteArgs} args - Arguments to delete one PasswordHistory.
     * @example
     * // Delete one PasswordHistory
     * const PasswordHistory = await prisma.passwordHistory.delete({
     *   where: {
     *     // ... filter to delete one PasswordHistory
     *   }
     * })
     * 
     */
    delete<T extends PasswordHistoryDeleteArgs>(args: SelectSubset<T, PasswordHistoryDeleteArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordHistory.
     * @param {PasswordHistoryUpdateArgs} args - Arguments to update one PasswordHistory.
     * @example
     * // Update one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordHistoryUpdateArgs>(args: SelectSubset<T, PasswordHistoryUpdateArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordHistories.
     * @param {PasswordHistoryDeleteManyArgs} args - Arguments to filter PasswordHistories to delete.
     * @example
     * // Delete a few PasswordHistories
     * const { count } = await prisma.passwordHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordHistoryDeleteManyArgs>(args?: SelectSubset<T, PasswordHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordHistoryUpdateManyArgs>(args: SelectSubset<T, PasswordHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordHistories and returns the data updated in the database.
     * @param {PasswordHistoryUpdateManyAndReturnArgs} args - Arguments to update many PasswordHistories.
     * @example
     * // Update many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordHistories and only return the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordHistory.
     * @param {PasswordHistoryUpsertArgs} args - Arguments to update or create a PasswordHistory.
     * @example
     * // Update or create a PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.upsert({
     *   create: {
     *     // ... data to create a PasswordHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordHistory we want to update
     *   }
     * })
     */
    upsert<T extends PasswordHistoryUpsertArgs>(args: SelectSubset<T, PasswordHistoryUpsertArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryCountArgs} args - Arguments to filter PasswordHistories to count.
     * @example
     * // Count the number of PasswordHistories
     * const count = await prisma.passwordHistory.count({
     *   where: {
     *     // ... the filter for the PasswordHistories we want to count
     *   }
     * })
    **/
    count<T extends PasswordHistoryCountArgs>(
      args?: Subset<T, PasswordHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordHistoryAggregateArgs>(args: Subset<T, PasswordHistoryAggregateArgs>): Prisma.PrismaPromise<GetPasswordHistoryAggregateType<T>>

    /**
     * Group by PasswordHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PasswordHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordHistory model
   */
  readonly fields: PasswordHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passwordEntry<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordHistory model
   */
  interface PasswordHistoryFieldRefs {
    readonly id: FieldRef<"PasswordHistory", 'String'>
    readonly passwordId: FieldRef<"PasswordHistory", 'String'>
    readonly name: FieldRef<"PasswordHistory", 'String'>
    readonly username: FieldRef<"PasswordHistory", 'String'>
    readonly password: FieldRef<"PasswordHistory", 'String'>
    readonly url: FieldRef<"PasswordHistory", 'String'>
    readonly notes: FieldRef<"PasswordHistory", 'String'>
    readonly folderId: FieldRef<"PasswordHistory", 'String'>
    readonly strength: FieldRef<"PasswordHistory", 'PasswordStrength'>
    readonly hasTotp: FieldRef<"PasswordHistory", 'Boolean'>
    readonly totpSecret: FieldRef<"PasswordHistory", 'String'>
    readonly expiresAt: FieldRef<"PasswordHistory", 'DateTime'>
    readonly changedBy: FieldRef<"PasswordHistory", 'String'>
    readonly changeType: FieldRef<"PasswordHistory", 'String'>
    readonly createdAt: FieldRef<"PasswordHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordHistory findUnique
   */
  export type PasswordHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory findUniqueOrThrow
   */
  export type PasswordHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory findFirst
   */
  export type PasswordHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistories.
     */
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory findFirstOrThrow
   */
  export type PasswordHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistories.
     */
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory findMany
   */
  export type PasswordHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistories to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory create
   */
  export type PasswordHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordHistory.
     */
    data: XOR<PasswordHistoryCreateInput, PasswordHistoryUncheckedCreateInput>
  }

  /**
   * PasswordHistory createMany
   */
  export type PasswordHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordHistories.
     */
    data: PasswordHistoryCreateManyInput | PasswordHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordHistory createManyAndReturn
   */
  export type PasswordHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordHistories.
     */
    data: PasswordHistoryCreateManyInput | PasswordHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordHistory update
   */
  export type PasswordHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordHistory.
     */
    data: XOR<PasswordHistoryUpdateInput, PasswordHistoryUncheckedUpdateInput>
    /**
     * Choose, which PasswordHistory to update.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory updateMany
   */
  export type PasswordHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordHistories.
     */
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PasswordHistories to update
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to update.
     */
    limit?: number
  }

  /**
   * PasswordHistory updateManyAndReturn
   */
  export type PasswordHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PasswordHistories.
     */
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PasswordHistories to update
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordHistory upsert
   */
  export type PasswordHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordHistory to update in case it exists.
     */
    where: PasswordHistoryWhereUniqueInput
    /**
     * In case the PasswordHistory found by the `where` argument doesn't exist, create a new PasswordHistory with this data.
     */
    create: XOR<PasswordHistoryCreateInput, PasswordHistoryUncheckedCreateInput>
    /**
     * In case the PasswordHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordHistoryUpdateInput, PasswordHistoryUncheckedUpdateInput>
  }

  /**
   * PasswordHistory delete
   */
  export type PasswordHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter which PasswordHistory to delete.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory deleteMany
   */
  export type PasswordHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistories to delete
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to delete.
     */
    limit?: number
  }

  /**
   * PasswordHistory without action
   */
  export type PasswordHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PasswordBreach
   */

  export type AggregatePasswordBreach = {
    _count: PasswordBreachCountAggregateOutputType | null
    _avg: PasswordBreachAvgAggregateOutputType | null
    _sum: PasswordBreachSumAggregateOutputType | null
    _min: PasswordBreachMinAggregateOutputType | null
    _max: PasswordBreachMaxAggregateOutputType | null
  }

  export type PasswordBreachAvgAggregateOutputType = {
    breachCount: number | null
  }

  export type PasswordBreachSumAggregateOutputType = {
    breachCount: number | null
  }

  export type PasswordBreachMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    isBreached: boolean | null
    breachCount: number | null
    hashPrefix: string | null
    checkedAt: Date | null
    checkedBy: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type PasswordBreachMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    isBreached: boolean | null
    breachCount: number | null
    hashPrefix: string | null
    checkedAt: Date | null
    checkedBy: string | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type PasswordBreachCountAggregateOutputType = {
    id: number
    passwordId: number
    isBreached: number
    breachCount: number
    hashPrefix: number
    checkedAt: number
    checkedBy: number
    resolved: number
    resolvedAt: number
    resolvedBy: number
    _all: number
  }


  export type PasswordBreachAvgAggregateInputType = {
    breachCount?: true
  }

  export type PasswordBreachSumAggregateInputType = {
    breachCount?: true
  }

  export type PasswordBreachMinAggregateInputType = {
    id?: true
    passwordId?: true
    isBreached?: true
    breachCount?: true
    hashPrefix?: true
    checkedAt?: true
    checkedBy?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type PasswordBreachMaxAggregateInputType = {
    id?: true
    passwordId?: true
    isBreached?: true
    breachCount?: true
    hashPrefix?: true
    checkedAt?: true
    checkedBy?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type PasswordBreachCountAggregateInputType = {
    id?: true
    passwordId?: true
    isBreached?: true
    breachCount?: true
    hashPrefix?: true
    checkedAt?: true
    checkedBy?: true
    resolved?: true
    resolvedAt?: true
    resolvedBy?: true
    _all?: true
  }

  export type PasswordBreachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordBreach to aggregate.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordBreaches
    **/
    _count?: true | PasswordBreachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordBreachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordBreachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordBreachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordBreachMaxAggregateInputType
  }

  export type GetPasswordBreachAggregateType<T extends PasswordBreachAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordBreach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordBreach[P]>
      : GetScalarType<T[P], AggregatePasswordBreach[P]>
  }




  export type PasswordBreachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordBreachWhereInput
    orderBy?: PasswordBreachOrderByWithAggregationInput | PasswordBreachOrderByWithAggregationInput[]
    by: PasswordBreachScalarFieldEnum[] | PasswordBreachScalarFieldEnum
    having?: PasswordBreachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordBreachCountAggregateInputType | true
    _avg?: PasswordBreachAvgAggregateInputType
    _sum?: PasswordBreachSumAggregateInputType
    _min?: PasswordBreachMinAggregateInputType
    _max?: PasswordBreachMaxAggregateInputType
  }

  export type PasswordBreachGroupByOutputType = {
    id: string
    passwordId: string
    isBreached: boolean
    breachCount: number
    hashPrefix: string
    checkedAt: Date
    checkedBy: string
    resolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    _count: PasswordBreachCountAggregateOutputType | null
    _avg: PasswordBreachAvgAggregateOutputType | null
    _sum: PasswordBreachSumAggregateOutputType | null
    _min: PasswordBreachMinAggregateOutputType | null
    _max: PasswordBreachMaxAggregateOutputType | null
  }

  type GetPasswordBreachGroupByPayload<T extends PasswordBreachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordBreachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordBreachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordBreachGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordBreachGroupByOutputType[P]>
        }
      >
    >


  export type PasswordBreachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["passwordBreach"]>

  export type PasswordBreachSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["passwordBreach"]>

  export type PasswordBreachSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["passwordBreach"]>

  export type PasswordBreachSelectScalar = {
    id?: boolean
    passwordId?: boolean
    isBreached?: boolean
    breachCount?: boolean
    hashPrefix?: boolean
    checkedAt?: boolean
    checkedBy?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
  }

  export type PasswordBreachOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "isBreached" | "breachCount" | "hashPrefix" | "checkedAt" | "checkedBy" | "resolved" | "resolvedAt" | "resolvedBy", ExtArgs["result"]["passwordBreach"]>
  export type PasswordBreachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }
  export type PasswordBreachIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }
  export type PasswordBreachIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    checkedByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | PasswordBreach$resolvedByUserArgs<ExtArgs>
  }

  export type $PasswordBreachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordBreach"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      checkedByUser: Prisma.$UserPayload<ExtArgs>
      resolvedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      isBreached: boolean
      breachCount: number
      hashPrefix: string
      checkedAt: Date
      checkedBy: string
      resolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
    }, ExtArgs["result"]["passwordBreach"]>
    composites: {}
  }

  type PasswordBreachGetPayload<S extends boolean | null | undefined | PasswordBreachDefaultArgs> = $Result.GetResult<Prisma.$PasswordBreachPayload, S>

  type PasswordBreachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordBreachFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordBreachCountAggregateInputType | true
    }

  export interface PasswordBreachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordBreach'], meta: { name: 'PasswordBreach' } }
    /**
     * Find zero or one PasswordBreach that matches the filter.
     * @param {PasswordBreachFindUniqueArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordBreachFindUniqueArgs>(args: SelectSubset<T, PasswordBreachFindUniqueArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordBreach that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordBreachFindUniqueOrThrowArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordBreachFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordBreachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordBreach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachFindFirstArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordBreachFindFirstArgs>(args?: SelectSubset<T, PasswordBreachFindFirstArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordBreach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachFindFirstOrThrowArgs} args - Arguments to find a PasswordBreach
     * @example
     * // Get one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordBreachFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordBreachFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordBreaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordBreaches
     * const passwordBreaches = await prisma.passwordBreach.findMany()
     * 
     * // Get first 10 PasswordBreaches
     * const passwordBreaches = await prisma.passwordBreach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordBreachWithIdOnly = await prisma.passwordBreach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordBreachFindManyArgs>(args?: SelectSubset<T, PasswordBreachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordBreach.
     * @param {PasswordBreachCreateArgs} args - Arguments to create a PasswordBreach.
     * @example
     * // Create one PasswordBreach
     * const PasswordBreach = await prisma.passwordBreach.create({
     *   data: {
     *     // ... data to create a PasswordBreach
     *   }
     * })
     * 
     */
    create<T extends PasswordBreachCreateArgs>(args: SelectSubset<T, PasswordBreachCreateArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordBreaches.
     * @param {PasswordBreachCreateManyArgs} args - Arguments to create many PasswordBreaches.
     * @example
     * // Create many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordBreachCreateManyArgs>(args?: SelectSubset<T, PasswordBreachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordBreaches and returns the data saved in the database.
     * @param {PasswordBreachCreateManyAndReturnArgs} args - Arguments to create many PasswordBreaches.
     * @example
     * // Create many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordBreaches and only return the `id`
     * const passwordBreachWithIdOnly = await prisma.passwordBreach.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordBreachCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordBreachCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordBreach.
     * @param {PasswordBreachDeleteArgs} args - Arguments to delete one PasswordBreach.
     * @example
     * // Delete one PasswordBreach
     * const PasswordBreach = await prisma.passwordBreach.delete({
     *   where: {
     *     // ... filter to delete one PasswordBreach
     *   }
     * })
     * 
     */
    delete<T extends PasswordBreachDeleteArgs>(args: SelectSubset<T, PasswordBreachDeleteArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordBreach.
     * @param {PasswordBreachUpdateArgs} args - Arguments to update one PasswordBreach.
     * @example
     * // Update one PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordBreachUpdateArgs>(args: SelectSubset<T, PasswordBreachUpdateArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordBreaches.
     * @param {PasswordBreachDeleteManyArgs} args - Arguments to filter PasswordBreaches to delete.
     * @example
     * // Delete a few PasswordBreaches
     * const { count } = await prisma.passwordBreach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordBreachDeleteManyArgs>(args?: SelectSubset<T, PasswordBreachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordBreaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordBreachUpdateManyArgs>(args: SelectSubset<T, PasswordBreachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordBreaches and returns the data updated in the database.
     * @param {PasswordBreachUpdateManyAndReturnArgs} args - Arguments to update many PasswordBreaches.
     * @example
     * // Update many PasswordBreaches
     * const passwordBreach = await prisma.passwordBreach.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordBreaches and only return the `id`
     * const passwordBreachWithIdOnly = await prisma.passwordBreach.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordBreachUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordBreachUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordBreach.
     * @param {PasswordBreachUpsertArgs} args - Arguments to update or create a PasswordBreach.
     * @example
     * // Update or create a PasswordBreach
     * const passwordBreach = await prisma.passwordBreach.upsert({
     *   create: {
     *     // ... data to create a PasswordBreach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordBreach we want to update
     *   }
     * })
     */
    upsert<T extends PasswordBreachUpsertArgs>(args: SelectSubset<T, PasswordBreachUpsertArgs<ExtArgs>>): Prisma__PasswordBreachClient<$Result.GetResult<Prisma.$PasswordBreachPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordBreaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachCountArgs} args - Arguments to filter PasswordBreaches to count.
     * @example
     * // Count the number of PasswordBreaches
     * const count = await prisma.passwordBreach.count({
     *   where: {
     *     // ... the filter for the PasswordBreaches we want to count
     *   }
     * })
    **/
    count<T extends PasswordBreachCountArgs>(
      args?: Subset<T, PasswordBreachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordBreachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordBreach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordBreachAggregateArgs>(args: Subset<T, PasswordBreachAggregateArgs>): Prisma.PrismaPromise<GetPasswordBreachAggregateType<T>>

    /**
     * Group by PasswordBreach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordBreachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordBreachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordBreachGroupByArgs['orderBy'] }
        : { orderBy?: PasswordBreachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordBreachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordBreachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordBreach model
   */
  readonly fields: PasswordBreachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordBreach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordBreachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checkedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resolvedByUser<T extends PasswordBreach$resolvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, PasswordBreach$resolvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordBreach model
   */
  interface PasswordBreachFieldRefs {
    readonly id: FieldRef<"PasswordBreach", 'String'>
    readonly passwordId: FieldRef<"PasswordBreach", 'String'>
    readonly isBreached: FieldRef<"PasswordBreach", 'Boolean'>
    readonly breachCount: FieldRef<"PasswordBreach", 'Int'>
    readonly hashPrefix: FieldRef<"PasswordBreach", 'String'>
    readonly checkedAt: FieldRef<"PasswordBreach", 'DateTime'>
    readonly checkedBy: FieldRef<"PasswordBreach", 'String'>
    readonly resolved: FieldRef<"PasswordBreach", 'Boolean'>
    readonly resolvedAt: FieldRef<"PasswordBreach", 'DateTime'>
    readonly resolvedBy: FieldRef<"PasswordBreach", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PasswordBreach findUnique
   */
  export type PasswordBreachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach findUniqueOrThrow
   */
  export type PasswordBreachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach findFirst
   */
  export type PasswordBreachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordBreaches.
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordBreaches.
     */
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * PasswordBreach findFirstOrThrow
   */
  export type PasswordBreachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreach to fetch.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordBreaches.
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordBreaches.
     */
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * PasswordBreach findMany
   */
  export type PasswordBreachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter, which PasswordBreaches to fetch.
     */
    where?: PasswordBreachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordBreaches to fetch.
     */
    orderBy?: PasswordBreachOrderByWithRelationInput | PasswordBreachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordBreaches.
     */
    cursor?: PasswordBreachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordBreaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordBreaches.
     */
    skip?: number
    distinct?: PasswordBreachScalarFieldEnum | PasswordBreachScalarFieldEnum[]
  }

  /**
   * PasswordBreach create
   */
  export type PasswordBreachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordBreach.
     */
    data: XOR<PasswordBreachCreateInput, PasswordBreachUncheckedCreateInput>
  }

  /**
   * PasswordBreach createMany
   */
  export type PasswordBreachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordBreaches.
     */
    data: PasswordBreachCreateManyInput | PasswordBreachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordBreach createManyAndReturn
   */
  export type PasswordBreachCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordBreaches.
     */
    data: PasswordBreachCreateManyInput | PasswordBreachCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordBreach update
   */
  export type PasswordBreachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordBreach.
     */
    data: XOR<PasswordBreachUpdateInput, PasswordBreachUncheckedUpdateInput>
    /**
     * Choose, which PasswordBreach to update.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach updateMany
   */
  export type PasswordBreachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordBreaches.
     */
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyInput>
    /**
     * Filter which PasswordBreaches to update
     */
    where?: PasswordBreachWhereInput
    /**
     * Limit how many PasswordBreaches to update.
     */
    limit?: number
  }

  /**
   * PasswordBreach updateManyAndReturn
   */
  export type PasswordBreachUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * The data used to update PasswordBreaches.
     */
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyInput>
    /**
     * Filter which PasswordBreaches to update
     */
    where?: PasswordBreachWhereInput
    /**
     * Limit how many PasswordBreaches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordBreach upsert
   */
  export type PasswordBreachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordBreach to update in case it exists.
     */
    where: PasswordBreachWhereUniqueInput
    /**
     * In case the PasswordBreach found by the `where` argument doesn't exist, create a new PasswordBreach with this data.
     */
    create: XOR<PasswordBreachCreateInput, PasswordBreachUncheckedCreateInput>
    /**
     * In case the PasswordBreach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordBreachUpdateInput, PasswordBreachUncheckedUpdateInput>
  }

  /**
   * PasswordBreach delete
   */
  export type PasswordBreachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
    /**
     * Filter which PasswordBreach to delete.
     */
    where: PasswordBreachWhereUniqueInput
  }

  /**
   * PasswordBreach deleteMany
   */
  export type PasswordBreachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordBreaches to delete
     */
    where?: PasswordBreachWhereInput
    /**
     * Limit how many PasswordBreaches to delete.
     */
    limit?: number
  }

  /**
   * PasswordBreach.resolvedByUser
   */
  export type PasswordBreach$resolvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PasswordBreach without action
   */
  export type PasswordBreachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordBreach
     */
    select?: PasswordBreachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordBreach
     */
    omit?: PasswordBreachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordBreachInclude<ExtArgs> | null
  }


  /**
   * Model PasswordRotationPolicy
   */

  export type AggregatePasswordRotationPolicy = {
    _count: PasswordRotationPolicyCountAggregateOutputType | null
    _avg: PasswordRotationPolicyAvgAggregateOutputType | null
    _sum: PasswordRotationPolicySumAggregateOutputType | null
    _min: PasswordRotationPolicyMinAggregateOutputType | null
    _max: PasswordRotationPolicyMaxAggregateOutputType | null
  }

  export type PasswordRotationPolicyAvgAggregateOutputType = {
    rotationDays: number | null
    reminderDays: number | null
  }

  export type PasswordRotationPolicySumAggregateOutputType = {
    rotationDays: number | null
    reminderDays: number | null
  }

  export type PasswordRotationPolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rotationDays: number | null
    reminderDays: number | null
    autoRotate: boolean | null
    requireApproval: boolean | null
    isActive: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordRotationPolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rotationDays: number | null
    reminderDays: number | null
    autoRotate: boolean | null
    requireApproval: boolean | null
    isActive: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordRotationPolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    rotationDays: number
    reminderDays: number
    autoRotate: number
    requireApproval: number
    isActive: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordRotationPolicyAvgAggregateInputType = {
    rotationDays?: true
    reminderDays?: true
  }

  export type PasswordRotationPolicySumAggregateInputType = {
    rotationDays?: true
    reminderDays?: true
  }

  export type PasswordRotationPolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rotationDays?: true
    reminderDays?: true
    autoRotate?: true
    requireApproval?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordRotationPolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rotationDays?: true
    reminderDays?: true
    autoRotate?: true
    requireApproval?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordRotationPolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rotationDays?: true
    reminderDays?: true
    autoRotate?: true
    requireApproval?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordRotationPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotationPolicy to aggregate.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordRotationPolicies
    **/
    _count?: true | PasswordRotationPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordRotationPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordRotationPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordRotationPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordRotationPolicyMaxAggregateInputType
  }

  export type GetPasswordRotationPolicyAggregateType<T extends PasswordRotationPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordRotationPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordRotationPolicy[P]>
      : GetScalarType<T[P], AggregatePasswordRotationPolicy[P]>
  }




  export type PasswordRotationPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationPolicyWhereInput
    orderBy?: PasswordRotationPolicyOrderByWithAggregationInput | PasswordRotationPolicyOrderByWithAggregationInput[]
    by: PasswordRotationPolicyScalarFieldEnum[] | PasswordRotationPolicyScalarFieldEnum
    having?: PasswordRotationPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordRotationPolicyCountAggregateInputType | true
    _avg?: PasswordRotationPolicyAvgAggregateInputType
    _sum?: PasswordRotationPolicySumAggregateInputType
    _min?: PasswordRotationPolicyMinAggregateInputType
    _max?: PasswordRotationPolicyMaxAggregateInputType
  }

  export type PasswordRotationPolicyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    rotationDays: number
    reminderDays: number
    autoRotate: boolean
    requireApproval: boolean
    isActive: boolean
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: PasswordRotationPolicyCountAggregateOutputType | null
    _avg: PasswordRotationPolicyAvgAggregateOutputType | null
    _sum: PasswordRotationPolicySumAggregateOutputType | null
    _min: PasswordRotationPolicyMinAggregateOutputType | null
    _max: PasswordRotationPolicyMaxAggregateOutputType | null
  }

  type GetPasswordRotationPolicyGroupByPayload<T extends PasswordRotationPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordRotationPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordRotationPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordRotationPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordRotationPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PasswordRotationPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    passwords?: boolean | PasswordRotationPolicy$passwordsArgs<ExtArgs>
    rotations?: boolean | PasswordRotationPolicy$rotationsArgs<ExtArgs>
    _count?: boolean | PasswordRotationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotationPolicy"]>

  export type PasswordRotationPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotationPolicy"]>

  export type PasswordRotationPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotationPolicy"]>

  export type PasswordRotationPolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    rotationDays?: boolean
    reminderDays?: boolean
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordRotationPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "rotationDays" | "reminderDays" | "autoRotate" | "requireApproval" | "isActive" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordRotationPolicy"]>
  export type PasswordRotationPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    passwords?: boolean | PasswordRotationPolicy$passwordsArgs<ExtArgs>
    rotations?: boolean | PasswordRotationPolicy$rotationsArgs<ExtArgs>
    _count?: boolean | PasswordRotationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PasswordRotationPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordRotationPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordRotationPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordRotationPolicy"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      passwords: Prisma.$PasswordPayload<ExtArgs>[]
      rotations: Prisma.$PasswordRotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      rotationDays: number
      reminderDays: number
      autoRotate: boolean
      requireApproval: boolean
      isActive: boolean
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordRotationPolicy"]>
    composites: {}
  }

  type PasswordRotationPolicyGetPayload<S extends boolean | null | undefined | PasswordRotationPolicyDefaultArgs> = $Result.GetResult<Prisma.$PasswordRotationPolicyPayload, S>

  type PasswordRotationPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordRotationPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordRotationPolicyCountAggregateInputType | true
    }

  export interface PasswordRotationPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordRotationPolicy'], meta: { name: 'PasswordRotationPolicy' } }
    /**
     * Find zero or one PasswordRotationPolicy that matches the filter.
     * @param {PasswordRotationPolicyFindUniqueArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordRotationPolicyFindUniqueArgs>(args: SelectSubset<T, PasswordRotationPolicyFindUniqueArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordRotationPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordRotationPolicyFindUniqueOrThrowArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordRotationPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordRotationPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotationPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyFindFirstArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordRotationPolicyFindFirstArgs>(args?: SelectSubset<T, PasswordRotationPolicyFindFirstArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotationPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyFindFirstOrThrowArgs} args - Arguments to find a PasswordRotationPolicy
     * @example
     * // Get one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordRotationPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordRotationPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordRotationPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordRotationPolicies
     * const passwordRotationPolicies = await prisma.passwordRotationPolicy.findMany()
     * 
     * // Get first 10 PasswordRotationPolicies
     * const passwordRotationPolicies = await prisma.passwordRotationPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordRotationPolicyWithIdOnly = await prisma.passwordRotationPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordRotationPolicyFindManyArgs>(args?: SelectSubset<T, PasswordRotationPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordRotationPolicy.
     * @param {PasswordRotationPolicyCreateArgs} args - Arguments to create a PasswordRotationPolicy.
     * @example
     * // Create one PasswordRotationPolicy
     * const PasswordRotationPolicy = await prisma.passwordRotationPolicy.create({
     *   data: {
     *     // ... data to create a PasswordRotationPolicy
     *   }
     * })
     * 
     */
    create<T extends PasswordRotationPolicyCreateArgs>(args: SelectSubset<T, PasswordRotationPolicyCreateArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordRotationPolicies.
     * @param {PasswordRotationPolicyCreateManyArgs} args - Arguments to create many PasswordRotationPolicies.
     * @example
     * // Create many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordRotationPolicyCreateManyArgs>(args?: SelectSubset<T, PasswordRotationPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordRotationPolicies and returns the data saved in the database.
     * @param {PasswordRotationPolicyCreateManyAndReturnArgs} args - Arguments to create many PasswordRotationPolicies.
     * @example
     * // Create many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordRotationPolicies and only return the `id`
     * const passwordRotationPolicyWithIdOnly = await prisma.passwordRotationPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordRotationPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordRotationPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordRotationPolicy.
     * @param {PasswordRotationPolicyDeleteArgs} args - Arguments to delete one PasswordRotationPolicy.
     * @example
     * // Delete one PasswordRotationPolicy
     * const PasswordRotationPolicy = await prisma.passwordRotationPolicy.delete({
     *   where: {
     *     // ... filter to delete one PasswordRotationPolicy
     *   }
     * })
     * 
     */
    delete<T extends PasswordRotationPolicyDeleteArgs>(args: SelectSubset<T, PasswordRotationPolicyDeleteArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordRotationPolicy.
     * @param {PasswordRotationPolicyUpdateArgs} args - Arguments to update one PasswordRotationPolicy.
     * @example
     * // Update one PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordRotationPolicyUpdateArgs>(args: SelectSubset<T, PasswordRotationPolicyUpdateArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordRotationPolicies.
     * @param {PasswordRotationPolicyDeleteManyArgs} args - Arguments to filter PasswordRotationPolicies to delete.
     * @example
     * // Delete a few PasswordRotationPolicies
     * const { count } = await prisma.passwordRotationPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordRotationPolicyDeleteManyArgs>(args?: SelectSubset<T, PasswordRotationPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordRotationPolicyUpdateManyArgs>(args: SelectSubset<T, PasswordRotationPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotationPolicies and returns the data updated in the database.
     * @param {PasswordRotationPolicyUpdateManyAndReturnArgs} args - Arguments to update many PasswordRotationPolicies.
     * @example
     * // Update many PasswordRotationPolicies
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordRotationPolicies and only return the `id`
     * const passwordRotationPolicyWithIdOnly = await prisma.passwordRotationPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordRotationPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordRotationPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordRotationPolicy.
     * @param {PasswordRotationPolicyUpsertArgs} args - Arguments to update or create a PasswordRotationPolicy.
     * @example
     * // Update or create a PasswordRotationPolicy
     * const passwordRotationPolicy = await prisma.passwordRotationPolicy.upsert({
     *   create: {
     *     // ... data to create a PasswordRotationPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordRotationPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PasswordRotationPolicyUpsertArgs>(args: SelectSubset<T, PasswordRotationPolicyUpsertArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordRotationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyCountArgs} args - Arguments to filter PasswordRotationPolicies to count.
     * @example
     * // Count the number of PasswordRotationPolicies
     * const count = await prisma.passwordRotationPolicy.count({
     *   where: {
     *     // ... the filter for the PasswordRotationPolicies we want to count
     *   }
     * })
    **/
    count<T extends PasswordRotationPolicyCountArgs>(
      args?: Subset<T, PasswordRotationPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordRotationPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordRotationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordRotationPolicyAggregateArgs>(args: Subset<T, PasswordRotationPolicyAggregateArgs>): Prisma.PrismaPromise<GetPasswordRotationPolicyAggregateType<T>>

    /**
     * Group by PasswordRotationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordRotationPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordRotationPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PasswordRotationPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordRotationPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordRotationPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordRotationPolicy model
   */
  readonly fields: PasswordRotationPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordRotationPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordRotationPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    passwords<T extends PasswordRotationPolicy$passwordsArgs<ExtArgs> = {}>(args?: Subset<T, PasswordRotationPolicy$passwordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rotations<T extends PasswordRotationPolicy$rotationsArgs<ExtArgs> = {}>(args?: Subset<T, PasswordRotationPolicy$rotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordRotationPolicy model
   */
  interface PasswordRotationPolicyFieldRefs {
    readonly id: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly name: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly description: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly rotationDays: FieldRef<"PasswordRotationPolicy", 'Int'>
    readonly reminderDays: FieldRef<"PasswordRotationPolicy", 'Int'>
    readonly autoRotate: FieldRef<"PasswordRotationPolicy", 'Boolean'>
    readonly requireApproval: FieldRef<"PasswordRotationPolicy", 'Boolean'>
    readonly isActive: FieldRef<"PasswordRotationPolicy", 'Boolean'>
    readonly ownerId: FieldRef<"PasswordRotationPolicy", 'String'>
    readonly createdAt: FieldRef<"PasswordRotationPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordRotationPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordRotationPolicy findUnique
   */
  export type PasswordRotationPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy findUniqueOrThrow
   */
  export type PasswordRotationPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy findFirst
   */
  export type PasswordRotationPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotationPolicies.
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotationPolicies.
     */
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy findFirstOrThrow
   */
  export type PasswordRotationPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicy to fetch.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotationPolicies.
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotationPolicies.
     */
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy findMany
   */
  export type PasswordRotationPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotationPolicies to fetch.
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotationPolicies to fetch.
     */
    orderBy?: PasswordRotationPolicyOrderByWithRelationInput | PasswordRotationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordRotationPolicies.
     */
    cursor?: PasswordRotationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotationPolicies.
     */
    skip?: number
    distinct?: PasswordRotationPolicyScalarFieldEnum | PasswordRotationPolicyScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy create
   */
  export type PasswordRotationPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordRotationPolicy.
     */
    data: XOR<PasswordRotationPolicyCreateInput, PasswordRotationPolicyUncheckedCreateInput>
  }

  /**
   * PasswordRotationPolicy createMany
   */
  export type PasswordRotationPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordRotationPolicies.
     */
    data: PasswordRotationPolicyCreateManyInput | PasswordRotationPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordRotationPolicy createManyAndReturn
   */
  export type PasswordRotationPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordRotationPolicies.
     */
    data: PasswordRotationPolicyCreateManyInput | PasswordRotationPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotationPolicy update
   */
  export type PasswordRotationPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordRotationPolicy.
     */
    data: XOR<PasswordRotationPolicyUpdateInput, PasswordRotationPolicyUncheckedUpdateInput>
    /**
     * Choose, which PasswordRotationPolicy to update.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy updateMany
   */
  export type PasswordRotationPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordRotationPolicies.
     */
    data: XOR<PasswordRotationPolicyUpdateManyMutationInput, PasswordRotationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotationPolicies to update
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * Limit how many PasswordRotationPolicies to update.
     */
    limit?: number
  }

  /**
   * PasswordRotationPolicy updateManyAndReturn
   */
  export type PasswordRotationPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * The data used to update PasswordRotationPolicies.
     */
    data: XOR<PasswordRotationPolicyUpdateManyMutationInput, PasswordRotationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotationPolicies to update
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * Limit how many PasswordRotationPolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotationPolicy upsert
   */
  export type PasswordRotationPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordRotationPolicy to update in case it exists.
     */
    where: PasswordRotationPolicyWhereUniqueInput
    /**
     * In case the PasswordRotationPolicy found by the `where` argument doesn't exist, create a new PasswordRotationPolicy with this data.
     */
    create: XOR<PasswordRotationPolicyCreateInput, PasswordRotationPolicyUncheckedCreateInput>
    /**
     * In case the PasswordRotationPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordRotationPolicyUpdateInput, PasswordRotationPolicyUncheckedUpdateInput>
  }

  /**
   * PasswordRotationPolicy delete
   */
  export type PasswordRotationPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    /**
     * Filter which PasswordRotationPolicy to delete.
     */
    where: PasswordRotationPolicyWhereUniqueInput
  }

  /**
   * PasswordRotationPolicy deleteMany
   */
  export type PasswordRotationPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotationPolicies to delete
     */
    where?: PasswordRotationPolicyWhereInput
    /**
     * Limit how many PasswordRotationPolicies to delete.
     */
    limit?: number
  }

  /**
   * PasswordRotationPolicy.passwords
   */
  export type PasswordRotationPolicy$passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    cursor?: PasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy.rotations
   */
  export type PasswordRotationPolicy$rotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    cursor?: PasswordRotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotationPolicy without action
   */
  export type PasswordRotationPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
  }


  /**
   * Model PasswordRotation
   */

  export type AggregatePasswordRotation = {
    _count: PasswordRotationCountAggregateOutputType | null
    _min: PasswordRotationMinAggregateOutputType | null
    _max: PasswordRotationMaxAggregateOutputType | null
  }

  export type PasswordRotationMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    policyId: string | null
    rotationType: string | null
    oldPassword: string | null
    newPassword: string | null
    rotatedAt: Date | null
    rotatedBy: string | null
    scheduledFor: Date | null
    completedAt: Date | null
    status: string | null
    notes: string | null
  }

  export type PasswordRotationMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    policyId: string | null
    rotationType: string | null
    oldPassword: string | null
    newPassword: string | null
    rotatedAt: Date | null
    rotatedBy: string | null
    scheduledFor: Date | null
    completedAt: Date | null
    status: string | null
    notes: string | null
  }

  export type PasswordRotationCountAggregateOutputType = {
    id: number
    passwordId: number
    policyId: number
    rotationType: number
    oldPassword: number
    newPassword: number
    rotatedAt: number
    rotatedBy: number
    scheduledFor: number
    completedAt: number
    status: number
    notes: number
    _all: number
  }


  export type PasswordRotationMinAggregateInputType = {
    id?: true
    passwordId?: true
    policyId?: true
    rotationType?: true
    oldPassword?: true
    newPassword?: true
    rotatedAt?: true
    rotatedBy?: true
    scheduledFor?: true
    completedAt?: true
    status?: true
    notes?: true
  }

  export type PasswordRotationMaxAggregateInputType = {
    id?: true
    passwordId?: true
    policyId?: true
    rotationType?: true
    oldPassword?: true
    newPassword?: true
    rotatedAt?: true
    rotatedBy?: true
    scheduledFor?: true
    completedAt?: true
    status?: true
    notes?: true
  }

  export type PasswordRotationCountAggregateInputType = {
    id?: true
    passwordId?: true
    policyId?: true
    rotationType?: true
    oldPassword?: true
    newPassword?: true
    rotatedAt?: true
    rotatedBy?: true
    scheduledFor?: true
    completedAt?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type PasswordRotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotation to aggregate.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordRotations
    **/
    _count?: true | PasswordRotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordRotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordRotationMaxAggregateInputType
  }

  export type GetPasswordRotationAggregateType<T extends PasswordRotationAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordRotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordRotation[P]>
      : GetScalarType<T[P], AggregatePasswordRotation[P]>
  }




  export type PasswordRotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordRotationWhereInput
    orderBy?: PasswordRotationOrderByWithAggregationInput | PasswordRotationOrderByWithAggregationInput[]
    by: PasswordRotationScalarFieldEnum[] | PasswordRotationScalarFieldEnum
    having?: PasswordRotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordRotationCountAggregateInputType | true
    _min?: PasswordRotationMinAggregateInputType
    _max?: PasswordRotationMaxAggregateInputType
  }

  export type PasswordRotationGroupByOutputType = {
    id: string
    passwordId: string
    policyId: string | null
    rotationType: string
    oldPassword: string | null
    newPassword: string
    rotatedAt: Date
    rotatedBy: string
    scheduledFor: Date | null
    completedAt: Date | null
    status: string
    notes: string | null
    _count: PasswordRotationCountAggregateOutputType | null
    _min: PasswordRotationMinAggregateOutputType | null
    _max: PasswordRotationMaxAggregateOutputType | null
  }

  type GetPasswordRotationGroupByPayload<T extends PasswordRotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordRotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordRotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordRotationGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordRotationGroupByOutputType[P]>
        }
      >
    >


  export type PasswordRotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotation"]>

  export type PasswordRotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotation"]>

  export type PasswordRotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordRotation"]>

  export type PasswordRotationSelectScalar = {
    id?: boolean
    passwordId?: boolean
    policyId?: boolean
    rotationType?: boolean
    oldPassword?: boolean
    newPassword?: boolean
    rotatedAt?: boolean
    rotatedBy?: boolean
    scheduledFor?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
  }

  export type PasswordRotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "policyId" | "rotationType" | "oldPassword" | "newPassword" | "rotatedAt" | "rotatedBy" | "scheduledFor" | "completedAt" | "status" | "notes", ExtArgs["result"]["passwordRotation"]>
  export type PasswordRotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordRotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordRotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    policy?: boolean | PasswordRotation$policyArgs<ExtArgs>
    rotatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordRotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordRotation"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      policy: Prisma.$PasswordRotationPolicyPayload<ExtArgs> | null
      rotatedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      policyId: string | null
      rotationType: string
      oldPassword: string | null
      newPassword: string
      rotatedAt: Date
      rotatedBy: string
      scheduledFor: Date | null
      completedAt: Date | null
      status: string
      notes: string | null
    }, ExtArgs["result"]["passwordRotation"]>
    composites: {}
  }

  type PasswordRotationGetPayload<S extends boolean | null | undefined | PasswordRotationDefaultArgs> = $Result.GetResult<Prisma.$PasswordRotationPayload, S>

  type PasswordRotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordRotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordRotationCountAggregateInputType | true
    }

  export interface PasswordRotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordRotation'], meta: { name: 'PasswordRotation' } }
    /**
     * Find zero or one PasswordRotation that matches the filter.
     * @param {PasswordRotationFindUniqueArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordRotationFindUniqueArgs>(args: SelectSubset<T, PasswordRotationFindUniqueArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordRotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordRotationFindUniqueOrThrowArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordRotationFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordRotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationFindFirstArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordRotationFindFirstArgs>(args?: SelectSubset<T, PasswordRotationFindFirstArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordRotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationFindFirstOrThrowArgs} args - Arguments to find a PasswordRotation
     * @example
     * // Get one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordRotationFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordRotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordRotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordRotations
     * const passwordRotations = await prisma.passwordRotation.findMany()
     * 
     * // Get first 10 PasswordRotations
     * const passwordRotations = await prisma.passwordRotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordRotationWithIdOnly = await prisma.passwordRotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordRotationFindManyArgs>(args?: SelectSubset<T, PasswordRotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordRotation.
     * @param {PasswordRotationCreateArgs} args - Arguments to create a PasswordRotation.
     * @example
     * // Create one PasswordRotation
     * const PasswordRotation = await prisma.passwordRotation.create({
     *   data: {
     *     // ... data to create a PasswordRotation
     *   }
     * })
     * 
     */
    create<T extends PasswordRotationCreateArgs>(args: SelectSubset<T, PasswordRotationCreateArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordRotations.
     * @param {PasswordRotationCreateManyArgs} args - Arguments to create many PasswordRotations.
     * @example
     * // Create many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordRotationCreateManyArgs>(args?: SelectSubset<T, PasswordRotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordRotations and returns the data saved in the database.
     * @param {PasswordRotationCreateManyAndReturnArgs} args - Arguments to create many PasswordRotations.
     * @example
     * // Create many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordRotations and only return the `id`
     * const passwordRotationWithIdOnly = await prisma.passwordRotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordRotationCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordRotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordRotation.
     * @param {PasswordRotationDeleteArgs} args - Arguments to delete one PasswordRotation.
     * @example
     * // Delete one PasswordRotation
     * const PasswordRotation = await prisma.passwordRotation.delete({
     *   where: {
     *     // ... filter to delete one PasswordRotation
     *   }
     * })
     * 
     */
    delete<T extends PasswordRotationDeleteArgs>(args: SelectSubset<T, PasswordRotationDeleteArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordRotation.
     * @param {PasswordRotationUpdateArgs} args - Arguments to update one PasswordRotation.
     * @example
     * // Update one PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordRotationUpdateArgs>(args: SelectSubset<T, PasswordRotationUpdateArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordRotations.
     * @param {PasswordRotationDeleteManyArgs} args - Arguments to filter PasswordRotations to delete.
     * @example
     * // Delete a few PasswordRotations
     * const { count } = await prisma.passwordRotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordRotationDeleteManyArgs>(args?: SelectSubset<T, PasswordRotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordRotationUpdateManyArgs>(args: SelectSubset<T, PasswordRotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordRotations and returns the data updated in the database.
     * @param {PasswordRotationUpdateManyAndReturnArgs} args - Arguments to update many PasswordRotations.
     * @example
     * // Update many PasswordRotations
     * const passwordRotation = await prisma.passwordRotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordRotations and only return the `id`
     * const passwordRotationWithIdOnly = await prisma.passwordRotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordRotationUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordRotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordRotation.
     * @param {PasswordRotationUpsertArgs} args - Arguments to update or create a PasswordRotation.
     * @example
     * // Update or create a PasswordRotation
     * const passwordRotation = await prisma.passwordRotation.upsert({
     *   create: {
     *     // ... data to create a PasswordRotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordRotation we want to update
     *   }
     * })
     */
    upsert<T extends PasswordRotationUpsertArgs>(args: SelectSubset<T, PasswordRotationUpsertArgs<ExtArgs>>): Prisma__PasswordRotationClient<$Result.GetResult<Prisma.$PasswordRotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationCountArgs} args - Arguments to filter PasswordRotations to count.
     * @example
     * // Count the number of PasswordRotations
     * const count = await prisma.passwordRotation.count({
     *   where: {
     *     // ... the filter for the PasswordRotations we want to count
     *   }
     * })
    **/
    count<T extends PasswordRotationCountArgs>(
      args?: Subset<T, PasswordRotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordRotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordRotationAggregateArgs>(args: Subset<T, PasswordRotationAggregateArgs>): Prisma.PrismaPromise<GetPasswordRotationAggregateType<T>>

    /**
     * Group by PasswordRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordRotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordRotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordRotationGroupByArgs['orderBy'] }
        : { orderBy?: PasswordRotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordRotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordRotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordRotation model
   */
  readonly fields: PasswordRotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordRotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordRotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    policy<T extends PasswordRotation$policyArgs<ExtArgs> = {}>(args?: Subset<T, PasswordRotation$policyArgs<ExtArgs>>): Prisma__PasswordRotationPolicyClient<$Result.GetResult<Prisma.$PasswordRotationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rotatedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordRotation model
   */
  interface PasswordRotationFieldRefs {
    readonly id: FieldRef<"PasswordRotation", 'String'>
    readonly passwordId: FieldRef<"PasswordRotation", 'String'>
    readonly policyId: FieldRef<"PasswordRotation", 'String'>
    readonly rotationType: FieldRef<"PasswordRotation", 'String'>
    readonly oldPassword: FieldRef<"PasswordRotation", 'String'>
    readonly newPassword: FieldRef<"PasswordRotation", 'String'>
    readonly rotatedAt: FieldRef<"PasswordRotation", 'DateTime'>
    readonly rotatedBy: FieldRef<"PasswordRotation", 'String'>
    readonly scheduledFor: FieldRef<"PasswordRotation", 'DateTime'>
    readonly completedAt: FieldRef<"PasswordRotation", 'DateTime'>
    readonly status: FieldRef<"PasswordRotation", 'String'>
    readonly notes: FieldRef<"PasswordRotation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PasswordRotation findUnique
   */
  export type PasswordRotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation findUniqueOrThrow
   */
  export type PasswordRotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation findFirst
   */
  export type PasswordRotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotations.
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotations.
     */
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotation findFirstOrThrow
   */
  export type PasswordRotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotation to fetch.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordRotations.
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordRotations.
     */
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotation findMany
   */
  export type PasswordRotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter, which PasswordRotations to fetch.
     */
    where?: PasswordRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordRotations to fetch.
     */
    orderBy?: PasswordRotationOrderByWithRelationInput | PasswordRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordRotations.
     */
    cursor?: PasswordRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordRotations.
     */
    skip?: number
    distinct?: PasswordRotationScalarFieldEnum | PasswordRotationScalarFieldEnum[]
  }

  /**
   * PasswordRotation create
   */
  export type PasswordRotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordRotation.
     */
    data: XOR<PasswordRotationCreateInput, PasswordRotationUncheckedCreateInput>
  }

  /**
   * PasswordRotation createMany
   */
  export type PasswordRotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordRotations.
     */
    data: PasswordRotationCreateManyInput | PasswordRotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordRotation createManyAndReturn
   */
  export type PasswordRotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordRotations.
     */
    data: PasswordRotationCreateManyInput | PasswordRotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotation update
   */
  export type PasswordRotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordRotation.
     */
    data: XOR<PasswordRotationUpdateInput, PasswordRotationUncheckedUpdateInput>
    /**
     * Choose, which PasswordRotation to update.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation updateMany
   */
  export type PasswordRotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordRotations.
     */
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotations to update
     */
    where?: PasswordRotationWhereInput
    /**
     * Limit how many PasswordRotations to update.
     */
    limit?: number
  }

  /**
   * PasswordRotation updateManyAndReturn
   */
  export type PasswordRotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * The data used to update PasswordRotations.
     */
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyInput>
    /**
     * Filter which PasswordRotations to update
     */
    where?: PasswordRotationWhereInput
    /**
     * Limit how many PasswordRotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordRotation upsert
   */
  export type PasswordRotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordRotation to update in case it exists.
     */
    where: PasswordRotationWhereUniqueInput
    /**
     * In case the PasswordRotation found by the `where` argument doesn't exist, create a new PasswordRotation with this data.
     */
    create: XOR<PasswordRotationCreateInput, PasswordRotationUncheckedCreateInput>
    /**
     * In case the PasswordRotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordRotationUpdateInput, PasswordRotationUncheckedUpdateInput>
  }

  /**
   * PasswordRotation delete
   */
  export type PasswordRotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
    /**
     * Filter which PasswordRotation to delete.
     */
    where: PasswordRotationWhereUniqueInput
  }

  /**
   * PasswordRotation deleteMany
   */
  export type PasswordRotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordRotations to delete
     */
    where?: PasswordRotationWhereInput
    /**
     * Limit how many PasswordRotations to delete.
     */
    limit?: number
  }

  /**
   * PasswordRotation.policy
   */
  export type PasswordRotation$policyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotationPolicy
     */
    select?: PasswordRotationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotationPolicy
     */
    omit?: PasswordRotationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationPolicyInclude<ExtArgs> | null
    where?: PasswordRotationPolicyWhereInput
  }

  /**
   * PasswordRotation without action
   */
  export type PasswordRotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordRotation
     */
    select?: PasswordRotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordRotation
     */
    omit?: PasswordRotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordRotationInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    color: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    name: string
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    passwords?: boolean | Folder$passwordsArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "color" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    passwords?: boolean | Folder$passwordsArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      parent: Prisma.$FolderPayload<ExtArgs> | null
      children: Prisma.$FolderPayload<ExtArgs>[]
      passwords: Prisma.$PasswordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      icon: string | null
      color: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Folder$parentArgs<ExtArgs> = {}>(args?: Subset<T, Folder$parentArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Folder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Folder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwords<T extends Folder$passwordsArgs<ExtArgs> = {}>(args?: Subset<T, Folder$passwordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly description: FieldRef<"Folder", 'String'>
    readonly icon: FieldRef<"Folder", 'String'>
    readonly color: FieldRef<"Folder", 'String'>
    readonly parentId: FieldRef<"Folder", 'String'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.parent
   */
  export type Folder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Folder.children
   */
  export type Folder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder.passwords
   */
  export type Folder$passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password
     */
    select?: PasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password
     */
    omit?: PasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordInclude<ExtArgs> | null
    where?: PasswordWhereInput
    orderBy?: PasswordOrderByWithRelationInput | PasswordOrderByWithRelationInput[]
    cursor?: PasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordScalarFieldEnum | PasswordScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model PasswordShare
   */

  export type AggregatePasswordShare = {
    _count: PasswordShareCountAggregateOutputType | null
    _min: PasswordShareMinAggregateOutputType | null
    _max: PasswordShareMaxAggregateOutputType | null
  }

  export type PasswordShareMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    userId: string | null
    teamId: string | null
    permission: $Enums.SharePermission | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PasswordShareMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    userId: string | null
    teamId: string | null
    permission: $Enums.SharePermission | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PasswordShareCountAggregateOutputType = {
    id: number
    passwordId: number
    userId: number
    teamId: number
    permission: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type PasswordShareMinAggregateInputType = {
    id?: true
    passwordId?: true
    userId?: true
    teamId?: true
    permission?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PasswordShareMaxAggregateInputType = {
    id?: true
    passwordId?: true
    userId?: true
    teamId?: true
    permission?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PasswordShareCountAggregateInputType = {
    id?: true
    passwordId?: true
    userId?: true
    teamId?: true
    permission?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type PasswordShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordShare to aggregate.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordShares
    **/
    _count?: true | PasswordShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordShareMaxAggregateInputType
  }

  export type GetPasswordShareAggregateType<T extends PasswordShareAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordShare[P]>
      : GetScalarType<T[P], AggregatePasswordShare[P]>
  }




  export type PasswordShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithAggregationInput | PasswordShareOrderByWithAggregationInput[]
    by: PasswordShareScalarFieldEnum[] | PasswordShareScalarFieldEnum
    having?: PasswordShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordShareCountAggregateInputType | true
    _min?: PasswordShareMinAggregateInputType
    _max?: PasswordShareMaxAggregateInputType
  }

  export type PasswordShareGroupByOutputType = {
    id: string
    passwordId: string
    userId: string | null
    teamId: string | null
    permission: $Enums.SharePermission
    createdAt: Date
    expiresAt: Date | null
    _count: PasswordShareCountAggregateOutputType | null
    _min: PasswordShareMinAggregateOutputType | null
    _max: PasswordShareMaxAggregateOutputType | null
  }

  type GetPasswordShareGroupByPayload<T extends PasswordShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordShareGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordShareGroupByOutputType[P]>
        }
      >
    >


  export type PasswordShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }, ExtArgs["result"]["passwordShare"]>

  export type PasswordShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }, ExtArgs["result"]["passwordShare"]>

  export type PasswordShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }, ExtArgs["result"]["passwordShare"]>

  export type PasswordShareSelectScalar = {
    id?: boolean
    passwordId?: boolean
    userId?: boolean
    teamId?: boolean
    permission?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type PasswordShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "userId" | "teamId" | "permission" | "createdAt" | "expiresAt", ExtArgs["result"]["passwordShare"]>
  export type PasswordShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }
  export type PasswordShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }
  export type PasswordShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    user?: boolean | PasswordShare$userArgs<ExtArgs>
    team?: boolean | PasswordShare$teamArgs<ExtArgs>
  }

  export type $PasswordSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordShare"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      userId: string | null
      teamId: string | null
      permission: $Enums.SharePermission
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["passwordShare"]>
    composites: {}
  }

  type PasswordShareGetPayload<S extends boolean | null | undefined | PasswordShareDefaultArgs> = $Result.GetResult<Prisma.$PasswordSharePayload, S>

  type PasswordShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordShareCountAggregateInputType | true
    }

  export interface PasswordShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordShare'], meta: { name: 'PasswordShare' } }
    /**
     * Find zero or one PasswordShare that matches the filter.
     * @param {PasswordShareFindUniqueArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordShareFindUniqueArgs>(args: SelectSubset<T, PasswordShareFindUniqueArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordShareFindUniqueOrThrowArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordShareFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareFindFirstArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordShareFindFirstArgs>(args?: SelectSubset<T, PasswordShareFindFirstArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareFindFirstOrThrowArgs} args - Arguments to find a PasswordShare
     * @example
     * // Get one PasswordShare
     * const passwordShare = await prisma.passwordShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordShareFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordShares
     * const passwordShares = await prisma.passwordShare.findMany()
     * 
     * // Get first 10 PasswordShares
     * const passwordShares = await prisma.passwordShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordShareWithIdOnly = await prisma.passwordShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordShareFindManyArgs>(args?: SelectSubset<T, PasswordShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordShare.
     * @param {PasswordShareCreateArgs} args - Arguments to create a PasswordShare.
     * @example
     * // Create one PasswordShare
     * const PasswordShare = await prisma.passwordShare.create({
     *   data: {
     *     // ... data to create a PasswordShare
     *   }
     * })
     * 
     */
    create<T extends PasswordShareCreateArgs>(args: SelectSubset<T, PasswordShareCreateArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordShares.
     * @param {PasswordShareCreateManyArgs} args - Arguments to create many PasswordShares.
     * @example
     * // Create many PasswordShares
     * const passwordShare = await prisma.passwordShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordShareCreateManyArgs>(args?: SelectSubset<T, PasswordShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordShares and returns the data saved in the database.
     * @param {PasswordShareCreateManyAndReturnArgs} args - Arguments to create many PasswordShares.
     * @example
     * // Create many PasswordShares
     * const passwordShare = await prisma.passwordShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordShares and only return the `id`
     * const passwordShareWithIdOnly = await prisma.passwordShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordShareCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordShare.
     * @param {PasswordShareDeleteArgs} args - Arguments to delete one PasswordShare.
     * @example
     * // Delete one PasswordShare
     * const PasswordShare = await prisma.passwordShare.delete({
     *   where: {
     *     // ... filter to delete one PasswordShare
     *   }
     * })
     * 
     */
    delete<T extends PasswordShareDeleteArgs>(args: SelectSubset<T, PasswordShareDeleteArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordShare.
     * @param {PasswordShareUpdateArgs} args - Arguments to update one PasswordShare.
     * @example
     * // Update one PasswordShare
     * const passwordShare = await prisma.passwordShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordShareUpdateArgs>(args: SelectSubset<T, PasswordShareUpdateArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordShares.
     * @param {PasswordShareDeleteManyArgs} args - Arguments to filter PasswordShares to delete.
     * @example
     * // Delete a few PasswordShares
     * const { count } = await prisma.passwordShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordShareDeleteManyArgs>(args?: SelectSubset<T, PasswordShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordShares
     * const passwordShare = await prisma.passwordShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordShareUpdateManyArgs>(args: SelectSubset<T, PasswordShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordShares and returns the data updated in the database.
     * @param {PasswordShareUpdateManyAndReturnArgs} args - Arguments to update many PasswordShares.
     * @example
     * // Update many PasswordShares
     * const passwordShare = await prisma.passwordShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordShares and only return the `id`
     * const passwordShareWithIdOnly = await prisma.passwordShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordShareUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordShare.
     * @param {PasswordShareUpsertArgs} args - Arguments to update or create a PasswordShare.
     * @example
     * // Update or create a PasswordShare
     * const passwordShare = await prisma.passwordShare.upsert({
     *   create: {
     *     // ... data to create a PasswordShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordShare we want to update
     *   }
     * })
     */
    upsert<T extends PasswordShareUpsertArgs>(args: SelectSubset<T, PasswordShareUpsertArgs<ExtArgs>>): Prisma__PasswordShareClient<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareCountArgs} args - Arguments to filter PasswordShares to count.
     * @example
     * // Count the number of PasswordShares
     * const count = await prisma.passwordShare.count({
     *   where: {
     *     // ... the filter for the PasswordShares we want to count
     *   }
     * })
    **/
    count<T extends PasswordShareCountArgs>(
      args?: Subset<T, PasswordShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordShareAggregateArgs>(args: Subset<T, PasswordShareAggregateArgs>): Prisma.PrismaPromise<GetPasswordShareAggregateType<T>>

    /**
     * Group by PasswordShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordShareGroupByArgs['orderBy'] }
        : { orderBy?: PasswordShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordShare model
   */
  readonly fields: PasswordShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends PasswordShare$userArgs<ExtArgs> = {}>(args?: Subset<T, PasswordShare$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends PasswordShare$teamArgs<ExtArgs> = {}>(args?: Subset<T, PasswordShare$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordShare model
   */
  interface PasswordShareFieldRefs {
    readonly id: FieldRef<"PasswordShare", 'String'>
    readonly passwordId: FieldRef<"PasswordShare", 'String'>
    readonly userId: FieldRef<"PasswordShare", 'String'>
    readonly teamId: FieldRef<"PasswordShare", 'String'>
    readonly permission: FieldRef<"PasswordShare", 'SharePermission'>
    readonly createdAt: FieldRef<"PasswordShare", 'DateTime'>
    readonly expiresAt: FieldRef<"PasswordShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordShare findUnique
   */
  export type PasswordShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare findUniqueOrThrow
   */
  export type PasswordShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare findFirst
   */
  export type PasswordShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordShares.
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordShares.
     */
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * PasswordShare findFirstOrThrow
   */
  export type PasswordShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShare to fetch.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordShares.
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordShares.
     */
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * PasswordShare findMany
   */
  export type PasswordShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter, which PasswordShares to fetch.
     */
    where?: PasswordShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordShares to fetch.
     */
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordShares.
     */
    cursor?: PasswordShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordShares.
     */
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * PasswordShare create
   */
  export type PasswordShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordShare.
     */
    data: XOR<PasswordShareCreateInput, PasswordShareUncheckedCreateInput>
  }

  /**
   * PasswordShare createMany
   */
  export type PasswordShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordShares.
     */
    data: PasswordShareCreateManyInput | PasswordShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordShare createManyAndReturn
   */
  export type PasswordShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordShares.
     */
    data: PasswordShareCreateManyInput | PasswordShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordShare update
   */
  export type PasswordShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordShare.
     */
    data: XOR<PasswordShareUpdateInput, PasswordShareUncheckedUpdateInput>
    /**
     * Choose, which PasswordShare to update.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare updateMany
   */
  export type PasswordShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordShares.
     */
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyInput>
    /**
     * Filter which PasswordShares to update
     */
    where?: PasswordShareWhereInput
    /**
     * Limit how many PasswordShares to update.
     */
    limit?: number
  }

  /**
   * PasswordShare updateManyAndReturn
   */
  export type PasswordShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * The data used to update PasswordShares.
     */
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyInput>
    /**
     * Filter which PasswordShares to update
     */
    where?: PasswordShareWhereInput
    /**
     * Limit how many PasswordShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordShare upsert
   */
  export type PasswordShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordShare to update in case it exists.
     */
    where: PasswordShareWhereUniqueInput
    /**
     * In case the PasswordShare found by the `where` argument doesn't exist, create a new PasswordShare with this data.
     */
    create: XOR<PasswordShareCreateInput, PasswordShareUncheckedCreateInput>
    /**
     * In case the PasswordShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordShareUpdateInput, PasswordShareUncheckedUpdateInput>
  }

  /**
   * PasswordShare delete
   */
  export type PasswordShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    /**
     * Filter which PasswordShare to delete.
     */
    where: PasswordShareWhereUniqueInput
  }

  /**
   * PasswordShare deleteMany
   */
  export type PasswordShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordShares to delete
     */
    where?: PasswordShareWhereInput
    /**
     * Limit how many PasswordShares to delete.
     */
    limit?: number
  }

  /**
   * PasswordShare.user
   */
  export type PasswordShare$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PasswordShare.team
   */
  export type PasswordShare$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * PasswordShare without action
   */
  export type PasswordShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Team$membersArgs<ExtArgs>
    sharedPasswords?: boolean | Team$sharedPasswordsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Team$membersArgs<ExtArgs>
    sharedPasswords?: boolean | Team$sharedPasswordsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      sharedPasswords: Prisma.$PasswordSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedPasswords<T extends Team$sharedPasswordsArgs<ExtArgs> = {}>(args?: Subset<T, Team$sharedPasswordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.sharedPasswords
   */
  export type Team$sharedPasswordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordShare
     */
    select?: PasswordShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordShare
     */
    omit?: PasswordShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordShareInclude<ExtArgs> | null
    where?: PasswordShareWhereInput
    orderBy?: PasswordShareOrderByWithRelationInput | PasswordShareOrderByWithRelationInput[]
    cursor?: PasswordShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordShareScalarFieldEnum | PasswordShareScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    createdAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    role: $Enums.TeamRole
    createdAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "role" | "createdAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      role: $Enums.TeamRole
      createdAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'TeamRole'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    icon: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    icon?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    icon?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    icon?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string | null
    icon: string | null
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
    passwords?: boolean | Tag$passwordsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "icon" | "createdAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwords?: boolean | Tag$passwordsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      passwords: Prisma.$PasswordTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string | null
      icon: string | null
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passwords<T extends Tag$passwordsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$passwordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly icon: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.passwords
   */
  export type Tag$passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    where?: PasswordTagWhereInput
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    cursor?: PasswordTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model PasswordTag
   */

  export type AggregatePasswordTag = {
    _count: PasswordTagCountAggregateOutputType | null
    _min: PasswordTagMinAggregateOutputType | null
    _max: PasswordTagMaxAggregateOutputType | null
  }

  export type PasswordTagMinAggregateOutputType = {
    id: string | null
    passwordId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type PasswordTagMaxAggregateOutputType = {
    id: string | null
    passwordId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type PasswordTagCountAggregateOutputType = {
    id: number
    passwordId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type PasswordTagMinAggregateInputType = {
    id?: true
    passwordId?: true
    tagId?: true
    createdAt?: true
  }

  export type PasswordTagMaxAggregateInputType = {
    id?: true
    passwordId?: true
    tagId?: true
    createdAt?: true
  }

  export type PasswordTagCountAggregateInputType = {
    id?: true
    passwordId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTag to aggregate.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordTags
    **/
    _count?: true | PasswordTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordTagMaxAggregateInputType
  }

  export type GetPasswordTagAggregateType<T extends PasswordTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordTag[P]>
      : GetScalarType<T[P], AggregatePasswordTag[P]>
  }




  export type PasswordTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTagWhereInput
    orderBy?: PasswordTagOrderByWithAggregationInput | PasswordTagOrderByWithAggregationInput[]
    by: PasswordTagScalarFieldEnum[] | PasswordTagScalarFieldEnum
    having?: PasswordTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordTagCountAggregateInputType | true
    _min?: PasswordTagMinAggregateInputType
    _max?: PasswordTagMaxAggregateInputType
  }

  export type PasswordTagGroupByOutputType = {
    id: string
    passwordId: string
    tagId: string
    createdAt: Date
    _count: PasswordTagCountAggregateOutputType | null
    _min: PasswordTagMinAggregateOutputType | null
    _max: PasswordTagMaxAggregateOutputType | null
  }

  type GetPasswordTagGroupByPayload<T extends PasswordTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordTagGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordTagGroupByOutputType[P]>
        }
      >
    >


  export type PasswordTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTag"]>

  export type PasswordTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTag"]>

  export type PasswordTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTag"]>

  export type PasswordTagSelectScalar = {
    id?: boolean
    passwordId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type PasswordTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordId" | "tagId" | "createdAt", ExtArgs["result"]["passwordTag"]>
  export type PasswordTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PasswordTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PasswordTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    password?: boolean | PasswordDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PasswordTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordTag"
    objects: {
      password: Prisma.$PasswordPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      passwordId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["passwordTag"]>
    composites: {}
  }

  type PasswordTagGetPayload<S extends boolean | null | undefined | PasswordTagDefaultArgs> = $Result.GetResult<Prisma.$PasswordTagPayload, S>

  type PasswordTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordTagCountAggregateInputType | true
    }

  export interface PasswordTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordTag'], meta: { name: 'PasswordTag' } }
    /**
     * Find zero or one PasswordTag that matches the filter.
     * @param {PasswordTagFindUniqueArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordTagFindUniqueArgs>(args: SelectSubset<T, PasswordTagFindUniqueArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordTagFindUniqueOrThrowArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagFindFirstArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordTagFindFirstArgs>(args?: SelectSubset<T, PasswordTagFindFirstArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagFindFirstOrThrowArgs} args - Arguments to find a PasswordTag
     * @example
     * // Get one PasswordTag
     * const passwordTag = await prisma.passwordTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordTags
     * const passwordTags = await prisma.passwordTag.findMany()
     * 
     * // Get first 10 PasswordTags
     * const passwordTags = await prisma.passwordTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordTagWithIdOnly = await prisma.passwordTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordTagFindManyArgs>(args?: SelectSubset<T, PasswordTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordTag.
     * @param {PasswordTagCreateArgs} args - Arguments to create a PasswordTag.
     * @example
     * // Create one PasswordTag
     * const PasswordTag = await prisma.passwordTag.create({
     *   data: {
     *     // ... data to create a PasswordTag
     *   }
     * })
     * 
     */
    create<T extends PasswordTagCreateArgs>(args: SelectSubset<T, PasswordTagCreateArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordTags.
     * @param {PasswordTagCreateManyArgs} args - Arguments to create many PasswordTags.
     * @example
     * // Create many PasswordTags
     * const passwordTag = await prisma.passwordTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordTagCreateManyArgs>(args?: SelectSubset<T, PasswordTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordTags and returns the data saved in the database.
     * @param {PasswordTagCreateManyAndReturnArgs} args - Arguments to create many PasswordTags.
     * @example
     * // Create many PasswordTags
     * const passwordTag = await prisma.passwordTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordTags and only return the `id`
     * const passwordTagWithIdOnly = await prisma.passwordTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordTag.
     * @param {PasswordTagDeleteArgs} args - Arguments to delete one PasswordTag.
     * @example
     * // Delete one PasswordTag
     * const PasswordTag = await prisma.passwordTag.delete({
     *   where: {
     *     // ... filter to delete one PasswordTag
     *   }
     * })
     * 
     */
    delete<T extends PasswordTagDeleteArgs>(args: SelectSubset<T, PasswordTagDeleteArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordTag.
     * @param {PasswordTagUpdateArgs} args - Arguments to update one PasswordTag.
     * @example
     * // Update one PasswordTag
     * const passwordTag = await prisma.passwordTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordTagUpdateArgs>(args: SelectSubset<T, PasswordTagUpdateArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordTags.
     * @param {PasswordTagDeleteManyArgs} args - Arguments to filter PasswordTags to delete.
     * @example
     * // Delete a few PasswordTags
     * const { count } = await prisma.passwordTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordTagDeleteManyArgs>(args?: SelectSubset<T, PasswordTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordTags
     * const passwordTag = await prisma.passwordTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordTagUpdateManyArgs>(args: SelectSubset<T, PasswordTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTags and returns the data updated in the database.
     * @param {PasswordTagUpdateManyAndReturnArgs} args - Arguments to update many PasswordTags.
     * @example
     * // Update many PasswordTags
     * const passwordTag = await prisma.passwordTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordTags and only return the `id`
     * const passwordTagWithIdOnly = await prisma.passwordTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordTag.
     * @param {PasswordTagUpsertArgs} args - Arguments to update or create a PasswordTag.
     * @example
     * // Update or create a PasswordTag
     * const passwordTag = await prisma.passwordTag.upsert({
     *   create: {
     *     // ... data to create a PasswordTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordTag we want to update
     *   }
     * })
     */
    upsert<T extends PasswordTagUpsertArgs>(args: SelectSubset<T, PasswordTagUpsertArgs<ExtArgs>>): Prisma__PasswordTagClient<$Result.GetResult<Prisma.$PasswordTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagCountArgs} args - Arguments to filter PasswordTags to count.
     * @example
     * // Count the number of PasswordTags
     * const count = await prisma.passwordTag.count({
     *   where: {
     *     // ... the filter for the PasswordTags we want to count
     *   }
     * })
    **/
    count<T extends PasswordTagCountArgs>(
      args?: Subset<T, PasswordTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordTagAggregateArgs>(args: Subset<T, PasswordTagAggregateArgs>): Prisma.PrismaPromise<GetPasswordTagAggregateType<T>>

    /**
     * Group by PasswordTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordTagGroupByArgs['orderBy'] }
        : { orderBy?: PasswordTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordTag model
   */
  readonly fields: PasswordTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    password<T extends PasswordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PasswordDefaultArgs<ExtArgs>>): Prisma__PasswordClient<$Result.GetResult<Prisma.$PasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordTag model
   */
  interface PasswordTagFieldRefs {
    readonly id: FieldRef<"PasswordTag", 'String'>
    readonly passwordId: FieldRef<"PasswordTag", 'String'>
    readonly tagId: FieldRef<"PasswordTag", 'String'>
    readonly createdAt: FieldRef<"PasswordTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordTag findUnique
   */
  export type PasswordTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag findUniqueOrThrow
   */
  export type PasswordTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag findFirst
   */
  export type PasswordTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTags.
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTags.
     */
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * PasswordTag findFirstOrThrow
   */
  export type PasswordTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTag to fetch.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTags.
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTags.
     */
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * PasswordTag findMany
   */
  export type PasswordTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTags to fetch.
     */
    where?: PasswordTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTags to fetch.
     */
    orderBy?: PasswordTagOrderByWithRelationInput | PasswordTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordTags.
     */
    cursor?: PasswordTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTags.
     */
    skip?: number
    distinct?: PasswordTagScalarFieldEnum | PasswordTagScalarFieldEnum[]
  }

  /**
   * PasswordTag create
   */
  export type PasswordTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordTag.
     */
    data: XOR<PasswordTagCreateInput, PasswordTagUncheckedCreateInput>
  }

  /**
   * PasswordTag createMany
   */
  export type PasswordTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordTags.
     */
    data: PasswordTagCreateManyInput | PasswordTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordTag createManyAndReturn
   */
  export type PasswordTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordTags.
     */
    data: PasswordTagCreateManyInput | PasswordTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTag update
   */
  export type PasswordTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordTag.
     */
    data: XOR<PasswordTagUpdateInput, PasswordTagUncheckedUpdateInput>
    /**
     * Choose, which PasswordTag to update.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag updateMany
   */
  export type PasswordTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordTags.
     */
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTags to update
     */
    where?: PasswordTagWhereInput
    /**
     * Limit how many PasswordTags to update.
     */
    limit?: number
  }

  /**
   * PasswordTag updateManyAndReturn
   */
  export type PasswordTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * The data used to update PasswordTags.
     */
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTags to update
     */
    where?: PasswordTagWhereInput
    /**
     * Limit how many PasswordTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTag upsert
   */
  export type PasswordTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordTag to update in case it exists.
     */
    where: PasswordTagWhereUniqueInput
    /**
     * In case the PasswordTag found by the `where` argument doesn't exist, create a new PasswordTag with this data.
     */
    create: XOR<PasswordTagCreateInput, PasswordTagUncheckedCreateInput>
    /**
     * In case the PasswordTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordTagUpdateInput, PasswordTagUncheckedUpdateInput>
  }

  /**
   * PasswordTag delete
   */
  export type PasswordTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
    /**
     * Filter which PasswordTag to delete.
     */
    where: PasswordTagWhereUniqueInput
  }

  /**
   * PasswordTag deleteMany
   */
  export type PasswordTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTags to delete
     */
    where?: PasswordTagWhereInput
    /**
     * Limit how many PasswordTags to delete.
     */
    limit?: number
  }

  /**
   * PasswordTag without action
   */
  export type PasswordTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTag
     */
    select?: PasswordTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTag
     */
    omit?: PasswordTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTagInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.AuditStatus | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.AuditStatus | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    status: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    status: $Enums.AuditStatus
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "status" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      status: $Enums.AuditStatus
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly status: FieldRef<"AuditLog", 'AuditStatus'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    updatedAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    key?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    key?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "updatedAt", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly key: FieldRef<"Settings", 'String'>
    readonly value: FieldRef<"Settings", 'Json'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isSystem" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Role$createdByArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Role$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Role$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly createdById: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.createdBy
   */
  export type Role$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string | null
    category: string
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name" | "description" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string | null
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly key: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model MfaCredential
   */

  export type AggregateMfaCredential = {
    _count: MfaCredentialCountAggregateOutputType | null
    _avg: MfaCredentialAvgAggregateOutputType | null
    _sum: MfaCredentialSumAggregateOutputType | null
    _min: MfaCredentialMinAggregateOutputType | null
    _max: MfaCredentialMaxAggregateOutputType | null
  }

  export type MfaCredentialAvgAggregateOutputType = {
    counter: number | null
  }

  export type MfaCredentialSumAggregateOutputType = {
    counter: bigint | null
  }

  export type MfaCredentialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: bigint | null
    deviceType: string | null
    backedUp: boolean | null
    transports: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type MfaCredentialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: bigint | null
    deviceType: string | null
    backedUp: boolean | null
    transports: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type MfaCredentialCountAggregateOutputType = {
    id: number
    userId: number
    credentialId: number
    publicKey: number
    counter: number
    deviceType: number
    backedUp: number
    transports: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type MfaCredentialAvgAggregateInputType = {
    counter?: true
  }

  export type MfaCredentialSumAggregateInputType = {
    counter?: true
  }

  export type MfaCredentialMinAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    deviceType?: true
    backedUp?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type MfaCredentialMaxAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    deviceType?: true
    backedUp?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type MfaCredentialCountAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    deviceType?: true
    backedUp?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type MfaCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MfaCredential to aggregate.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MfaCredentials
    **/
    _count?: true | MfaCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MfaCredentialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MfaCredentialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MfaCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MfaCredentialMaxAggregateInputType
  }

  export type GetMfaCredentialAggregateType<T extends MfaCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateMfaCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMfaCredential[P]>
      : GetScalarType<T[P], AggregateMfaCredential[P]>
  }




  export type MfaCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MfaCredentialWhereInput
    orderBy?: MfaCredentialOrderByWithAggregationInput | MfaCredentialOrderByWithAggregationInput[]
    by: MfaCredentialScalarFieldEnum[] | MfaCredentialScalarFieldEnum
    having?: MfaCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MfaCredentialCountAggregateInputType | true
    _avg?: MfaCredentialAvgAggregateInputType
    _sum?: MfaCredentialSumAggregateInputType
    _min?: MfaCredentialMinAggregateInputType
    _max?: MfaCredentialMaxAggregateInputType
  }

  export type MfaCredentialGroupByOutputType = {
    id: string
    userId: string
    credentialId: string
    publicKey: string
    counter: bigint
    deviceType: string | null
    backedUp: boolean
    transports: string | null
    createdAt: Date
    lastUsedAt: Date | null
    _count: MfaCredentialCountAggregateOutputType | null
    _avg: MfaCredentialAvgAggregateOutputType | null
    _sum: MfaCredentialSumAggregateOutputType | null
    _min: MfaCredentialMinAggregateOutputType | null
    _max: MfaCredentialMaxAggregateOutputType | null
  }

  type GetMfaCredentialGroupByPayload<T extends MfaCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MfaCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MfaCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MfaCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], MfaCredentialGroupByOutputType[P]>
        }
      >
    >


  export type MfaCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaCredential"]>

  export type MfaCredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaCredential"]>

  export type MfaCredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaCredential"]>

  export type MfaCredentialSelectScalar = {
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    deviceType?: boolean
    backedUp?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type MfaCredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "credentialId" | "publicKey" | "counter" | "deviceType" | "backedUp" | "transports" | "createdAt" | "lastUsedAt", ExtArgs["result"]["mfaCredential"]>
  export type MfaCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MfaCredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MfaCredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MfaCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MfaCredential"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      credentialId: string
      publicKey: string
      counter: bigint
      deviceType: string | null
      backedUp: boolean
      transports: string | null
      createdAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["mfaCredential"]>
    composites: {}
  }

  type MfaCredentialGetPayload<S extends boolean | null | undefined | MfaCredentialDefaultArgs> = $Result.GetResult<Prisma.$MfaCredentialPayload, S>

  type MfaCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MfaCredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MfaCredentialCountAggregateInputType | true
    }

  export interface MfaCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MfaCredential'], meta: { name: 'MfaCredential' } }
    /**
     * Find zero or one MfaCredential that matches the filter.
     * @param {MfaCredentialFindUniqueArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MfaCredentialFindUniqueArgs>(args: SelectSubset<T, MfaCredentialFindUniqueArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MfaCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MfaCredentialFindUniqueOrThrowArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MfaCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, MfaCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MfaCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialFindFirstArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MfaCredentialFindFirstArgs>(args?: SelectSubset<T, MfaCredentialFindFirstArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MfaCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialFindFirstOrThrowArgs} args - Arguments to find a MfaCredential
     * @example
     * // Get one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MfaCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, MfaCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MfaCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MfaCredentials
     * const mfaCredentials = await prisma.mfaCredential.findMany()
     * 
     * // Get first 10 MfaCredentials
     * const mfaCredentials = await prisma.mfaCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mfaCredentialWithIdOnly = await prisma.mfaCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MfaCredentialFindManyArgs>(args?: SelectSubset<T, MfaCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MfaCredential.
     * @param {MfaCredentialCreateArgs} args - Arguments to create a MfaCredential.
     * @example
     * // Create one MfaCredential
     * const MfaCredential = await prisma.mfaCredential.create({
     *   data: {
     *     // ... data to create a MfaCredential
     *   }
     * })
     * 
     */
    create<T extends MfaCredentialCreateArgs>(args: SelectSubset<T, MfaCredentialCreateArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MfaCredentials.
     * @param {MfaCredentialCreateManyArgs} args - Arguments to create many MfaCredentials.
     * @example
     * // Create many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MfaCredentialCreateManyArgs>(args?: SelectSubset<T, MfaCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MfaCredentials and returns the data saved in the database.
     * @param {MfaCredentialCreateManyAndReturnArgs} args - Arguments to create many MfaCredentials.
     * @example
     * // Create many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MfaCredentials and only return the `id`
     * const mfaCredentialWithIdOnly = await prisma.mfaCredential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MfaCredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, MfaCredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MfaCredential.
     * @param {MfaCredentialDeleteArgs} args - Arguments to delete one MfaCredential.
     * @example
     * // Delete one MfaCredential
     * const MfaCredential = await prisma.mfaCredential.delete({
     *   where: {
     *     // ... filter to delete one MfaCredential
     *   }
     * })
     * 
     */
    delete<T extends MfaCredentialDeleteArgs>(args: SelectSubset<T, MfaCredentialDeleteArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MfaCredential.
     * @param {MfaCredentialUpdateArgs} args - Arguments to update one MfaCredential.
     * @example
     * // Update one MfaCredential
     * const mfaCredential = await prisma.mfaCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MfaCredentialUpdateArgs>(args: SelectSubset<T, MfaCredentialUpdateArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MfaCredentials.
     * @param {MfaCredentialDeleteManyArgs} args - Arguments to filter MfaCredentials to delete.
     * @example
     * // Delete a few MfaCredentials
     * const { count } = await prisma.mfaCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MfaCredentialDeleteManyArgs>(args?: SelectSubset<T, MfaCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MfaCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MfaCredentialUpdateManyArgs>(args: SelectSubset<T, MfaCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MfaCredentials and returns the data updated in the database.
     * @param {MfaCredentialUpdateManyAndReturnArgs} args - Arguments to update many MfaCredentials.
     * @example
     * // Update many MfaCredentials
     * const mfaCredential = await prisma.mfaCredential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MfaCredentials and only return the `id`
     * const mfaCredentialWithIdOnly = await prisma.mfaCredential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MfaCredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, MfaCredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MfaCredential.
     * @param {MfaCredentialUpsertArgs} args - Arguments to update or create a MfaCredential.
     * @example
     * // Update or create a MfaCredential
     * const mfaCredential = await prisma.mfaCredential.upsert({
     *   create: {
     *     // ... data to create a MfaCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MfaCredential we want to update
     *   }
     * })
     */
    upsert<T extends MfaCredentialUpsertArgs>(args: SelectSubset<T, MfaCredentialUpsertArgs<ExtArgs>>): Prisma__MfaCredentialClient<$Result.GetResult<Prisma.$MfaCredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MfaCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialCountArgs} args - Arguments to filter MfaCredentials to count.
     * @example
     * // Count the number of MfaCredentials
     * const count = await prisma.mfaCredential.count({
     *   where: {
     *     // ... the filter for the MfaCredentials we want to count
     *   }
     * })
    **/
    count<T extends MfaCredentialCountArgs>(
      args?: Subset<T, MfaCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MfaCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MfaCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MfaCredentialAggregateArgs>(args: Subset<T, MfaCredentialAggregateArgs>): Prisma.PrismaPromise<GetMfaCredentialAggregateType<T>>

    /**
     * Group by MfaCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MfaCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MfaCredentialGroupByArgs['orderBy'] }
        : { orderBy?: MfaCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MfaCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMfaCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MfaCredential model
   */
  readonly fields: MfaCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MfaCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MfaCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MfaCredential model
   */
  interface MfaCredentialFieldRefs {
    readonly id: FieldRef<"MfaCredential", 'String'>
    readonly userId: FieldRef<"MfaCredential", 'String'>
    readonly credentialId: FieldRef<"MfaCredential", 'String'>
    readonly publicKey: FieldRef<"MfaCredential", 'String'>
    readonly counter: FieldRef<"MfaCredential", 'BigInt'>
    readonly deviceType: FieldRef<"MfaCredential", 'String'>
    readonly backedUp: FieldRef<"MfaCredential", 'Boolean'>
    readonly transports: FieldRef<"MfaCredential", 'String'>
    readonly createdAt: FieldRef<"MfaCredential", 'DateTime'>
    readonly lastUsedAt: FieldRef<"MfaCredential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MfaCredential findUnique
   */
  export type MfaCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential findUniqueOrThrow
   */
  export type MfaCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential findFirst
   */
  export type MfaCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MfaCredentials.
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MfaCredentials.
     */
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * MfaCredential findFirstOrThrow
   */
  export type MfaCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredential to fetch.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MfaCredentials.
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MfaCredentials.
     */
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * MfaCredential findMany
   */
  export type MfaCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter, which MfaCredentials to fetch.
     */
    where?: MfaCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaCredentials to fetch.
     */
    orderBy?: MfaCredentialOrderByWithRelationInput | MfaCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MfaCredentials.
     */
    cursor?: MfaCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaCredentials.
     */
    skip?: number
    distinct?: MfaCredentialScalarFieldEnum | MfaCredentialScalarFieldEnum[]
  }

  /**
   * MfaCredential create
   */
  export type MfaCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a MfaCredential.
     */
    data: XOR<MfaCredentialCreateInput, MfaCredentialUncheckedCreateInput>
  }

  /**
   * MfaCredential createMany
   */
  export type MfaCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MfaCredentials.
     */
    data: MfaCredentialCreateManyInput | MfaCredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MfaCredential createManyAndReturn
   */
  export type MfaCredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * The data used to create many MfaCredentials.
     */
    data: MfaCredentialCreateManyInput | MfaCredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MfaCredential update
   */
  export type MfaCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a MfaCredential.
     */
    data: XOR<MfaCredentialUpdateInput, MfaCredentialUncheckedUpdateInput>
    /**
     * Choose, which MfaCredential to update.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential updateMany
   */
  export type MfaCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MfaCredentials.
     */
    data: XOR<MfaCredentialUpdateManyMutationInput, MfaCredentialUncheckedUpdateManyInput>
    /**
     * Filter which MfaCredentials to update
     */
    where?: MfaCredentialWhereInput
    /**
     * Limit how many MfaCredentials to update.
     */
    limit?: number
  }

  /**
   * MfaCredential updateManyAndReturn
   */
  export type MfaCredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * The data used to update MfaCredentials.
     */
    data: XOR<MfaCredentialUpdateManyMutationInput, MfaCredentialUncheckedUpdateManyInput>
    /**
     * Filter which MfaCredentials to update
     */
    where?: MfaCredentialWhereInput
    /**
     * Limit how many MfaCredentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MfaCredential upsert
   */
  export type MfaCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the MfaCredential to update in case it exists.
     */
    where: MfaCredentialWhereUniqueInput
    /**
     * In case the MfaCredential found by the `where` argument doesn't exist, create a new MfaCredential with this data.
     */
    create: XOR<MfaCredentialCreateInput, MfaCredentialUncheckedCreateInput>
    /**
     * In case the MfaCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MfaCredentialUpdateInput, MfaCredentialUncheckedUpdateInput>
  }

  /**
   * MfaCredential delete
   */
  export type MfaCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
    /**
     * Filter which MfaCredential to delete.
     */
    where: MfaCredentialWhereUniqueInput
  }

  /**
   * MfaCredential deleteMany
   */
  export type MfaCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MfaCredentials to delete
     */
    where?: MfaCredentialWhereInput
    /**
     * Limit how many MfaCredentials to delete.
     */
    limit?: number
  }

  /**
   * MfaCredential without action
   */
  export type MfaCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaCredential
     */
    select?: MfaCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaCredential
     */
    omit?: MfaCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaCredentialInclude<ExtArgs> | null
  }


  /**
   * Model RecoveryCode
   */

  export type AggregateRecoveryCode = {
    _count: RecoveryCodeCountAggregateOutputType | null
    _min: RecoveryCodeMinAggregateOutputType | null
    _max: RecoveryCodeMaxAggregateOutputType | null
  }

  export type RecoveryCodeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type RecoveryCodeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    codeHash: string | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type RecoveryCodeCountAggregateOutputType = {
    id: number
    userId: number
    codeHash: number
    used: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type RecoveryCodeMinAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type RecoveryCodeMaxAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type RecoveryCodeCountAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    used?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type RecoveryCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryCode to aggregate.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryCodes
    **/
    _count?: true | RecoveryCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryCodeMaxAggregateInputType
  }

  export type GetRecoveryCodeAggregateType<T extends RecoveryCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryCode[P]>
      : GetScalarType<T[P], AggregateRecoveryCode[P]>
  }




  export type RecoveryCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryCodeWhereInput
    orderBy?: RecoveryCodeOrderByWithAggregationInput | RecoveryCodeOrderByWithAggregationInput[]
    by: RecoveryCodeScalarFieldEnum[] | RecoveryCodeScalarFieldEnum
    having?: RecoveryCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryCodeCountAggregateInputType | true
    _min?: RecoveryCodeMinAggregateInputType
    _max?: RecoveryCodeMaxAggregateInputType
  }

  export type RecoveryCodeGroupByOutputType = {
    id: string
    userId: string
    codeHash: string
    used: boolean
    usedAt: Date | null
    createdAt: Date
    _count: RecoveryCodeCountAggregateOutputType | null
    _min: RecoveryCodeMinAggregateOutputType | null
    _max: RecoveryCodeMaxAggregateOutputType | null
  }

  type GetRecoveryCodeGroupByPayload<T extends RecoveryCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryCodeGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryCodeGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryCode"]>

  export type RecoveryCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryCode"]>

  export type RecoveryCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryCode"]>

  export type RecoveryCodeSelectScalar = {
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type RecoveryCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "codeHash" | "used" | "usedAt" | "createdAt", ExtArgs["result"]["recoveryCode"]>
  export type RecoveryCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RecoveryCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RecoveryCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RecoveryCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      codeHash: string
      used: boolean
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["recoveryCode"]>
    composites: {}
  }

  type RecoveryCodeGetPayload<S extends boolean | null | undefined | RecoveryCodeDefaultArgs> = $Result.GetResult<Prisma.$RecoveryCodePayload, S>

  type RecoveryCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecoveryCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecoveryCodeCountAggregateInputType | true
    }

  export interface RecoveryCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryCode'], meta: { name: 'RecoveryCode' } }
    /**
     * Find zero or one RecoveryCode that matches the filter.
     * @param {RecoveryCodeFindUniqueArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryCodeFindUniqueArgs>(args: SelectSubset<T, RecoveryCodeFindUniqueArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecoveryCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecoveryCodeFindUniqueOrThrowArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeFindFirstArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryCodeFindFirstArgs>(args?: SelectSubset<T, RecoveryCodeFindFirstArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeFindFirstOrThrowArgs} args - Arguments to find a RecoveryCode
     * @example
     * // Get one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecoveryCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryCodes
     * const recoveryCodes = await prisma.recoveryCode.findMany()
     * 
     * // Get first 10 RecoveryCodes
     * const recoveryCodes = await prisma.recoveryCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recoveryCodeWithIdOnly = await prisma.recoveryCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecoveryCodeFindManyArgs>(args?: SelectSubset<T, RecoveryCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecoveryCode.
     * @param {RecoveryCodeCreateArgs} args - Arguments to create a RecoveryCode.
     * @example
     * // Create one RecoveryCode
     * const RecoveryCode = await prisma.recoveryCode.create({
     *   data: {
     *     // ... data to create a RecoveryCode
     *   }
     * })
     * 
     */
    create<T extends RecoveryCodeCreateArgs>(args: SelectSubset<T, RecoveryCodeCreateArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecoveryCodes.
     * @param {RecoveryCodeCreateManyArgs} args - Arguments to create many RecoveryCodes.
     * @example
     * // Create many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryCodeCreateManyArgs>(args?: SelectSubset<T, RecoveryCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecoveryCodes and returns the data saved in the database.
     * @param {RecoveryCodeCreateManyAndReturnArgs} args - Arguments to create many RecoveryCodes.
     * @example
     * // Create many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecoveryCodes and only return the `id`
     * const recoveryCodeWithIdOnly = await prisma.recoveryCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecoveryCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecoveryCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecoveryCode.
     * @param {RecoveryCodeDeleteArgs} args - Arguments to delete one RecoveryCode.
     * @example
     * // Delete one RecoveryCode
     * const RecoveryCode = await prisma.recoveryCode.delete({
     *   where: {
     *     // ... filter to delete one RecoveryCode
     *   }
     * })
     * 
     */
    delete<T extends RecoveryCodeDeleteArgs>(args: SelectSubset<T, RecoveryCodeDeleteArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecoveryCode.
     * @param {RecoveryCodeUpdateArgs} args - Arguments to update one RecoveryCode.
     * @example
     * // Update one RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryCodeUpdateArgs>(args: SelectSubset<T, RecoveryCodeUpdateArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecoveryCodes.
     * @param {RecoveryCodeDeleteManyArgs} args - Arguments to filter RecoveryCodes to delete.
     * @example
     * // Delete a few RecoveryCodes
     * const { count } = await prisma.recoveryCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryCodeDeleteManyArgs>(args?: SelectSubset<T, RecoveryCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryCodeUpdateManyArgs>(args: SelectSubset<T, RecoveryCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryCodes and returns the data updated in the database.
     * @param {RecoveryCodeUpdateManyAndReturnArgs} args - Arguments to update many RecoveryCodes.
     * @example
     * // Update many RecoveryCodes
     * const recoveryCode = await prisma.recoveryCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecoveryCodes and only return the `id`
     * const recoveryCodeWithIdOnly = await prisma.recoveryCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecoveryCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, RecoveryCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecoveryCode.
     * @param {RecoveryCodeUpsertArgs} args - Arguments to update or create a RecoveryCode.
     * @example
     * // Update or create a RecoveryCode
     * const recoveryCode = await prisma.recoveryCode.upsert({
     *   create: {
     *     // ... data to create a RecoveryCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryCode we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryCodeUpsertArgs>(args: SelectSubset<T, RecoveryCodeUpsertArgs<ExtArgs>>): Prisma__RecoveryCodeClient<$Result.GetResult<Prisma.$RecoveryCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecoveryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeCountArgs} args - Arguments to filter RecoveryCodes to count.
     * @example
     * // Count the number of RecoveryCodes
     * const count = await prisma.recoveryCode.count({
     *   where: {
     *     // ... the filter for the RecoveryCodes we want to count
     *   }
     * })
    **/
    count<T extends RecoveryCodeCountArgs>(
      args?: Subset<T, RecoveryCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryCodeAggregateArgs>(args: Subset<T, RecoveryCodeAggregateArgs>): Prisma.PrismaPromise<GetRecoveryCodeAggregateType<T>>

    /**
     * Group by RecoveryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryCodeGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryCode model
   */
  readonly fields: RecoveryCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryCode model
   */
  interface RecoveryCodeFieldRefs {
    readonly id: FieldRef<"RecoveryCode", 'String'>
    readonly userId: FieldRef<"RecoveryCode", 'String'>
    readonly codeHash: FieldRef<"RecoveryCode", 'String'>
    readonly used: FieldRef<"RecoveryCode", 'Boolean'>
    readonly usedAt: FieldRef<"RecoveryCode", 'DateTime'>
    readonly createdAt: FieldRef<"RecoveryCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryCode findUnique
   */
  export type RecoveryCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode findUniqueOrThrow
   */
  export type RecoveryCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode findFirst
   */
  export type RecoveryCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryCodes.
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryCodes.
     */
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * RecoveryCode findFirstOrThrow
   */
  export type RecoveryCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCode to fetch.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryCodes.
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryCodes.
     */
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * RecoveryCode findMany
   */
  export type RecoveryCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryCodes to fetch.
     */
    where?: RecoveryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryCodes to fetch.
     */
    orderBy?: RecoveryCodeOrderByWithRelationInput | RecoveryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryCodes.
     */
    cursor?: RecoveryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryCodes.
     */
    skip?: number
    distinct?: RecoveryCodeScalarFieldEnum | RecoveryCodeScalarFieldEnum[]
  }

  /**
   * RecoveryCode create
   */
  export type RecoveryCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryCode.
     */
    data: XOR<RecoveryCodeCreateInput, RecoveryCodeUncheckedCreateInput>
  }

  /**
   * RecoveryCode createMany
   */
  export type RecoveryCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryCodes.
     */
    data: RecoveryCodeCreateManyInput | RecoveryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecoveryCode createManyAndReturn
   */
  export type RecoveryCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * The data used to create many RecoveryCodes.
     */
    data: RecoveryCodeCreateManyInput | RecoveryCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryCode update
   */
  export type RecoveryCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryCode.
     */
    data: XOR<RecoveryCodeUpdateInput, RecoveryCodeUncheckedUpdateInput>
    /**
     * Choose, which RecoveryCode to update.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode updateMany
   */
  export type RecoveryCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryCodes.
     */
    data: XOR<RecoveryCodeUpdateManyMutationInput, RecoveryCodeUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryCodes to update
     */
    where?: RecoveryCodeWhereInput
    /**
     * Limit how many RecoveryCodes to update.
     */
    limit?: number
  }

  /**
   * RecoveryCode updateManyAndReturn
   */
  export type RecoveryCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * The data used to update RecoveryCodes.
     */
    data: XOR<RecoveryCodeUpdateManyMutationInput, RecoveryCodeUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryCodes to update
     */
    where?: RecoveryCodeWhereInput
    /**
     * Limit how many RecoveryCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecoveryCode upsert
   */
  export type RecoveryCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryCode to update in case it exists.
     */
    where: RecoveryCodeWhereUniqueInput
    /**
     * In case the RecoveryCode found by the `where` argument doesn't exist, create a new RecoveryCode with this data.
     */
    create: XOR<RecoveryCodeCreateInput, RecoveryCodeUncheckedCreateInput>
    /**
     * In case the RecoveryCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryCodeUpdateInput, RecoveryCodeUncheckedUpdateInput>
  }

  /**
   * RecoveryCode delete
   */
  export type RecoveryCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
    /**
     * Filter which RecoveryCode to delete.
     */
    where: RecoveryCodeWhereUniqueInput
  }

  /**
   * RecoveryCode deleteMany
   */
  export type RecoveryCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryCodes to delete
     */
    where?: RecoveryCodeWhereInput
    /**
     * Limit how many RecoveryCodes to delete.
     */
    limit?: number
  }

  /**
   * RecoveryCode without action
   */
  export type RecoveryCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryCode
     */
    select?: RecoveryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryCode
     */
    omit?: RecoveryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryCodeInclude<ExtArgs> | null
  }


  /**
   * Model SavedSearch
   */

  export type AggregateSavedSearch = {
    _count: SavedSearchCountAggregateOutputType | null
    _min: SavedSearchMinAggregateOutputType | null
    _max: SavedSearchMaxAggregateOutputType | null
  }

  export type SavedSearchMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    query: string | null
    filter: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SavedSearchMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    query: string | null
    filter: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type SavedSearchCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    query: number
    folderIds: number
    tagIds: number
    filter: number
    searchFields: number
    createdAt: number
    updatedAt: number
    lastUsedAt: number
    _all: number
  }


  export type SavedSearchMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    query?: true
    filter?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SavedSearchMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    query?: true
    filter?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type SavedSearchCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    query?: true
    folderIds?: true
    tagIds?: true
    filter?: true
    searchFields?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type SavedSearchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedSearch to aggregate.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedSearches
    **/
    _count?: true | SavedSearchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedSearchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedSearchMaxAggregateInputType
  }

  export type GetSavedSearchAggregateType<T extends SavedSearchAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedSearch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedSearch[P]>
      : GetScalarType<T[P], AggregateSavedSearch[P]>
  }




  export type SavedSearchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedSearchWhereInput
    orderBy?: SavedSearchOrderByWithAggregationInput | SavedSearchOrderByWithAggregationInput[]
    by: SavedSearchScalarFieldEnum[] | SavedSearchScalarFieldEnum
    having?: SavedSearchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedSearchCountAggregateInputType | true
    _min?: SavedSearchMinAggregateInputType
    _max?: SavedSearchMaxAggregateInputType
  }

  export type SavedSearchGroupByOutputType = {
    id: string
    userId: string
    name: string
    query: string | null
    folderIds: string[]
    tagIds: string[]
    filter: string | null
    searchFields: string[]
    createdAt: Date
    updatedAt: Date
    lastUsedAt: Date | null
    _count: SavedSearchCountAggregateOutputType | null
    _min: SavedSearchMinAggregateOutputType | null
    _max: SavedSearchMaxAggregateOutputType | null
  }

  type GetSavedSearchGroupByPayload<T extends SavedSearchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedSearchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedSearchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedSearchGroupByOutputType[P]>
            : GetScalarType<T[P], SavedSearchGroupByOutputType[P]>
        }
      >
    >


  export type SavedSearchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedSearch"]>

  export type SavedSearchSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }

  export type SavedSearchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "query" | "folderIds" | "tagIds" | "filter" | "searchFields" | "createdAt" | "updatedAt" | "lastUsedAt", ExtArgs["result"]["savedSearch"]>
  export type SavedSearchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedSearchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedSearchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavedSearchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedSearch"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      query: string | null
      folderIds: string[]
      tagIds: string[]
      filter: string | null
      searchFields: string[]
      createdAt: Date
      updatedAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["savedSearch"]>
    composites: {}
  }

  type SavedSearchGetPayload<S extends boolean | null | undefined | SavedSearchDefaultArgs> = $Result.GetResult<Prisma.$SavedSearchPayload, S>

  type SavedSearchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedSearchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedSearchCountAggregateInputType | true
    }

  export interface SavedSearchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedSearch'], meta: { name: 'SavedSearch' } }
    /**
     * Find zero or one SavedSearch that matches the filter.
     * @param {SavedSearchFindUniqueArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedSearchFindUniqueArgs>(args: SelectSubset<T, SavedSearchFindUniqueArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedSearch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedSearchFindUniqueOrThrowArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedSearchFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedSearchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedSearch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindFirstArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedSearchFindFirstArgs>(args?: SelectSubset<T, SavedSearchFindFirstArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedSearch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindFirstOrThrowArgs} args - Arguments to find a SavedSearch
     * @example
     * // Get one SavedSearch
     * const savedSearch = await prisma.savedSearch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedSearchFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedSearchFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedSearches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedSearches
     * const savedSearches = await prisma.savedSearch.findMany()
     * 
     * // Get first 10 SavedSearches
     * const savedSearches = await prisma.savedSearch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedSearchFindManyArgs>(args?: SelectSubset<T, SavedSearchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedSearch.
     * @param {SavedSearchCreateArgs} args - Arguments to create a SavedSearch.
     * @example
     * // Create one SavedSearch
     * const SavedSearch = await prisma.savedSearch.create({
     *   data: {
     *     // ... data to create a SavedSearch
     *   }
     * })
     * 
     */
    create<T extends SavedSearchCreateArgs>(args: SelectSubset<T, SavedSearchCreateArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedSearches.
     * @param {SavedSearchCreateManyArgs} args - Arguments to create many SavedSearches.
     * @example
     * // Create many SavedSearches
     * const savedSearch = await prisma.savedSearch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedSearchCreateManyArgs>(args?: SelectSubset<T, SavedSearchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedSearches and returns the data saved in the database.
     * @param {SavedSearchCreateManyAndReturnArgs} args - Arguments to create many SavedSearches.
     * @example
     * // Create many SavedSearches
     * const savedSearch = await prisma.savedSearch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedSearches and only return the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedSearchCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedSearchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedSearch.
     * @param {SavedSearchDeleteArgs} args - Arguments to delete one SavedSearch.
     * @example
     * // Delete one SavedSearch
     * const SavedSearch = await prisma.savedSearch.delete({
     *   where: {
     *     // ... filter to delete one SavedSearch
     *   }
     * })
     * 
     */
    delete<T extends SavedSearchDeleteArgs>(args: SelectSubset<T, SavedSearchDeleteArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedSearch.
     * @param {SavedSearchUpdateArgs} args - Arguments to update one SavedSearch.
     * @example
     * // Update one SavedSearch
     * const savedSearch = await prisma.savedSearch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedSearchUpdateArgs>(args: SelectSubset<T, SavedSearchUpdateArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedSearches.
     * @param {SavedSearchDeleteManyArgs} args - Arguments to filter SavedSearches to delete.
     * @example
     * // Delete a few SavedSearches
     * const { count } = await prisma.savedSearch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedSearchDeleteManyArgs>(args?: SelectSubset<T, SavedSearchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedSearches
     * const savedSearch = await prisma.savedSearch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedSearchUpdateManyArgs>(args: SelectSubset<T, SavedSearchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedSearches and returns the data updated in the database.
     * @param {SavedSearchUpdateManyAndReturnArgs} args - Arguments to update many SavedSearches.
     * @example
     * // Update many SavedSearches
     * const savedSearch = await prisma.savedSearch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedSearches and only return the `id`
     * const savedSearchWithIdOnly = await prisma.savedSearch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedSearchUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedSearchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedSearch.
     * @param {SavedSearchUpsertArgs} args - Arguments to update or create a SavedSearch.
     * @example
     * // Update or create a SavedSearch
     * const savedSearch = await prisma.savedSearch.upsert({
     *   create: {
     *     // ... data to create a SavedSearch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedSearch we want to update
     *   }
     * })
     */
    upsert<T extends SavedSearchUpsertArgs>(args: SelectSubset<T, SavedSearchUpsertArgs<ExtArgs>>): Prisma__SavedSearchClient<$Result.GetResult<Prisma.$SavedSearchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchCountArgs} args - Arguments to filter SavedSearches to count.
     * @example
     * // Count the number of SavedSearches
     * const count = await prisma.savedSearch.count({
     *   where: {
     *     // ... the filter for the SavedSearches we want to count
     *   }
     * })
    **/
    count<T extends SavedSearchCountArgs>(
      args?: Subset<T, SavedSearchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedSearchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedSearchAggregateArgs>(args: Subset<T, SavedSearchAggregateArgs>): Prisma.PrismaPromise<GetSavedSearchAggregateType<T>>

    /**
     * Group by SavedSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedSearchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedSearchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedSearchGroupByArgs['orderBy'] }
        : { orderBy?: SavedSearchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedSearchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedSearchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedSearch model
   */
  readonly fields: SavedSearchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedSearch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedSearchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedSearch model
   */
  interface SavedSearchFieldRefs {
    readonly id: FieldRef<"SavedSearch", 'String'>
    readonly userId: FieldRef<"SavedSearch", 'String'>
    readonly name: FieldRef<"SavedSearch", 'String'>
    readonly query: FieldRef<"SavedSearch", 'String'>
    readonly folderIds: FieldRef<"SavedSearch", 'String[]'>
    readonly tagIds: FieldRef<"SavedSearch", 'String[]'>
    readonly filter: FieldRef<"SavedSearch", 'String'>
    readonly searchFields: FieldRef<"SavedSearch", 'String[]'>
    readonly createdAt: FieldRef<"SavedSearch", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedSearch", 'DateTime'>
    readonly lastUsedAt: FieldRef<"SavedSearch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedSearch findUnique
   */
  export type SavedSearchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch findUniqueOrThrow
   */
  export type SavedSearchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch findFirst
   */
  export type SavedSearchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedSearches.
     */
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch findFirstOrThrow
   */
  export type SavedSearchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearch to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedSearches.
     */
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch findMany
   */
  export type SavedSearchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter, which SavedSearches to fetch.
     */
    where?: SavedSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedSearches to fetch.
     */
    orderBy?: SavedSearchOrderByWithRelationInput | SavedSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedSearches.
     */
    cursor?: SavedSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedSearches.
     */
    skip?: number
    distinct?: SavedSearchScalarFieldEnum | SavedSearchScalarFieldEnum[]
  }

  /**
   * SavedSearch create
   */
  export type SavedSearchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedSearch.
     */
    data: XOR<SavedSearchCreateInput, SavedSearchUncheckedCreateInput>
  }

  /**
   * SavedSearch createMany
   */
  export type SavedSearchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedSearches.
     */
    data: SavedSearchCreateManyInput | SavedSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedSearch createManyAndReturn
   */
  export type SavedSearchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * The data used to create many SavedSearches.
     */
    data: SavedSearchCreateManyInput | SavedSearchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedSearch update
   */
  export type SavedSearchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedSearch.
     */
    data: XOR<SavedSearchUpdateInput, SavedSearchUncheckedUpdateInput>
    /**
     * Choose, which SavedSearch to update.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch updateMany
   */
  export type SavedSearchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedSearches.
     */
    data: XOR<SavedSearchUpdateManyMutationInput, SavedSearchUncheckedUpdateManyInput>
    /**
     * Filter which SavedSearches to update
     */
    where?: SavedSearchWhereInput
    /**
     * Limit how many SavedSearches to update.
     */
    limit?: number
  }

  /**
   * SavedSearch updateManyAndReturn
   */
  export type SavedSearchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * The data used to update SavedSearches.
     */
    data: XOR<SavedSearchUpdateManyMutationInput, SavedSearchUncheckedUpdateManyInput>
    /**
     * Filter which SavedSearches to update
     */
    where?: SavedSearchWhereInput
    /**
     * Limit how many SavedSearches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedSearch upsert
   */
  export type SavedSearchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedSearch to update in case it exists.
     */
    where: SavedSearchWhereUniqueInput
    /**
     * In case the SavedSearch found by the `where` argument doesn't exist, create a new SavedSearch with this data.
     */
    create: XOR<SavedSearchCreateInput, SavedSearchUncheckedCreateInput>
    /**
     * In case the SavedSearch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedSearchUpdateInput, SavedSearchUncheckedUpdateInput>
  }

  /**
   * SavedSearch delete
   */
  export type SavedSearchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
    /**
     * Filter which SavedSearch to delete.
     */
    where: SavedSearchWhereUniqueInput
  }

  /**
   * SavedSearch deleteMany
   */
  export type SavedSearchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedSearches to delete
     */
    where?: SavedSearchWhereInput
    /**
     * Limit how many SavedSearches to delete.
     */
    limit?: number
  }

  /**
   * SavedSearch without action
   */
  export type SavedSearchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedSearch
     */
    select?: SavedSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedSearch
     */
    omit?: SavedSearchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedSearchInclude<ExtArgs> | null
  }


  /**
   * Model SearchHistory
   */

  export type AggregateSearchHistory = {
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  export type SearchHistoryAvgAggregateOutputType = {
    resultCount: number | null
  }

  export type SearchHistorySumAggregateOutputType = {
    resultCount: number | null
  }

  export type SearchHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    query: string | null
    filter: string | null
    resultCount: number | null
    createdAt: Date | null
  }

  export type SearchHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    query: string | null
    filter: string | null
    resultCount: number | null
    createdAt: Date | null
  }

  export type SearchHistoryCountAggregateOutputType = {
    id: number
    userId: number
    query: number
    folderIds: number
    tagIds: number
    filter: number
    searchFields: number
    resultCount: number
    createdAt: number
    _all: number
  }


  export type SearchHistoryAvgAggregateInputType = {
    resultCount?: true
  }

  export type SearchHistorySumAggregateInputType = {
    resultCount?: true
  }

  export type SearchHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    filter?: true
    resultCount?: true
    createdAt?: true
  }

  export type SearchHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    filter?: true
    resultCount?: true
    createdAt?: true
  }

  export type SearchHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    folderIds?: true
    tagIds?: true
    filter?: true
    searchFields?: true
    resultCount?: true
    createdAt?: true
    _all?: true
  }

  export type SearchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistory to aggregate.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchHistories
    **/
    _count?: true | SearchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type GetSearchHistoryAggregateType<T extends SearchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchHistory[P]>
      : GetScalarType<T[P], AggregateSearchHistory[P]>
  }




  export type SearchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithAggregationInput | SearchHistoryOrderByWithAggregationInput[]
    by: SearchHistoryScalarFieldEnum[] | SearchHistoryScalarFieldEnum
    having?: SearchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchHistoryCountAggregateInputType | true
    _avg?: SearchHistoryAvgAggregateInputType
    _sum?: SearchHistorySumAggregateInputType
    _min?: SearchHistoryMinAggregateInputType
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type SearchHistoryGroupByOutputType = {
    id: string
    userId: string
    query: string | null
    folderIds: string[]
    tagIds: string[]
    filter: string | null
    searchFields: string[]
    resultCount: number | null
    createdAt: Date
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  type GetSearchHistoryGroupByPayload<T extends SearchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SearchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    query?: boolean
    folderIds?: boolean
    tagIds?: boolean
    filter?: boolean
    searchFields?: boolean
    resultCount?: boolean
    createdAt?: boolean
  }

  export type SearchHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "query" | "folderIds" | "tagIds" | "filter" | "searchFields" | "resultCount" | "createdAt", ExtArgs["result"]["searchHistory"]>
  export type SearchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      query: string | null
      folderIds: string[]
      tagIds: string[]
      filter: string | null
      searchFields: string[]
      resultCount: number | null
      createdAt: Date
    }, ExtArgs["result"]["searchHistory"]>
    composites: {}
  }

  type SearchHistoryGetPayload<S extends boolean | null | undefined | SearchHistoryDefaultArgs> = $Result.GetResult<Prisma.$SearchHistoryPayload, S>

  type SearchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchHistoryCountAggregateInputType | true
    }

  export interface SearchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchHistory'], meta: { name: 'SearchHistory' } }
    /**
     * Find zero or one SearchHistory that matches the filter.
     * @param {SearchHistoryFindUniqueArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchHistoryFindUniqueArgs>(args: SelectSubset<T, SearchHistoryFindUniqueArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchHistoryFindUniqueOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchHistoryFindFirstArgs>(args?: SelectSubset<T, SearchHistoryFindFirstArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany()
     * 
     * // Get first 10 SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchHistoryFindManyArgs>(args?: SelectSubset<T, SearchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchHistory.
     * @param {SearchHistoryCreateArgs} args - Arguments to create a SearchHistory.
     * @example
     * // Create one SearchHistory
     * const SearchHistory = await prisma.searchHistory.create({
     *   data: {
     *     // ... data to create a SearchHistory
     *   }
     * })
     * 
     */
    create<T extends SearchHistoryCreateArgs>(args: SelectSubset<T, SearchHistoryCreateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchHistories.
     * @param {SearchHistoryCreateManyArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchHistoryCreateManyArgs>(args?: SelectSubset<T, SearchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchHistories and returns the data saved in the database.
     * @param {SearchHistoryCreateManyAndReturnArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchHistory.
     * @param {SearchHistoryDeleteArgs} args - Arguments to delete one SearchHistory.
     * @example
     * // Delete one SearchHistory
     * const SearchHistory = await prisma.searchHistory.delete({
     *   where: {
     *     // ... filter to delete one SearchHistory
     *   }
     * })
     * 
     */
    delete<T extends SearchHistoryDeleteArgs>(args: SelectSubset<T, SearchHistoryDeleteArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchHistory.
     * @param {SearchHistoryUpdateArgs} args - Arguments to update one SearchHistory.
     * @example
     * // Update one SearchHistory
     * const searchHistory = await prisma.searchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchHistoryUpdateArgs>(args: SelectSubset<T, SearchHistoryUpdateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchHistories.
     * @param {SearchHistoryDeleteManyArgs} args - Arguments to filter SearchHistories to delete.
     * @example
     * // Delete a few SearchHistories
     * const { count } = await prisma.searchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchHistoryDeleteManyArgs>(args?: SelectSubset<T, SearchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchHistoryUpdateManyArgs>(args: SelectSubset<T, SearchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories and returns the data updated in the database.
     * @param {SearchHistoryUpdateManyAndReturnArgs} args - Arguments to update many SearchHistories.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchHistory.
     * @param {SearchHistoryUpsertArgs} args - Arguments to update or create a SearchHistory.
     * @example
     * // Update or create a SearchHistory
     * const searchHistory = await prisma.searchHistory.upsert({
     *   create: {
     *     // ... data to create a SearchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchHistory we want to update
     *   }
     * })
     */
    upsert<T extends SearchHistoryUpsertArgs>(args: SelectSubset<T, SearchHistoryUpsertArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryCountArgs} args - Arguments to filter SearchHistories to count.
     * @example
     * // Count the number of SearchHistories
     * const count = await prisma.searchHistory.count({
     *   where: {
     *     // ... the filter for the SearchHistories we want to count
     *   }
     * })
    **/
    count<T extends SearchHistoryCountArgs>(
      args?: Subset<T, SearchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchHistoryAggregateArgs>(args: Subset<T, SearchHistoryAggregateArgs>): Prisma.PrismaPromise<GetSearchHistoryAggregateType<T>>

    /**
     * Group by SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SearchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchHistory model
   */
  readonly fields: SearchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchHistory model
   */
  interface SearchHistoryFieldRefs {
    readonly id: FieldRef<"SearchHistory", 'String'>
    readonly userId: FieldRef<"SearchHistory", 'String'>
    readonly query: FieldRef<"SearchHistory", 'String'>
    readonly folderIds: FieldRef<"SearchHistory", 'String[]'>
    readonly tagIds: FieldRef<"SearchHistory", 'String[]'>
    readonly filter: FieldRef<"SearchHistory", 'String'>
    readonly searchFields: FieldRef<"SearchHistory", 'String[]'>
    readonly resultCount: FieldRef<"SearchHistory", 'Int'>
    readonly createdAt: FieldRef<"SearchHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchHistory findUnique
   */
  export type SearchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findUniqueOrThrow
   */
  export type SearchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findFirst
   */
  export type SearchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findFirstOrThrow
   */
  export type SearchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findMany
   */
  export type SearchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistories to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory create
   */
  export type SearchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchHistory.
     */
    data: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
  }

  /**
   * SearchHistory createMany
   */
  export type SearchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchHistory createManyAndReturn
   */
  export type SearchHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory update
   */
  export type SearchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchHistory.
     */
    data: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
    /**
     * Choose, which SearchHistory to update.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory updateMany
   */
  export type SearchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to update.
     */
    limit?: number
  }

  /**
   * SearchHistory updateManyAndReturn
   */
  export type SearchHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory upsert
   */
  export type SearchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchHistory to update in case it exists.
     */
    where: SearchHistoryWhereUniqueInput
    /**
     * In case the SearchHistory found by the `where` argument doesn't exist, create a new SearchHistory with this data.
     */
    create: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
    /**
     * In case the SearchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
  }

  /**
   * SearchHistory delete
   */
  export type SearchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter which SearchHistory to delete.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory deleteMany
   */
  export type SearchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistories to delete
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to delete.
     */
    limit?: number
  }

  /**
   * SearchHistory without action
   */
  export type SearchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PasswordTemplate
   */

  export type AggregatePasswordTemplate = {
    _count: PasswordTemplateCountAggregateOutputType | null
    _avg: PasswordTemplateAvgAggregateOutputType | null
    _sum: PasswordTemplateSumAggregateOutputType | null
    _min: PasswordTemplateMinAggregateOutputType | null
    _max: PasswordTemplateMaxAggregateOutputType | null
  }

  export type PasswordTemplateAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type PasswordTemplateSumAggregateOutputType = {
    usageCount: number | null
  }

  export type PasswordTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    service: string | null
    icon: string | null
    category: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    ownerId: string | null
    companyId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    service: string | null
    icon: string | null
    category: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    ownerId: string | null
    companyId: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    service: number
    icon: number
    category: number
    isSystem: number
    isPublic: number
    ownerId: number
    companyId: number
    defaultFields: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordTemplateAvgAggregateInputType = {
    usageCount?: true
  }

  export type PasswordTemplateSumAggregateInputType = {
    usageCount?: true
  }

  export type PasswordTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service?: true
    icon?: true
    category?: true
    isSystem?: true
    isPublic?: true
    ownerId?: true
    companyId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service?: true
    icon?: true
    category?: true
    isSystem?: true
    isPublic?: true
    ownerId?: true
    companyId?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service?: true
    icon?: true
    category?: true
    isSystem?: true
    isPublic?: true
    ownerId?: true
    companyId?: true
    defaultFields?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTemplate to aggregate.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordTemplates
    **/
    _count?: true | PasswordTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordTemplateMaxAggregateInputType
  }

  export type GetPasswordTemplateAggregateType<T extends PasswordTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordTemplate[P]>
      : GetScalarType<T[P], AggregatePasswordTemplate[P]>
  }




  export type PasswordTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordTemplateWhereInput
    orderBy?: PasswordTemplateOrderByWithAggregationInput | PasswordTemplateOrderByWithAggregationInput[]
    by: PasswordTemplateScalarFieldEnum[] | PasswordTemplateScalarFieldEnum
    having?: PasswordTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordTemplateCountAggregateInputType | true
    _avg?: PasswordTemplateAvgAggregateInputType
    _sum?: PasswordTemplateSumAggregateInputType
    _min?: PasswordTemplateMinAggregateInputType
    _max?: PasswordTemplateMaxAggregateInputType
  }

  export type PasswordTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    service: string | null
    icon: string | null
    category: string | null
    isSystem: boolean
    isPublic: boolean
    ownerId: string | null
    companyId: string | null
    defaultFields: JsonValue
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: PasswordTemplateCountAggregateOutputType | null
    _avg: PasswordTemplateAvgAggregateOutputType | null
    _sum: PasswordTemplateSumAggregateOutputType | null
    _min: PasswordTemplateMinAggregateOutputType | null
    _max: PasswordTemplateMaxAggregateOutputType | null
  }

  type GetPasswordTemplateGroupByPayload<T extends PasswordTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordTemplateGroupByOutputType[P]>
        }
      >
    >


  export type PasswordTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTemplate"]>

  export type PasswordTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTemplate"]>

  export type PasswordTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }, ExtArgs["result"]["passwordTemplate"]>

  export type PasswordTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    icon?: boolean
    category?: boolean
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: boolean
    companyId?: boolean
    defaultFields?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "service" | "icon" | "category" | "isSystem" | "isPublic" | "ownerId" | "companyId" | "defaultFields" | "usageCount" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordTemplate"]>
  export type PasswordTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }
  export type PasswordTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }
  export type PasswordTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PasswordTemplate$ownerArgs<ExtArgs>
    company?: boolean | PasswordTemplate$companyArgs<ExtArgs>
  }

  export type $PasswordTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordTemplate"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      service: string | null
      icon: string | null
      category: string | null
      isSystem: boolean
      isPublic: boolean
      ownerId: string | null
      companyId: string | null
      defaultFields: Prisma.JsonValue
      usageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordTemplate"]>
    composites: {}
  }

  type PasswordTemplateGetPayload<S extends boolean | null | undefined | PasswordTemplateDefaultArgs> = $Result.GetResult<Prisma.$PasswordTemplatePayload, S>

  type PasswordTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordTemplateCountAggregateInputType | true
    }

  export interface PasswordTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordTemplate'], meta: { name: 'PasswordTemplate' } }
    /**
     * Find zero or one PasswordTemplate that matches the filter.
     * @param {PasswordTemplateFindUniqueArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordTemplateFindUniqueArgs>(args: SelectSubset<T, PasswordTemplateFindUniqueArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordTemplateFindUniqueOrThrowArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateFindFirstArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordTemplateFindFirstArgs>(args?: SelectSubset<T, PasswordTemplateFindFirstArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateFindFirstOrThrowArgs} args - Arguments to find a PasswordTemplate
     * @example
     * // Get one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordTemplates
     * const passwordTemplates = await prisma.passwordTemplate.findMany()
     * 
     * // Get first 10 PasswordTemplates
     * const passwordTemplates = await prisma.passwordTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordTemplateWithIdOnly = await prisma.passwordTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordTemplateFindManyArgs>(args?: SelectSubset<T, PasswordTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordTemplate.
     * @param {PasswordTemplateCreateArgs} args - Arguments to create a PasswordTemplate.
     * @example
     * // Create one PasswordTemplate
     * const PasswordTemplate = await prisma.passwordTemplate.create({
     *   data: {
     *     // ... data to create a PasswordTemplate
     *   }
     * })
     * 
     */
    create<T extends PasswordTemplateCreateArgs>(args: SelectSubset<T, PasswordTemplateCreateArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordTemplates.
     * @param {PasswordTemplateCreateManyArgs} args - Arguments to create many PasswordTemplates.
     * @example
     * // Create many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordTemplateCreateManyArgs>(args?: SelectSubset<T, PasswordTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordTemplates and returns the data saved in the database.
     * @param {PasswordTemplateCreateManyAndReturnArgs} args - Arguments to create many PasswordTemplates.
     * @example
     * // Create many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordTemplates and only return the `id`
     * const passwordTemplateWithIdOnly = await prisma.passwordTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordTemplate.
     * @param {PasswordTemplateDeleteArgs} args - Arguments to delete one PasswordTemplate.
     * @example
     * // Delete one PasswordTemplate
     * const PasswordTemplate = await prisma.passwordTemplate.delete({
     *   where: {
     *     // ... filter to delete one PasswordTemplate
     *   }
     * })
     * 
     */
    delete<T extends PasswordTemplateDeleteArgs>(args: SelectSubset<T, PasswordTemplateDeleteArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordTemplate.
     * @param {PasswordTemplateUpdateArgs} args - Arguments to update one PasswordTemplate.
     * @example
     * // Update one PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordTemplateUpdateArgs>(args: SelectSubset<T, PasswordTemplateUpdateArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordTemplates.
     * @param {PasswordTemplateDeleteManyArgs} args - Arguments to filter PasswordTemplates to delete.
     * @example
     * // Delete a few PasswordTemplates
     * const { count } = await prisma.passwordTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordTemplateDeleteManyArgs>(args?: SelectSubset<T, PasswordTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordTemplateUpdateManyArgs>(args: SelectSubset<T, PasswordTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordTemplates and returns the data updated in the database.
     * @param {PasswordTemplateUpdateManyAndReturnArgs} args - Arguments to update many PasswordTemplates.
     * @example
     * // Update many PasswordTemplates
     * const passwordTemplate = await prisma.passwordTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordTemplates and only return the `id`
     * const passwordTemplateWithIdOnly = await prisma.passwordTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordTemplate.
     * @param {PasswordTemplateUpsertArgs} args - Arguments to update or create a PasswordTemplate.
     * @example
     * // Update or create a PasswordTemplate
     * const passwordTemplate = await prisma.passwordTemplate.upsert({
     *   create: {
     *     // ... data to create a PasswordTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordTemplate we want to update
     *   }
     * })
     */
    upsert<T extends PasswordTemplateUpsertArgs>(args: SelectSubset<T, PasswordTemplateUpsertArgs<ExtArgs>>): Prisma__PasswordTemplateClient<$Result.GetResult<Prisma.$PasswordTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateCountArgs} args - Arguments to filter PasswordTemplates to count.
     * @example
     * // Count the number of PasswordTemplates
     * const count = await prisma.passwordTemplate.count({
     *   where: {
     *     // ... the filter for the PasswordTemplates we want to count
     *   }
     * })
    **/
    count<T extends PasswordTemplateCountArgs>(
      args?: Subset<T, PasswordTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordTemplateAggregateArgs>(args: Subset<T, PasswordTemplateAggregateArgs>): Prisma.PrismaPromise<GetPasswordTemplateAggregateType<T>>

    /**
     * Group by PasswordTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordTemplateGroupByArgs['orderBy'] }
        : { orderBy?: PasswordTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordTemplate model
   */
  readonly fields: PasswordTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends PasswordTemplate$ownerArgs<ExtArgs> = {}>(args?: Subset<T, PasswordTemplate$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends PasswordTemplate$companyArgs<ExtArgs> = {}>(args?: Subset<T, PasswordTemplate$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordTemplate model
   */
  interface PasswordTemplateFieldRefs {
    readonly id: FieldRef<"PasswordTemplate", 'String'>
    readonly name: FieldRef<"PasswordTemplate", 'String'>
    readonly description: FieldRef<"PasswordTemplate", 'String'>
    readonly service: FieldRef<"PasswordTemplate", 'String'>
    readonly icon: FieldRef<"PasswordTemplate", 'String'>
    readonly category: FieldRef<"PasswordTemplate", 'String'>
    readonly isSystem: FieldRef<"PasswordTemplate", 'Boolean'>
    readonly isPublic: FieldRef<"PasswordTemplate", 'Boolean'>
    readonly ownerId: FieldRef<"PasswordTemplate", 'String'>
    readonly companyId: FieldRef<"PasswordTemplate", 'String'>
    readonly defaultFields: FieldRef<"PasswordTemplate", 'Json'>
    readonly usageCount: FieldRef<"PasswordTemplate", 'Int'>
    readonly createdAt: FieldRef<"PasswordTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordTemplate findUnique
   */
  export type PasswordTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate findUniqueOrThrow
   */
  export type PasswordTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate findFirst
   */
  export type PasswordTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTemplates.
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTemplates.
     */
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * PasswordTemplate findFirstOrThrow
   */
  export type PasswordTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplate to fetch.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordTemplates.
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordTemplates.
     */
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * PasswordTemplate findMany
   */
  export type PasswordTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PasswordTemplates to fetch.
     */
    where?: PasswordTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordTemplates to fetch.
     */
    orderBy?: PasswordTemplateOrderByWithRelationInput | PasswordTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordTemplates.
     */
    cursor?: PasswordTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordTemplates.
     */
    skip?: number
    distinct?: PasswordTemplateScalarFieldEnum | PasswordTemplateScalarFieldEnum[]
  }

  /**
   * PasswordTemplate create
   */
  export type PasswordTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordTemplate.
     */
    data: XOR<PasswordTemplateCreateInput, PasswordTemplateUncheckedCreateInput>
  }

  /**
   * PasswordTemplate createMany
   */
  export type PasswordTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordTemplates.
     */
    data: PasswordTemplateCreateManyInput | PasswordTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordTemplate createManyAndReturn
   */
  export type PasswordTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordTemplates.
     */
    data: PasswordTemplateCreateManyInput | PasswordTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTemplate update
   */
  export type PasswordTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordTemplate.
     */
    data: XOR<PasswordTemplateUpdateInput, PasswordTemplateUncheckedUpdateInput>
    /**
     * Choose, which PasswordTemplate to update.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate updateMany
   */
  export type PasswordTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordTemplates.
     */
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTemplates to update
     */
    where?: PasswordTemplateWhereInput
    /**
     * Limit how many PasswordTemplates to update.
     */
    limit?: number
  }

  /**
   * PasswordTemplate updateManyAndReturn
   */
  export type PasswordTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * The data used to update PasswordTemplates.
     */
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PasswordTemplates to update
     */
    where?: PasswordTemplateWhereInput
    /**
     * Limit how many PasswordTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordTemplate upsert
   */
  export type PasswordTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordTemplate to update in case it exists.
     */
    where: PasswordTemplateWhereUniqueInput
    /**
     * In case the PasswordTemplate found by the `where` argument doesn't exist, create a new PasswordTemplate with this data.
     */
    create: XOR<PasswordTemplateCreateInput, PasswordTemplateUncheckedCreateInput>
    /**
     * In case the PasswordTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordTemplateUpdateInput, PasswordTemplateUncheckedUpdateInput>
  }

  /**
   * PasswordTemplate delete
   */
  export type PasswordTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
    /**
     * Filter which PasswordTemplate to delete.
     */
    where: PasswordTemplateWhereUniqueInput
  }

  /**
   * PasswordTemplate deleteMany
   */
  export type PasswordTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordTemplates to delete
     */
    where?: PasswordTemplateWhereInput
    /**
     * Limit how many PasswordTemplates to delete.
     */
    limit?: number
  }

  /**
   * PasswordTemplate.owner
   */
  export type PasswordTemplate$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PasswordTemplate.company
   */
  export type PasswordTemplate$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * PasswordTemplate without action
   */
  export type PasswordTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordTemplate
     */
    select?: PasswordTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordTemplate
     */
    omit?: PasswordTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordTemplateInclude<ExtArgs> | null
  }


  /**
   * Model EmailVerificationToken
   */

  export type AggregateEmailVerificationToken = {
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  export type EmailVerificationTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type EmailVerificationTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    email: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type EmailVerificationTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    createdAt?: true
  }

  export type EmailVerificationTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    createdAt?: true
  }

  export type EmailVerificationTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type EmailVerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationToken to aggregate.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerificationTokens
    **/
    _count?: true | EmailVerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type GetEmailVerificationTokenAggregateType<T extends EmailVerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
      : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
  }




  export type EmailVerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationTokenWhereInput
    orderBy?: EmailVerificationTokenOrderByWithAggregationInput | EmailVerificationTokenOrderByWithAggregationInput[]
    by: EmailVerificationTokenScalarFieldEnum[] | EmailVerificationTokenScalarFieldEnum
    having?: EmailVerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailVerificationTokenCountAggregateInputType | true
    _min?: EmailVerificationTokenMinAggregateInputType
    _max?: EmailVerificationTokenMaxAggregateInputType
  }

  export type EmailVerificationTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    email: string
    expiresAt: Date
    createdAt: Date
    _count: EmailVerificationTokenCountAggregateOutputType | null
    _min: EmailVerificationTokenMinAggregateOutputType | null
    _max: EmailVerificationTokenMaxAggregateOutputType | null
  }

  type GetEmailVerificationTokenGroupByPayload<T extends EmailVerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerificationToken"]>

  export type EmailVerificationTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type EmailVerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "email" | "expiresAt" | "createdAt", ExtArgs["result"]["emailVerificationToken"]>
  export type EmailVerificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailVerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerificationToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      email: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["emailVerificationToken"]>
    composites: {}
  }

  type EmailVerificationTokenGetPayload<S extends boolean | null | undefined | EmailVerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationTokenPayload, S>

  type EmailVerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailVerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailVerificationTokenCountAggregateInputType | true
    }

  export interface EmailVerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerificationToken'], meta: { name: 'EmailVerificationToken' } }
    /**
     * Find zero or one EmailVerificationToken that matches the filter.
     * @param {EmailVerificationTokenFindUniqueArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationTokenFindUniqueArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailVerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationTokenFindFirstArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailVerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
     * 
     * // Get first 10 EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationTokenFindManyArgs>(args?: SelectSubset<T, EmailVerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailVerificationToken.
     * @param {EmailVerificationTokenCreateArgs} args - Arguments to create a EmailVerificationToken.
     * @example
     * // Create one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.create({
     *   data: {
     *     // ... data to create a EmailVerificationToken
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationTokenCreateArgs>(args: SelectSubset<T, EmailVerificationTokenCreateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailVerificationTokens.
     * @param {EmailVerificationTokenCreateManyArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationTokenCreateManyArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailVerificationTokens and returns the data saved in the database.
     * @param {EmailVerificationTokenCreateManyAndReturnArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailVerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailVerificationToken.
     * @param {EmailVerificationTokenDeleteArgs} args - Arguments to delete one EmailVerificationToken.
     * @example
     * // Delete one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.delete({
     *   where: {
     *     // ... filter to delete one EmailVerificationToken
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationTokenDeleteArgs>(args: SelectSubset<T, EmailVerificationTokenDeleteArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpdateArgs} args - Arguments to update one EmailVerificationToken.
     * @example
     * // Update one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationTokenUpdateArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailVerificationTokens.
     * @param {EmailVerificationTokenDeleteManyArgs} args - Arguments to filter EmailVerificationTokens to delete.
     * @example
     * // Delete a few EmailVerificationTokens
     * const { count } = await prisma.emailVerificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationTokenDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationTokenUpdateManyArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerificationTokens and returns the data updated in the database.
     * @param {EmailVerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many EmailVerificationTokens.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailVerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpsertArgs} args - Arguments to update or create a EmailVerificationToken.
     * @example
     * // Update or create a EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.upsert({
     *   create: {
     *     // ... data to create a EmailVerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationTokenUpsertArgs>(args: SelectSubset<T, EmailVerificationTokenUpsertArgs<ExtArgs>>): Prisma__EmailVerificationTokenClient<$Result.GetResult<Prisma.$EmailVerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenCountArgs} args - Arguments to filter EmailVerificationTokens to count.
     * @example
     * // Count the number of EmailVerificationTokens
     * const count = await prisma.emailVerificationToken.count({
     *   where: {
     *     // ... the filter for the EmailVerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationTokenCountArgs>(
      args?: Subset<T, EmailVerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationTokenAggregateArgs>(args: Subset<T, EmailVerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationTokenAggregateType<T>>

    /**
     * Group by EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerificationToken model
   */
  readonly fields: EmailVerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerificationToken model
   */
  interface EmailVerificationTokenFieldRefs {
    readonly id: FieldRef<"EmailVerificationToken", 'String'>
    readonly token: FieldRef<"EmailVerificationToken", 'String'>
    readonly userId: FieldRef<"EmailVerificationToken", 'String'>
    readonly email: FieldRef<"EmailVerificationToken", 'String'>
    readonly expiresAt: FieldRef<"EmailVerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"EmailVerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerificationToken findUnique
   */
  export type EmailVerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findUniqueOrThrow
   */
  export type EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken findFirst
   */
  export type EmailVerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken findFirstOrThrow
   */
  export type EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken findMany
   */
  export type EmailVerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerificationTokens to fetch.
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?: EmailVerificationTokenOrderByWithRelationInput | EmailVerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[]
  }

  /**
   * EmailVerificationToken create
   */
  export type EmailVerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
  }

  /**
   * EmailVerificationToken createMany
   */
  export type EmailVerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerificationToken createManyAndReturn
   */
  export type EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken update
   */
  export type EmailVerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which EmailVerificationToken to update.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken updateMany
   */
  export type EmailVerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number
  }

  /**
   * EmailVerificationToken updateManyAndReturn
   */
  export type EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerificationToken upsert
   */
  export type EmailVerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailVerificationToken to update in case it exists.
     */
    where: EmailVerificationTokenWhereUniqueInput
    /**
     * In case the EmailVerificationToken found by the `where` argument doesn't exist, create a new EmailVerificationToken with this data.
     */
    create: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>
    /**
     * In case the EmailVerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>
  }

  /**
   * EmailVerificationToken delete
   */
  export type EmailVerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
    /**
     * Filter which EmailVerificationToken to delete.
     */
    where: EmailVerificationTokenWhereUniqueInput
  }

  /**
   * EmailVerificationToken deleteMany
   */
  export type EmailVerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerificationTokens to delete
     */
    where?: EmailVerificationTokenWhereInput
    /**
     * Limit how many EmailVerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * EmailVerificationToken without action
   */
  export type EmailVerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    email: string | null
    expiresAt: Date | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    email: number
    expiresAt: number
    used: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    email?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    email: string
    expiresAt: Date
    used: boolean
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "email" | "expiresAt" | "used" | "usedAt" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      email: string
      expiresAt: Date
      used: boolean
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly used: FieldRef<"PasswordResetToken", 'Boolean'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model SecurityQuestion
   */

  export type AggregateSecurityQuestion = {
    _count: SecurityQuestionCountAggregateOutputType | null
    _min: SecurityQuestionMinAggregateOutputType | null
    _max: SecurityQuestionMaxAggregateOutputType | null
  }

  export type SecurityQuestionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    answerHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityQuestionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    answerHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityQuestionCountAggregateOutputType = {
    id: number
    userId: number
    question: number
    answerHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityQuestionMinAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityQuestionMaxAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityQuestionCountAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    answerHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityQuestion to aggregate.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityQuestions
    **/
    _count?: true | SecurityQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityQuestionMaxAggregateInputType
  }

  export type GetSecurityQuestionAggregateType<T extends SecurityQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityQuestion[P]>
      : GetScalarType<T[P], AggregateSecurityQuestion[P]>
  }




  export type SecurityQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityQuestionWhereInput
    orderBy?: SecurityQuestionOrderByWithAggregationInput | SecurityQuestionOrderByWithAggregationInput[]
    by: SecurityQuestionScalarFieldEnum[] | SecurityQuestionScalarFieldEnum
    having?: SecurityQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityQuestionCountAggregateInputType | true
    _min?: SecurityQuestionMinAggregateInputType
    _max?: SecurityQuestionMaxAggregateInputType
  }

  export type SecurityQuestionGroupByOutputType = {
    id: string
    userId: string
    question: string
    answerHash: string
    createdAt: Date
    updatedAt: Date
    _count: SecurityQuestionCountAggregateOutputType | null
    _min: SecurityQuestionMinAggregateOutputType | null
    _max: SecurityQuestionMaxAggregateOutputType | null
  }

  type GetSecurityQuestionGroupByPayload<T extends SecurityQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityQuestionGroupByOutputType[P]>
        }
      >
    >


  export type SecurityQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityQuestion"]>

  export type SecurityQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityQuestion"]>

  export type SecurityQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityQuestion"]>

  export type SecurityQuestionSelectScalar = {
    id?: boolean
    userId?: boolean
    question?: boolean
    answerHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecurityQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "question" | "answerHash" | "createdAt" | "updatedAt", ExtArgs["result"]["securityQuestion"]>
  export type SecurityQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SecurityQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SecurityQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SecurityQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityQuestion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      question: string
      answerHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["securityQuestion"]>
    composites: {}
  }

  type SecurityQuestionGetPayload<S extends boolean | null | undefined | SecurityQuestionDefaultArgs> = $Result.GetResult<Prisma.$SecurityQuestionPayload, S>

  type SecurityQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityQuestionCountAggregateInputType | true
    }

  export interface SecurityQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityQuestion'], meta: { name: 'SecurityQuestion' } }
    /**
     * Find zero or one SecurityQuestion that matches the filter.
     * @param {SecurityQuestionFindUniqueArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityQuestionFindUniqueArgs>(args: SelectSubset<T, SecurityQuestionFindUniqueArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityQuestionFindUniqueOrThrowArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionFindFirstArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityQuestionFindFirstArgs>(args?: SelectSubset<T, SecurityQuestionFindFirstArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionFindFirstOrThrowArgs} args - Arguments to find a SecurityQuestion
     * @example
     * // Get one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityQuestions
     * const securityQuestions = await prisma.securityQuestion.findMany()
     * 
     * // Get first 10 SecurityQuestions
     * const securityQuestions = await prisma.securityQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityQuestionWithIdOnly = await prisma.securityQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityQuestionFindManyArgs>(args?: SelectSubset<T, SecurityQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityQuestion.
     * @param {SecurityQuestionCreateArgs} args - Arguments to create a SecurityQuestion.
     * @example
     * // Create one SecurityQuestion
     * const SecurityQuestion = await prisma.securityQuestion.create({
     *   data: {
     *     // ... data to create a SecurityQuestion
     *   }
     * })
     * 
     */
    create<T extends SecurityQuestionCreateArgs>(args: SelectSubset<T, SecurityQuestionCreateArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityQuestions.
     * @param {SecurityQuestionCreateManyArgs} args - Arguments to create many SecurityQuestions.
     * @example
     * // Create many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityQuestionCreateManyArgs>(args?: SelectSubset<T, SecurityQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityQuestions and returns the data saved in the database.
     * @param {SecurityQuestionCreateManyAndReturnArgs} args - Arguments to create many SecurityQuestions.
     * @example
     * // Create many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityQuestions and only return the `id`
     * const securityQuestionWithIdOnly = await prisma.securityQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityQuestion.
     * @param {SecurityQuestionDeleteArgs} args - Arguments to delete one SecurityQuestion.
     * @example
     * // Delete one SecurityQuestion
     * const SecurityQuestion = await prisma.securityQuestion.delete({
     *   where: {
     *     // ... filter to delete one SecurityQuestion
     *   }
     * })
     * 
     */
    delete<T extends SecurityQuestionDeleteArgs>(args: SelectSubset<T, SecurityQuestionDeleteArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityQuestion.
     * @param {SecurityQuestionUpdateArgs} args - Arguments to update one SecurityQuestion.
     * @example
     * // Update one SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityQuestionUpdateArgs>(args: SelectSubset<T, SecurityQuestionUpdateArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityQuestions.
     * @param {SecurityQuestionDeleteManyArgs} args - Arguments to filter SecurityQuestions to delete.
     * @example
     * // Delete a few SecurityQuestions
     * const { count } = await prisma.securityQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityQuestionDeleteManyArgs>(args?: SelectSubset<T, SecurityQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityQuestionUpdateManyArgs>(args: SelectSubset<T, SecurityQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityQuestions and returns the data updated in the database.
     * @param {SecurityQuestionUpdateManyAndReturnArgs} args - Arguments to update many SecurityQuestions.
     * @example
     * // Update many SecurityQuestions
     * const securityQuestion = await prisma.securityQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityQuestions and only return the `id`
     * const securityQuestionWithIdOnly = await prisma.securityQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityQuestion.
     * @param {SecurityQuestionUpsertArgs} args - Arguments to update or create a SecurityQuestion.
     * @example
     * // Update or create a SecurityQuestion
     * const securityQuestion = await prisma.securityQuestion.upsert({
     *   create: {
     *     // ... data to create a SecurityQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityQuestion we want to update
     *   }
     * })
     */
    upsert<T extends SecurityQuestionUpsertArgs>(args: SelectSubset<T, SecurityQuestionUpsertArgs<ExtArgs>>): Prisma__SecurityQuestionClient<$Result.GetResult<Prisma.$SecurityQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionCountArgs} args - Arguments to filter SecurityQuestions to count.
     * @example
     * // Count the number of SecurityQuestions
     * const count = await prisma.securityQuestion.count({
     *   where: {
     *     // ... the filter for the SecurityQuestions we want to count
     *   }
     * })
    **/
    count<T extends SecurityQuestionCountArgs>(
      args?: Subset<T, SecurityQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityQuestionAggregateArgs>(args: Subset<T, SecurityQuestionAggregateArgs>): Prisma.PrismaPromise<GetSecurityQuestionAggregateType<T>>

    /**
     * Group by SecurityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityQuestionGroupByArgs['orderBy'] }
        : { orderBy?: SecurityQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityQuestion model
   */
  readonly fields: SecurityQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityQuestion model
   */
  interface SecurityQuestionFieldRefs {
    readonly id: FieldRef<"SecurityQuestion", 'String'>
    readonly userId: FieldRef<"SecurityQuestion", 'String'>
    readonly question: FieldRef<"SecurityQuestion", 'String'>
    readonly answerHash: FieldRef<"SecurityQuestion", 'String'>
    readonly createdAt: FieldRef<"SecurityQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"SecurityQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityQuestion findUnique
   */
  export type SecurityQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion findUniqueOrThrow
   */
  export type SecurityQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion findFirst
   */
  export type SecurityQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityQuestions.
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityQuestions.
     */
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * SecurityQuestion findFirstOrThrow
   */
  export type SecurityQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestion to fetch.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityQuestions.
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityQuestions.
     */
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * SecurityQuestion findMany
   */
  export type SecurityQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SecurityQuestions to fetch.
     */
    where?: SecurityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityQuestions to fetch.
     */
    orderBy?: SecurityQuestionOrderByWithRelationInput | SecurityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityQuestions.
     */
    cursor?: SecurityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityQuestions.
     */
    skip?: number
    distinct?: SecurityQuestionScalarFieldEnum | SecurityQuestionScalarFieldEnum[]
  }

  /**
   * SecurityQuestion create
   */
  export type SecurityQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityQuestion.
     */
    data: XOR<SecurityQuestionCreateInput, SecurityQuestionUncheckedCreateInput>
  }

  /**
   * SecurityQuestion createMany
   */
  export type SecurityQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityQuestions.
     */
    data: SecurityQuestionCreateManyInput | SecurityQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityQuestion createManyAndReturn
   */
  export type SecurityQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityQuestions.
     */
    data: SecurityQuestionCreateManyInput | SecurityQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityQuestion update
   */
  export type SecurityQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityQuestion.
     */
    data: XOR<SecurityQuestionUpdateInput, SecurityQuestionUncheckedUpdateInput>
    /**
     * Choose, which SecurityQuestion to update.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion updateMany
   */
  export type SecurityQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityQuestions.
     */
    data: XOR<SecurityQuestionUpdateManyMutationInput, SecurityQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SecurityQuestions to update
     */
    where?: SecurityQuestionWhereInput
    /**
     * Limit how many SecurityQuestions to update.
     */
    limit?: number
  }

  /**
   * SecurityQuestion updateManyAndReturn
   */
  export type SecurityQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * The data used to update SecurityQuestions.
     */
    data: XOR<SecurityQuestionUpdateManyMutationInput, SecurityQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SecurityQuestions to update
     */
    where?: SecurityQuestionWhereInput
    /**
     * Limit how many SecurityQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityQuestion upsert
   */
  export type SecurityQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityQuestion to update in case it exists.
     */
    where: SecurityQuestionWhereUniqueInput
    /**
     * In case the SecurityQuestion found by the `where` argument doesn't exist, create a new SecurityQuestion with this data.
     */
    create: XOR<SecurityQuestionCreateInput, SecurityQuestionUncheckedCreateInput>
    /**
     * In case the SecurityQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityQuestionUpdateInput, SecurityQuestionUncheckedUpdateInput>
  }

  /**
   * SecurityQuestion delete
   */
  export type SecurityQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
    /**
     * Filter which SecurityQuestion to delete.
     */
    where: SecurityQuestionWhereUniqueInput
  }

  /**
   * SecurityQuestion deleteMany
   */
  export type SecurityQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityQuestions to delete
     */
    where?: SecurityQuestionWhereInput
    /**
     * Limit how many SecurityQuestions to delete.
     */
    limit?: number
  }

  /**
   * SecurityQuestion without action
   */
  export type SecurityQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityQuestion
     */
    select?: SecurityQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityQuestion
     */
    omit?: SecurityQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityQuestionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    recoveryEmail: 'recoveryEmail',
    recoveryEmailVerified: 'recoveryEmailVerified',
    image: 'image',
    password: 'password',
    phoneNumber: 'phoneNumber',
    bio: 'bio',
    preferences: 'preferences',
    role: 'role',
    isActive: 'isActive',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    mfaMethod: 'mfaMethod',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    createdById: 'createdById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceName: 'deviceName',
    deviceType: 'deviceType',
    isTrusted: 'isTrusted',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const PasswordScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    password: 'password',
    url: 'url',
    notes: 'notes',
    folderId: 'folderId',
    strength: 'strength',
    hasTotp: 'hasTotp',
    totpSecret: 'totpSecret',
    expiresAt: 'expiresAt',
    isFavorite: 'isFavorite',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rotationPolicyId: 'rotationPolicyId'
  };

  export type PasswordScalarFieldEnum = (typeof PasswordScalarFieldEnum)[keyof typeof PasswordScalarFieldEnum]


  export const PasswordHistoryScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    name: 'name',
    username: 'username',
    password: 'password',
    url: 'url',
    notes: 'notes',
    folderId: 'folderId',
    strength: 'strength',
    hasTotp: 'hasTotp',
    totpSecret: 'totpSecret',
    expiresAt: 'expiresAt',
    changedBy: 'changedBy',
    changeType: 'changeType',
    createdAt: 'createdAt'
  };

  export type PasswordHistoryScalarFieldEnum = (typeof PasswordHistoryScalarFieldEnum)[keyof typeof PasswordHistoryScalarFieldEnum]


  export const PasswordBreachScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    isBreached: 'isBreached',
    breachCount: 'breachCount',
    hashPrefix: 'hashPrefix',
    checkedAt: 'checkedAt',
    checkedBy: 'checkedBy',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy'
  };

  export type PasswordBreachScalarFieldEnum = (typeof PasswordBreachScalarFieldEnum)[keyof typeof PasswordBreachScalarFieldEnum]


  export const PasswordRotationPolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    rotationDays: 'rotationDays',
    reminderDays: 'reminderDays',
    autoRotate: 'autoRotate',
    requireApproval: 'requireApproval',
    isActive: 'isActive',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordRotationPolicyScalarFieldEnum = (typeof PasswordRotationPolicyScalarFieldEnum)[keyof typeof PasswordRotationPolicyScalarFieldEnum]


  export const PasswordRotationScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    policyId: 'policyId',
    rotationType: 'rotationType',
    oldPassword: 'oldPassword',
    newPassword: 'newPassword',
    rotatedAt: 'rotatedAt',
    rotatedBy: 'rotatedBy',
    scheduledFor: 'scheduledFor',
    completedAt: 'completedAt',
    status: 'status',
    notes: 'notes'
  };

  export type PasswordRotationScalarFieldEnum = (typeof PasswordRotationScalarFieldEnum)[keyof typeof PasswordRotationScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const PasswordShareScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    userId: 'userId',
    teamId: 'teamId',
    permission: 'permission',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type PasswordShareScalarFieldEnum = (typeof PasswordShareScalarFieldEnum)[keyof typeof PasswordShareScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    icon: 'icon',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PasswordTagScalarFieldEnum: {
    id: 'id',
    passwordId: 'passwordId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type PasswordTagScalarFieldEnum = (typeof PasswordTagScalarFieldEnum)[keyof typeof PasswordTagScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const MfaCredentialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    credentialId: 'credentialId',
    publicKey: 'publicKey',
    counter: 'counter',
    deviceType: 'deviceType',
    backedUp: 'backedUp',
    transports: 'transports',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type MfaCredentialScalarFieldEnum = (typeof MfaCredentialScalarFieldEnum)[keyof typeof MfaCredentialScalarFieldEnum]


  export const RecoveryCodeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    codeHash: 'codeHash',
    used: 'used',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type RecoveryCodeScalarFieldEnum = (typeof RecoveryCodeScalarFieldEnum)[keyof typeof RecoveryCodeScalarFieldEnum]


  export const SavedSearchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    query: 'query',
    folderIds: 'folderIds',
    tagIds: 'tagIds',
    filter: 'filter',
    searchFields: 'searchFields',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type SavedSearchScalarFieldEnum = (typeof SavedSearchScalarFieldEnum)[keyof typeof SavedSearchScalarFieldEnum]


  export const SearchHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    query: 'query',
    folderIds: 'folderIds',
    tagIds: 'tagIds',
    filter: 'filter',
    searchFields: 'searchFields',
    resultCount: 'resultCount',
    createdAt: 'createdAt'
  };

  export type SearchHistoryScalarFieldEnum = (typeof SearchHistoryScalarFieldEnum)[keyof typeof SearchHistoryScalarFieldEnum]


  export const PasswordTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    service: 'service',
    icon: 'icon',
    category: 'category',
    isSystem: 'isSystem',
    isPublic: 'isPublic',
    ownerId: 'ownerId',
    companyId: 'companyId',
    defaultFields: 'defaultFields',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordTemplateScalarFieldEnum = (typeof PasswordTemplateScalarFieldEnum)[keyof typeof PasswordTemplateScalarFieldEnum]


  export const EmailVerificationTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    email: 'email',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type EmailVerificationTokenScalarFieldEnum = (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    email: 'email',
    expiresAt: 'expiresAt',
    used: 'used',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const SecurityQuestionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    question: 'question',
    answerHash: 'answerHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityQuestionScalarFieldEnum = (typeof SecurityQuestionScalarFieldEnum)[keyof typeof SecurityQuestionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MfaMethod'
   */
  export type EnumMfaMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MfaMethod'>
    


  /**
   * Reference to a field of type 'MfaMethod[]'
   */
  export type ListEnumMfaMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MfaMethod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PasswordStrength'
   */
  export type EnumPasswordStrengthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PasswordStrength'>
    


  /**
   * Reference to a field of type 'PasswordStrength[]'
   */
  export type ListEnumPasswordStrengthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PasswordStrength[]'>
    


  /**
   * Reference to a field of type 'SharePermission'
   */
  export type EnumSharePermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SharePermission'>
    


  /**
   * Reference to a field of type 'SharePermission[]'
   */
  export type ListEnumSharePermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SharePermission[]'>
    


  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>
    


  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>
    


  /**
   * Reference to a field of type 'AuditStatus'
   */
  export type EnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus'>
    


  /**
   * Reference to a field of type 'AuditStatus[]'
   */
  export type ListEnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    subdomain?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    templates?: PasswordTemplateListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    templates?: PasswordTemplateOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    templates?: PasswordTemplateListRelationFilter
  }, "id" | "subdomain">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    subdomain?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    ownedPasswords?: PasswordListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    mfaCredentials?: MfaCredentialListRelationFilter
    recoveryCodes?: RecoveryCodeListRelationFilter
    passwordHistory?: PasswordHistoryListRelationFilter
    passwordBreachesChecked?: PasswordBreachListRelationFilter
    passwordBreachesResolved?: PasswordBreachListRelationFilter
    rotationPolicies?: PasswordRotationPolicyListRelationFilter
    passwordRotations?: PasswordRotationListRelationFilter
    savedSearches?: SavedSearchListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    passwordTemplates?: PasswordTemplateListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    createdRoles?: RoleListRelationFilter
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    securityQuestions?: SecurityQuestionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryEmailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaMethod?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    ownedPasswords?: PasswordOrderByRelationAggregateInput
    sharedPasswords?: PasswordShareOrderByRelationAggregateInput
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    mfaCredentials?: MfaCredentialOrderByRelationAggregateInput
    recoveryCodes?: RecoveryCodeOrderByRelationAggregateInput
    passwordHistory?: PasswordHistoryOrderByRelationAggregateInput
    passwordBreachesChecked?: PasswordBreachOrderByRelationAggregateInput
    passwordBreachesResolved?: PasswordBreachOrderByRelationAggregateInput
    rotationPolicies?: PasswordRotationPolicyOrderByRelationAggregateInput
    passwordRotations?: PasswordRotationOrderByRelationAggregateInput
    savedSearches?: SavedSearchOrderByRelationAggregateInput
    searchHistory?: SearchHistoryOrderByRelationAggregateInput
    passwordTemplates?: PasswordTemplateOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    createdRoles?: RoleOrderByRelationAggregateInput
    emailVerificationTokens?: EmailVerificationTokenOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    securityQuestions?: SecurityQuestionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: StringNullableFilter<"User"> | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    ownedPasswords?: PasswordListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    mfaCredentials?: MfaCredentialListRelationFilter
    recoveryCodes?: RecoveryCodeListRelationFilter
    passwordHistory?: PasswordHistoryListRelationFilter
    passwordBreachesChecked?: PasswordBreachListRelationFilter
    passwordBreachesResolved?: PasswordBreachListRelationFilter
    rotationPolicies?: PasswordRotationPolicyListRelationFilter
    passwordRotations?: PasswordRotationListRelationFilter
    savedSearches?: SavedSearchListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    passwordTemplates?: PasswordTemplateListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    createdRoles?: RoleListRelationFilter
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    securityQuestions?: SecurityQuestionListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryEmailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaMethod?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"User">
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    mfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableWithAggregatesFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    deviceType?: StringNullableFilter<"Session"> | string | null
    isTrusted?: BoolFilter<"Session"> | boolean
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    deviceType?: StringNullableFilter<"Session"> | string | null
    isTrusted?: BoolFilter<"Session"> | boolean
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    isTrusted?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"Session"> | string | null
    isTrusted?: BoolWithAggregatesFilter<"Session"> | boolean
    lastActiveAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type PasswordWhereInput = {
    AND?: PasswordWhereInput | PasswordWhereInput[]
    OR?: PasswordWhereInput[]
    NOT?: PasswordWhereInput | PasswordWhereInput[]
    id?: StringFilter<"Password"> | string
    name?: StringFilter<"Password"> | string
    username?: StringFilter<"Password"> | string
    password?: StringFilter<"Password"> | string
    url?: StringNullableFilter<"Password"> | string | null
    notes?: StringNullableFilter<"Password"> | string | null
    folderId?: StringNullableFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"Password"> | boolean
    totpSecret?: StringNullableFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableFilter<"Password"> | Date | string | null
    isFavorite?: BoolFilter<"Password"> | boolean
    ownerId?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableFilter<"Password"> | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    sharedWith?: PasswordShareListRelationFilter
    tags?: PasswordTagListRelationFilter
    history?: PasswordHistoryListRelationFilter
    breaches?: PasswordBreachListRelationFilter
    rotations?: PasswordRotationListRelationFilter
    rotationPolicy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
  }

  export type PasswordOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
    folder?: FolderOrderByWithRelationInput
    sharedWith?: PasswordShareOrderByRelationAggregateInput
    tags?: PasswordTagOrderByRelationAggregateInput
    history?: PasswordHistoryOrderByRelationAggregateInput
    breaches?: PasswordBreachOrderByRelationAggregateInput
    rotations?: PasswordRotationOrderByRelationAggregateInput
    rotationPolicy?: PasswordRotationPolicyOrderByWithRelationInput
  }

  export type PasswordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordWhereInput | PasswordWhereInput[]
    OR?: PasswordWhereInput[]
    NOT?: PasswordWhereInput | PasswordWhereInput[]
    name?: StringFilter<"Password"> | string
    username?: StringFilter<"Password"> | string
    password?: StringFilter<"Password"> | string
    url?: StringNullableFilter<"Password"> | string | null
    notes?: StringNullableFilter<"Password"> | string | null
    folderId?: StringNullableFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"Password"> | boolean
    totpSecret?: StringNullableFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableFilter<"Password"> | Date | string | null
    isFavorite?: BoolFilter<"Password"> | boolean
    ownerId?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableFilter<"Password"> | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    sharedWith?: PasswordShareListRelationFilter
    tags?: PasswordTagListRelationFilter
    history?: PasswordHistoryListRelationFilter
    breaches?: PasswordBreachListRelationFilter
    rotations?: PasswordRotationListRelationFilter
    rotationPolicy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
  }, "id">

  export type PasswordOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrderInput | SortOrder
    _count?: PasswordCountOrderByAggregateInput
    _max?: PasswordMaxOrderByAggregateInput
    _min?: PasswordMinOrderByAggregateInput
  }

  export type PasswordScalarWhereWithAggregatesInput = {
    AND?: PasswordScalarWhereWithAggregatesInput | PasswordScalarWhereWithAggregatesInput[]
    OR?: PasswordScalarWhereWithAggregatesInput[]
    NOT?: PasswordScalarWhereWithAggregatesInput | PasswordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Password"> | string
    name?: StringWithAggregatesFilter<"Password"> | string
    username?: StringWithAggregatesFilter<"Password"> | string
    password?: StringWithAggregatesFilter<"Password"> | string
    url?: StringNullableWithAggregatesFilter<"Password"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Password"> | string | null
    folderId?: StringNullableWithAggregatesFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthWithAggregatesFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolWithAggregatesFilter<"Password"> | boolean
    totpSecret?: StringNullableWithAggregatesFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Password"> | Date | string | null
    isFavorite?: BoolWithAggregatesFilter<"Password"> | boolean
    ownerId?: StringWithAggregatesFilter<"Password"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Password"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableWithAggregatesFilter<"Password"> | string | null
  }

  export type PasswordHistoryWhereInput = {
    AND?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    OR?: PasswordHistoryWhereInput[]
    NOT?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    id?: StringFilter<"PasswordHistory"> | string
    passwordId?: StringFilter<"PasswordHistory"> | string
    name?: StringFilter<"PasswordHistory"> | string
    username?: StringFilter<"PasswordHistory"> | string
    password?: StringFilter<"PasswordHistory"> | string
    url?: StringNullableFilter<"PasswordHistory"> | string | null
    notes?: StringNullableFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringFilter<"PasswordHistory"> | string
    changeType?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
    passwordEntry?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    changedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordHistoryOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    passwordEntry?: PasswordOrderByWithRelationInput
    changedByUser?: UserOrderByWithRelationInput
  }

  export type PasswordHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    OR?: PasswordHistoryWhereInput[]
    NOT?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    passwordId?: StringFilter<"PasswordHistory"> | string
    name?: StringFilter<"PasswordHistory"> | string
    username?: StringFilter<"PasswordHistory"> | string
    password?: StringFilter<"PasswordHistory"> | string
    url?: StringNullableFilter<"PasswordHistory"> | string | null
    notes?: StringNullableFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringFilter<"PasswordHistory"> | string
    changeType?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
    passwordEntry?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    changedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordHistoryCountOrderByAggregateInput
    _max?: PasswordHistoryMaxOrderByAggregateInput
    _min?: PasswordHistoryMinOrderByAggregateInput
  }

  export type PasswordHistoryScalarWhereWithAggregatesInput = {
    AND?: PasswordHistoryScalarWhereWithAggregatesInput | PasswordHistoryScalarWhereWithAggregatesInput[]
    OR?: PasswordHistoryScalarWhereWithAggregatesInput[]
    NOT?: PasswordHistoryScalarWhereWithAggregatesInput | PasswordHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordHistory"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordHistory"> | string
    name?: StringWithAggregatesFilter<"PasswordHistory"> | string
    username?: StringWithAggregatesFilter<"PasswordHistory"> | string
    password?: StringWithAggregatesFilter<"PasswordHistory"> | string
    url?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthWithAggregatesFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolWithAggregatesFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableWithAggregatesFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringWithAggregatesFilter<"PasswordHistory"> | string
    changeType?: StringWithAggregatesFilter<"PasswordHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordHistory"> | Date | string
  }

  export type PasswordBreachWhereInput = {
    AND?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    OR?: PasswordBreachWhereInput[]
    NOT?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    id?: StringFilter<"PasswordBreach"> | string
    passwordId?: StringFilter<"PasswordBreach"> | string
    isBreached?: BoolFilter<"PasswordBreach"> | boolean
    breachCount?: IntFilter<"PasswordBreach"> | number
    hashPrefix?: StringFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringFilter<"PasswordBreach"> | string
    resolved?: BoolFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableFilter<"PasswordBreach"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    checkedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PasswordBreachOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    password?: PasswordOrderByWithRelationInput
    checkedByUser?: UserOrderByWithRelationInput
    resolvedByUser?: UserOrderByWithRelationInput
  }

  export type PasswordBreachWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    OR?: PasswordBreachWhereInput[]
    NOT?: PasswordBreachWhereInput | PasswordBreachWhereInput[]
    passwordId?: StringFilter<"PasswordBreach"> | string
    isBreached?: BoolFilter<"PasswordBreach"> | boolean
    breachCount?: IntFilter<"PasswordBreach"> | number
    hashPrefix?: StringFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringFilter<"PasswordBreach"> | string
    resolved?: BoolFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableFilter<"PasswordBreach"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    checkedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PasswordBreachOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    _count?: PasswordBreachCountOrderByAggregateInput
    _avg?: PasswordBreachAvgOrderByAggregateInput
    _max?: PasswordBreachMaxOrderByAggregateInput
    _min?: PasswordBreachMinOrderByAggregateInput
    _sum?: PasswordBreachSumOrderByAggregateInput
  }

  export type PasswordBreachScalarWhereWithAggregatesInput = {
    AND?: PasswordBreachScalarWhereWithAggregatesInput | PasswordBreachScalarWhereWithAggregatesInput[]
    OR?: PasswordBreachScalarWhereWithAggregatesInput[]
    NOT?: PasswordBreachScalarWhereWithAggregatesInput | PasswordBreachScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordBreach"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordBreach"> | string
    isBreached?: BoolWithAggregatesFilter<"PasswordBreach"> | boolean
    breachCount?: IntWithAggregatesFilter<"PasswordBreach"> | number
    hashPrefix?: StringWithAggregatesFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeWithAggregatesFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringWithAggregatesFilter<"PasswordBreach"> | string
    resolved?: BoolWithAggregatesFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"PasswordBreach"> | string | null
  }

  export type PasswordRotationPolicyWhereInput = {
    AND?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    OR?: PasswordRotationPolicyWhereInput[]
    NOT?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    id?: StringFilter<"PasswordRotationPolicy"> | string
    name?: StringFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    passwords?: PasswordListRelationFilter
    rotations?: PasswordRotationListRelationFilter
  }

  export type PasswordRotationPolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    passwords?: PasswordOrderByRelationAggregateInput
    rotations?: PasswordRotationOrderByRelationAggregateInput
  }

  export type PasswordRotationPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    OR?: PasswordRotationPolicyWhereInput[]
    NOT?: PasswordRotationPolicyWhereInput | PasswordRotationPolicyWhereInput[]
    name?: StringFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    passwords?: PasswordListRelationFilter
    rotations?: PasswordRotationListRelationFilter
  }, "id">

  export type PasswordRotationPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordRotationPolicyCountOrderByAggregateInput
    _avg?: PasswordRotationPolicyAvgOrderByAggregateInput
    _max?: PasswordRotationPolicyMaxOrderByAggregateInput
    _min?: PasswordRotationPolicyMinOrderByAggregateInput
    _sum?: PasswordRotationPolicySumOrderByAggregateInput
  }

  export type PasswordRotationPolicyScalarWhereWithAggregatesInput = {
    AND?: PasswordRotationPolicyScalarWhereWithAggregatesInput | PasswordRotationPolicyScalarWhereWithAggregatesInput[]
    OR?: PasswordRotationPolicyScalarWhereWithAggregatesInput[]
    NOT?: PasswordRotationPolicyScalarWhereWithAggregatesInput | PasswordRotationPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordRotationPolicy"> | string
    name?: StringWithAggregatesFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableWithAggregatesFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntWithAggregatesFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntWithAggregatesFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolWithAggregatesFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolWithAggregatesFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolWithAggregatesFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringWithAggregatesFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordRotationPolicy"> | Date | string
  }

  export type PasswordRotationWhereInput = {
    AND?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    OR?: PasswordRotationWhereInput[]
    NOT?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    id?: StringFilter<"PasswordRotation"> | string
    passwordId?: StringFilter<"PasswordRotation"> | string
    policyId?: StringNullableFilter<"PasswordRotation"> | string | null
    rotationType?: StringFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableFilter<"PasswordRotation"> | string | null
    newPassword?: StringFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    status?: StringFilter<"PasswordRotation"> | string
    notes?: StringNullableFilter<"PasswordRotation"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    policy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
    rotatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordRotationOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrderInput | SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrderInput | SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    password?: PasswordOrderByWithRelationInput
    policy?: PasswordRotationPolicyOrderByWithRelationInput
    rotatedByUser?: UserOrderByWithRelationInput
  }

  export type PasswordRotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    OR?: PasswordRotationWhereInput[]
    NOT?: PasswordRotationWhereInput | PasswordRotationWhereInput[]
    passwordId?: StringFilter<"PasswordRotation"> | string
    policyId?: StringNullableFilter<"PasswordRotation"> | string | null
    rotationType?: StringFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableFilter<"PasswordRotation"> | string | null
    newPassword?: StringFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    status?: StringFilter<"PasswordRotation"> | string
    notes?: StringNullableFilter<"PasswordRotation"> | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    policy?: XOR<PasswordRotationPolicyNullableScalarRelationFilter, PasswordRotationPolicyWhereInput> | null
    rotatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordRotationOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrderInput | SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrderInput | SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: PasswordRotationCountOrderByAggregateInput
    _max?: PasswordRotationMaxOrderByAggregateInput
    _min?: PasswordRotationMinOrderByAggregateInput
  }

  export type PasswordRotationScalarWhereWithAggregatesInput = {
    AND?: PasswordRotationScalarWhereWithAggregatesInput | PasswordRotationScalarWhereWithAggregatesInput[]
    OR?: PasswordRotationScalarWhereWithAggregatesInput[]
    NOT?: PasswordRotationScalarWhereWithAggregatesInput | PasswordRotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordRotation"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordRotation"> | string
    policyId?: StringNullableWithAggregatesFilter<"PasswordRotation"> | string | null
    rotationType?: StringWithAggregatesFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableWithAggregatesFilter<"PasswordRotation"> | string | null
    newPassword?: StringWithAggregatesFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeWithAggregatesFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringWithAggregatesFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PasswordRotation"> | Date | string | null
    status?: StringWithAggregatesFilter<"PasswordRotation"> | string
    notes?: StringNullableWithAggregatesFilter<"PasswordRotation"> | string | null
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    icon?: StringNullableFilter<"Folder"> | string | null
    color?: StringNullableFilter<"Folder"> | string | null
    parentId?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    passwords?: PasswordListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: FolderOrderByWithRelationInput
    children?: FolderOrderByRelationAggregateInput
    passwords?: PasswordOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    icon?: StringNullableFilter<"Folder"> | string | null
    color?: StringNullableFilter<"Folder"> | string | null
    parentId?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    passwords?: PasswordListRelationFilter
  }, "id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    description?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    color?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
  }

  export type PasswordShareWhereInput = {
    AND?: PasswordShareWhereInput | PasswordShareWhereInput[]
    OR?: PasswordShareWhereInput[]
    NOT?: PasswordShareWhereInput | PasswordShareWhereInput[]
    id?: StringFilter<"PasswordShare"> | string
    passwordId?: StringFilter<"PasswordShare"> | string
    userId?: StringNullableFilter<"PasswordShare"> | string | null
    teamId?: StringNullableFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PasswordShare"> | Date | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }

  export type PasswordShareOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    password?: PasswordOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type PasswordShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordShareWhereInput | PasswordShareWhereInput[]
    OR?: PasswordShareWhereInput[]
    NOT?: PasswordShareWhereInput | PasswordShareWhereInput[]
    passwordId?: StringFilter<"PasswordShare"> | string
    userId?: StringNullableFilter<"PasswordShare"> | string | null
    teamId?: StringNullableFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PasswordShare"> | Date | string | null
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }, "id">

  export type PasswordShareOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: PasswordShareCountOrderByAggregateInput
    _max?: PasswordShareMaxOrderByAggregateInput
    _min?: PasswordShareMinOrderByAggregateInput
  }

  export type PasswordShareScalarWhereWithAggregatesInput = {
    AND?: PasswordShareScalarWhereWithAggregatesInput | PasswordShareScalarWhereWithAggregatesInput[]
    OR?: PasswordShareScalarWhereWithAggregatesInput[]
    NOT?: PasswordShareScalarWhereWithAggregatesInput | PasswordShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordShare"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordShare"> | string
    userId?: StringNullableWithAggregatesFilter<"PasswordShare"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionWithAggregatesFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeWithAggregatesFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PasswordShare"> | Date | string | null
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: TeamMemberListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: TeamMemberOrderByRelationAggregateInput
    sharedPasswords?: PasswordShareOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: TeamMemberListRelationFilter
    sharedPasswords?: PasswordShareListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: EnumTeamRoleWithAggregatesFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    icon?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    passwords?: PasswordTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    passwords?: PasswordTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    color?: StringNullableFilter<"Tag"> | string | null
    icon?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    passwords?: PasswordTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type PasswordTagWhereInput = {
    AND?: PasswordTagWhereInput | PasswordTagWhereInput[]
    OR?: PasswordTagWhereInput[]
    NOT?: PasswordTagWhereInput | PasswordTagWhereInput[]
    id?: StringFilter<"PasswordTag"> | string
    passwordId?: StringFilter<"PasswordTag"> | string
    tagId?: StringFilter<"PasswordTag"> | string
    createdAt?: DateTimeFilter<"PasswordTag"> | Date | string
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PasswordTagOrderByWithRelationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    password?: PasswordOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PasswordTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    passwordId_tagId?: PasswordTagPasswordIdTagIdCompoundUniqueInput
    AND?: PasswordTagWhereInput | PasswordTagWhereInput[]
    OR?: PasswordTagWhereInput[]
    NOT?: PasswordTagWhereInput | PasswordTagWhereInput[]
    passwordId?: StringFilter<"PasswordTag"> | string
    tagId?: StringFilter<"PasswordTag"> | string
    createdAt?: DateTimeFilter<"PasswordTag"> | Date | string
    password?: XOR<PasswordScalarRelationFilter, PasswordWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "passwordId_tagId">

  export type PasswordTagOrderByWithAggregationInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordTagCountOrderByAggregateInput
    _max?: PasswordTagMaxOrderByAggregateInput
    _min?: PasswordTagMinOrderByAggregateInput
  }

  export type PasswordTagScalarWhereWithAggregatesInput = {
    AND?: PasswordTagScalarWhereWithAggregatesInput | PasswordTagScalarWhereWithAggregatesInput[]
    OR?: PasswordTagScalarWhereWithAggregatesInput[]
    NOT?: PasswordTagScalarWhereWithAggregatesInput | PasswordTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordTag"> | string
    passwordId?: StringWithAggregatesFilter<"PasswordTag"> | string
    tagId?: StringWithAggregatesFilter<"PasswordTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordTag"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusWithAggregatesFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    key?: StringFilter<"Settings"> | string
    value?: JsonFilter<"Settings">
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    value?: JsonFilter<"Settings">
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }, "id" | "key">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    key?: StringWithAggregatesFilter<"Settings"> | string
    value?: JsonWithAggregatesFilter<"Settings">
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    createdById?: StringNullableFilter<"Role"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    permissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    permissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    createdById?: StringNullableFilter<"Role"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    permissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    key?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "key">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    key?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    category?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type MfaCredentialWhereInput = {
    AND?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    OR?: MfaCredentialWhereInput[]
    NOT?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    id?: StringFilter<"MfaCredential"> | string
    userId?: StringFilter<"MfaCredential"> | string
    credentialId?: StringFilter<"MfaCredential"> | string
    publicKey?: StringFilter<"MfaCredential"> | string
    counter?: BigIntFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableFilter<"MfaCredential"> | string | null
    backedUp?: BoolFilter<"MfaCredential"> | boolean
    transports?: StringNullableFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MfaCredential"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MfaCredentialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    backedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MfaCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    credentialId?: string
    AND?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    OR?: MfaCredentialWhereInput[]
    NOT?: MfaCredentialWhereInput | MfaCredentialWhereInput[]
    userId?: StringFilter<"MfaCredential"> | string
    publicKey?: StringFilter<"MfaCredential"> | string
    counter?: BigIntFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableFilter<"MfaCredential"> | string | null
    backedUp?: BoolFilter<"MfaCredential"> | boolean
    transports?: StringNullableFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MfaCredential"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "credentialId">

  export type MfaCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    backedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: MfaCredentialCountOrderByAggregateInput
    _avg?: MfaCredentialAvgOrderByAggregateInput
    _max?: MfaCredentialMaxOrderByAggregateInput
    _min?: MfaCredentialMinOrderByAggregateInput
    _sum?: MfaCredentialSumOrderByAggregateInput
  }

  export type MfaCredentialScalarWhereWithAggregatesInput = {
    AND?: MfaCredentialScalarWhereWithAggregatesInput | MfaCredentialScalarWhereWithAggregatesInput[]
    OR?: MfaCredentialScalarWhereWithAggregatesInput[]
    NOT?: MfaCredentialScalarWhereWithAggregatesInput | MfaCredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MfaCredential"> | string
    userId?: StringWithAggregatesFilter<"MfaCredential"> | string
    credentialId?: StringWithAggregatesFilter<"MfaCredential"> | string
    publicKey?: StringWithAggregatesFilter<"MfaCredential"> | string
    counter?: BigIntWithAggregatesFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableWithAggregatesFilter<"MfaCredential"> | string | null
    backedUp?: BoolWithAggregatesFilter<"MfaCredential"> | boolean
    transports?: StringNullableWithAggregatesFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"MfaCredential"> | Date | string | null
  }

  export type RecoveryCodeWhereInput = {
    AND?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    OR?: RecoveryCodeWhereInput[]
    NOT?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    id?: StringFilter<"RecoveryCode"> | string
    userId?: StringFilter<"RecoveryCode"> | string
    codeHash?: StringFilter<"RecoveryCode"> | string
    used?: BoolFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RecoveryCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RecoveryCodeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RecoveryCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    OR?: RecoveryCodeWhereInput[]
    NOT?: RecoveryCodeWhereInput | RecoveryCodeWhereInput[]
    userId?: StringFilter<"RecoveryCode"> | string
    codeHash?: StringFilter<"RecoveryCode"> | string
    used?: BoolFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RecoveryCode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RecoveryCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RecoveryCodeCountOrderByAggregateInput
    _max?: RecoveryCodeMaxOrderByAggregateInput
    _min?: RecoveryCodeMinOrderByAggregateInput
  }

  export type RecoveryCodeScalarWhereWithAggregatesInput = {
    AND?: RecoveryCodeScalarWhereWithAggregatesInput | RecoveryCodeScalarWhereWithAggregatesInput[]
    OR?: RecoveryCodeScalarWhereWithAggregatesInput[]
    NOT?: RecoveryCodeScalarWhereWithAggregatesInput | RecoveryCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecoveryCode"> | string
    userId?: StringWithAggregatesFilter<"RecoveryCode"> | string
    codeHash?: StringWithAggregatesFilter<"RecoveryCode"> | string
    used?: BoolWithAggregatesFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecoveryCode"> | Date | string
  }

  export type SavedSearchWhereInput = {
    AND?: SavedSearchWhereInput | SavedSearchWhereInput[]
    OR?: SavedSearchWhereInput[]
    NOT?: SavedSearchWhereInput | SavedSearchWhereInput[]
    id?: StringFilter<"SavedSearch"> | string
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    query?: StringNullableFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SavedSearch"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SavedSearchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SavedSearchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedSearchWhereInput | SavedSearchWhereInput[]
    OR?: SavedSearchWhereInput[]
    NOT?: SavedSearchWhereInput | SavedSearchWhereInput[]
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    query?: StringNullableFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SavedSearch"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SavedSearchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: SavedSearchCountOrderByAggregateInput
    _max?: SavedSearchMaxOrderByAggregateInput
    _min?: SavedSearchMinOrderByAggregateInput
  }

  export type SavedSearchScalarWhereWithAggregatesInput = {
    AND?: SavedSearchScalarWhereWithAggregatesInput | SavedSearchScalarWhereWithAggregatesInput[]
    OR?: SavedSearchScalarWhereWithAggregatesInput[]
    NOT?: SavedSearchScalarWhereWithAggregatesInput | SavedSearchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedSearch"> | string
    userId?: StringWithAggregatesFilter<"SavedSearch"> | string
    name?: StringWithAggregatesFilter<"SavedSearch"> | string
    query?: StringNullableWithAggregatesFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableWithAggregatesFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeWithAggregatesFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"SavedSearch"> | Date | string | null
  }

  export type SearchHistoryWhereInput = {
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringNullableFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SearchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    resultCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringNullableFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SearchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrderInput | SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrderInput | SortOrder
    searchFields?: SortOrder
    resultCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SearchHistoryCountOrderByAggregateInput
    _avg?: SearchHistoryAvgOrderByAggregateInput
    _max?: SearchHistoryMaxOrderByAggregateInput
    _min?: SearchHistoryMinOrderByAggregateInput
    _sum?: SearchHistorySumOrderByAggregateInput
  }

  export type SearchHistoryScalarWhereWithAggregatesInput = {
    AND?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    OR?: SearchHistoryScalarWhereWithAggregatesInput[]
    NOT?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchHistory"> | string
    userId?: StringWithAggregatesFilter<"SearchHistory"> | string
    query?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableWithAggregatesFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
  }

  export type PasswordTemplateWhereInput = {
    AND?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    OR?: PasswordTemplateWhereInput[]
    NOT?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    id?: StringFilter<"PasswordTemplate"> | string
    name?: StringFilter<"PasswordTemplate"> | string
    description?: StringNullableFilter<"PasswordTemplate"> | string | null
    service?: StringNullableFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableFilter<"PasswordTemplate"> | string | null
    category?: StringNullableFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonFilter<"PasswordTemplate">
    usageCount?: IntFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type PasswordTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    defaultFields?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type PasswordTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    OR?: PasswordTemplateWhereInput[]
    NOT?: PasswordTemplateWhereInput | PasswordTemplateWhereInput[]
    name?: StringFilter<"PasswordTemplate"> | string
    description?: StringNullableFilter<"PasswordTemplate"> | string | null
    service?: StringNullableFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableFilter<"PasswordTemplate"> | string | null
    category?: StringNullableFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonFilter<"PasswordTemplate">
    usageCount?: IntFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type PasswordTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    defaultFields?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordTemplateCountOrderByAggregateInput
    _avg?: PasswordTemplateAvgOrderByAggregateInput
    _max?: PasswordTemplateMaxOrderByAggregateInput
    _min?: PasswordTemplateMinOrderByAggregateInput
    _sum?: PasswordTemplateSumOrderByAggregateInput
  }

  export type PasswordTemplateScalarWhereWithAggregatesInput = {
    AND?: PasswordTemplateScalarWhereWithAggregatesInput | PasswordTemplateScalarWhereWithAggregatesInput[]
    OR?: PasswordTemplateScalarWhereWithAggregatesInput[]
    NOT?: PasswordTemplateScalarWhereWithAggregatesInput | PasswordTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordTemplate"> | string
    name?: StringWithAggregatesFilter<"PasswordTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    service?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    category?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolWithAggregatesFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolWithAggregatesFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonWithAggregatesFilter<"PasswordTemplate">
    usageCount?: IntWithAggregatesFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordTemplate"> | Date | string
  }

  export type EmailVerificationTokenWhereInput = {
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    OR?: EmailVerificationTokenWhereInput[]
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    id?: StringFilter<"EmailVerificationToken"> | string
    token?: StringFilter<"EmailVerificationToken"> | string
    userId?: StringFilter<"EmailVerificationToken"> | string
    email?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailVerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailVerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    OR?: EmailVerificationTokenWhereInput[]
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[]
    userId?: StringFilter<"EmailVerificationToken"> | string
    email?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type EmailVerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: EmailVerificationTokenCountOrderByAggregateInput
    _max?: EmailVerificationTokenMaxOrderByAggregateInput
    _min?: EmailVerificationTokenMinOrderByAggregateInput
  }

  export type EmailVerificationTokenScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[]
    OR?: EmailVerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: EmailVerificationTokenScalarWhereWithAggregatesInput | EmailVerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    token?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    userId?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    email?: StringWithAggregatesFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    used?: BoolWithAggregatesFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type SecurityQuestionWhereInput = {
    AND?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    OR?: SecurityQuestionWhereInput[]
    NOT?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    id?: StringFilter<"SecurityQuestion"> | string
    userId?: StringFilter<"SecurityQuestion"> | string
    question?: StringFilter<"SecurityQuestion"> | string
    answerHash?: StringFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SecurityQuestionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SecurityQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    OR?: SecurityQuestionWhereInput[]
    NOT?: SecurityQuestionWhereInput | SecurityQuestionWhereInput[]
    userId?: StringFilter<"SecurityQuestion"> | string
    question?: StringFilter<"SecurityQuestion"> | string
    answerHash?: StringFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SecurityQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityQuestionCountOrderByAggregateInput
    _max?: SecurityQuestionMaxOrderByAggregateInput
    _min?: SecurityQuestionMinOrderByAggregateInput
  }

  export type SecurityQuestionScalarWhereWithAggregatesInput = {
    AND?: SecurityQuestionScalarWhereWithAggregatesInput | SecurityQuestionScalarWhereWithAggregatesInput[]
    OR?: SecurityQuestionScalarWhereWithAggregatesInput[]
    NOT?: SecurityQuestionScalarWhereWithAggregatesInput | SecurityQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    userId?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    question?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    answerHash?: StringWithAggregatesFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityQuestion"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    isTrusted?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    isTrusted?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    isTrusted?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordCreateInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordCreateManyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
  }

  export type PasswordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordHistoryCreateInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
    passwordEntry: PasswordCreateNestedOneWithoutHistoryInput
    changedByUser: UserCreateNestedOneWithoutPasswordHistoryInput
  }

  export type PasswordHistoryUncheckedCreateInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordEntry?: PasswordUpdateOneRequiredWithoutHistoryNestedInput
    changedByUser?: UserUpdateOneRequiredWithoutPasswordHistoryNestedInput
  }

  export type PasswordHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryCreateManyInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordBreachCreateInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutBreachesInput
    checkedByUser: UserCreateNestedOneWithoutPasswordBreachesCheckedInput
    resolvedByUser?: UserCreateNestedOneWithoutPasswordBreachesResolvedInput
  }

  export type PasswordBreachUncheckedCreateInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutBreachesNestedInput
    checkedByUser?: UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput
    resolvedByUser?: UserUpdateOneWithoutPasswordBreachesResolvedNestedInput
  }

  export type PasswordBreachUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachCreateManyInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordBreachUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationPolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutRotationPoliciesInput
    passwords?: PasswordCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutRotationPoliciesNestedInput
    passwords?: PasswordUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordRotationPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationCreateInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    password: PasswordCreateNestedOneWithoutRotationsInput
    policy?: PasswordRotationPolicyCreateNestedOneWithoutRotationsInput
    rotatedByUser: UserCreateNestedOneWithoutPasswordRotationsInput
  }

  export type PasswordRotationUncheckedCreateInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    password?: PasswordUpdateOneRequiredWithoutRotationsNestedInput
    policy?: PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput
    rotatedByUser?: UserUpdateOneRequiredWithoutPasswordRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationCreateManyInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FolderCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
    passwords?: PasswordCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    passwords?: PasswordUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    passwords?: PasswordUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    passwords?: PasswordUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordShareCreateInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutSharedWithInput
    user?: UserCreateNestedOneWithoutSharedPasswordsInput
    team?: TeamCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateInput = {
    id?: string
    passwordId: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutSharedWithNestedInput
    user?: UserUpdateOneWithoutSharedPasswordsNestedInput
    team?: TeamUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareCreateManyInput = {
    id?: string
    passwordId: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    passwords?: PasswordTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    passwords?: PasswordTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagCreateInput = {
    id?: string
    createdAt?: Date | string
    password: PasswordCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordTagUncheckedCreateInput = {
    id?: string
    passwordId: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: PasswordUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPasswordsNestedInput
  }

  export type PasswordTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagCreateManyInput = {
    id?: string
    passwordId: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedRolesInput
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedRolesNestedInput
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MfaCredentialCreateInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMfaCredentialsInput
  }

  export type MfaCredentialUncheckedCreateInput = {
    id?: string
    userId: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMfaCredentialsNestedInput
  }

  export type MfaCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialCreateManyInput = {
    id?: string
    userId: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecoveryCodeCreateInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecoveryCodesInput
  }

  export type RecoveryCodeUncheckedCreateInput = {
    id?: string
    userId: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecoveryCodesNestedInput
  }

  export type RecoveryCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeCreateManyInput = {
    id?: string
    userId: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedSearchCreateInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSavedSearchesInput
  }

  export type SavedSearchUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSavedSearchesNestedInput
  }

  export type SavedSearchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchCreateManyInput = {
    id?: string
    userId: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchHistoryCreateInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSearchHistoryInput
  }

  export type SearchHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSearchHistoryNestedInput
  }

  export type SearchHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryCreateManyInput = {
    id?: string
    userId: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutPasswordTemplatesInput
    company?: CompanyCreateNestedOneWithoutTemplatesInput
  }

  export type PasswordTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutPasswordTemplatesNestedInput
    company?: CompanyUpdateOneWithoutTemplatesNestedInput
  }

  export type PasswordTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenCreateInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailVerificationTokensInput
  }

  export type EmailVerificationTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput
  }

  export type EmailVerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionCreateInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSecurityQuestionsInput
  }

  export type SecurityQuestionUncheckedCreateInput = {
    id?: string
    userId: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSecurityQuestionsNestedInput
  }

  export type SecurityQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionCreateManyInput = {
    id?: string
    userId: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PasswordTemplateListRelationFilter = {
    every?: PasswordTemplateWhereInput
    some?: PasswordTemplateWhereInput
    none?: PasswordTemplateWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumMfaMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableFilter<$PrismaModel> | $Enums.MfaMethod | null
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type PasswordListRelationFilter = {
    every?: PasswordWhereInput
    some?: PasswordWhereInput
    none?: PasswordWhereInput
  }

  export type PasswordShareListRelationFilter = {
    every?: PasswordShareWhereInput
    some?: PasswordShareWhereInput
    none?: PasswordShareWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type MfaCredentialListRelationFilter = {
    every?: MfaCredentialWhereInput
    some?: MfaCredentialWhereInput
    none?: MfaCredentialWhereInput
  }

  export type RecoveryCodeListRelationFilter = {
    every?: RecoveryCodeWhereInput
    some?: RecoveryCodeWhereInput
    none?: RecoveryCodeWhereInput
  }

  export type PasswordHistoryListRelationFilter = {
    every?: PasswordHistoryWhereInput
    some?: PasswordHistoryWhereInput
    none?: PasswordHistoryWhereInput
  }

  export type PasswordBreachListRelationFilter = {
    every?: PasswordBreachWhereInput
    some?: PasswordBreachWhereInput
    none?: PasswordBreachWhereInput
  }

  export type PasswordRotationPolicyListRelationFilter = {
    every?: PasswordRotationPolicyWhereInput
    some?: PasswordRotationPolicyWhereInput
    none?: PasswordRotationPolicyWhereInput
  }

  export type PasswordRotationListRelationFilter = {
    every?: PasswordRotationWhereInput
    some?: PasswordRotationWhereInput
    none?: PasswordRotationWhereInput
  }

  export type SavedSearchListRelationFilter = {
    every?: SavedSearchWhereInput
    some?: SavedSearchWhereInput
    none?: SavedSearchWhereInput
  }

  export type SearchHistoryListRelationFilter = {
    every?: SearchHistoryWhereInput
    some?: SearchHistoryWhereInput
    none?: SearchHistoryWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type EmailVerificationTokenListRelationFilter = {
    every?: EmailVerificationTokenWhereInput
    some?: EmailVerificationTokenWhereInput
    none?: EmailVerificationTokenWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SecurityQuestionListRelationFilter = {
    every?: SecurityQuestionWhereInput
    some?: SecurityQuestionWhereInput
    none?: SecurityQuestionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PasswordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MfaCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecoveryCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordBreachOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordRotationPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordRotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedSearchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailVerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    recoveryEmail?: SortOrder
    recoveryEmailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    bio?: SortOrder
    preferences?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaMethod?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    recoveryEmail?: SortOrder
    recoveryEmailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaMethod?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    recoveryEmail?: SortOrder
    recoveryEmailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaMethod?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdById?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumMfaMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.MfaMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    isTrusted?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPasswordStrengthFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthFilter<$PrismaModel> | $Enums.PasswordStrength
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type PasswordTagListRelationFilter = {
    every?: PasswordTagWhereInput
    some?: PasswordTagWhereInput
    none?: PasswordTagWhereInput
  }

  export type PasswordRotationPolicyNullableScalarRelationFilter = {
    is?: PasswordRotationPolicyWhereInput | null
    isNot?: PasswordRotationPolicyWhereInput | null
  }

  export type PasswordTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrder
  }

  export type PasswordMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrder
  }

  export type PasswordMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    isFavorite?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotationPolicyId?: SortOrder
  }

  export type EnumPasswordStrengthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthWithAggregatesFilter<$PrismaModel> | $Enums.PasswordStrength
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPasswordStrengthFilter<$PrismaModel>
    _max?: NestedEnumPasswordStrengthFilter<$PrismaModel>
  }

  export type PasswordScalarRelationFilter = {
    is?: PasswordWhereInput
    isNot?: PasswordWhereInput
  }

  export type PasswordHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    url?: SortOrder
    notes?: SortOrder
    folderId?: SortOrder
    strength?: SortOrder
    hasTotp?: SortOrder
    totpSecret?: SortOrder
    expiresAt?: SortOrder
    changedBy?: SortOrder
    changeType?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PasswordBreachCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type PasswordBreachAvgOrderByAggregateInput = {
    breachCount?: SortOrder
  }

  export type PasswordBreachMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type PasswordBreachMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    isBreached?: SortOrder
    breachCount?: SortOrder
    hashPrefix?: SortOrder
    checkedAt?: SortOrder
    checkedBy?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type PasswordBreachSumOrderByAggregateInput = {
    breachCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PasswordRotationPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordRotationPolicyAvgOrderByAggregateInput = {
    rotationDays?: SortOrder
    reminderDays?: SortOrder
  }

  export type PasswordRotationPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordRotationPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rotationDays?: SortOrder
    reminderDays?: SortOrder
    autoRotate?: SortOrder
    requireApproval?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordRotationPolicySumOrderByAggregateInput = {
    rotationDays?: SortOrder
    reminderDays?: SortOrder
  }

  export type PasswordRotationCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type PasswordRotationMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type PasswordRotationMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    policyId?: SortOrder
    rotationType?: SortOrder
    oldPassword?: SortOrder
    newPassword?: SortOrder
    rotatedAt?: SortOrder
    rotatedBy?: SortOrder
    scheduledFor?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSharePermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionFilter<$PrismaModel> | $Enums.SharePermission
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type PasswordShareCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordShareMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordShareMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumSharePermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionWithAggregatesFilter<$PrismaModel> | $Enums.SharePermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSharePermissionFilter<$PrismaModel>
    _max?: NestedEnumSharePermissionFilter<$PrismaModel>
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PasswordTagPasswordIdTagIdCompoundUniqueInput = {
    passwordId: string
    tagId: string
  }

  export type PasswordTagCountOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordTagMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordTagMinOrderByAggregateInput = {
    id?: SortOrder
    passwordId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type MfaCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type MfaCredentialAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type MfaCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type MfaCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type MfaCredentialSumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type RecoveryCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RecoveryCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RecoveryCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SavedSearchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrder
    searchFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SavedSearchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SavedSearchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type SearchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    folderIds?: SortOrder
    tagIds?: SortOrder
    filter?: SortOrder
    searchFields?: SortOrder
    resultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryAvgOrderByAggregateInput = {
    resultCount?: SortOrder
  }

  export type SearchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    resultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    filter?: SortOrder
    resultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistorySumOrderByAggregateInput = {
    resultCount?: SortOrder
  }

  export type PasswordTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
    defaultFields?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type PasswordTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EmailVerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailVerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailVerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    answerHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PasswordTemplateCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PasswordTemplateUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutCompanyInput | PasswordTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput> | PasswordTemplateCreateWithoutCompanyInput[] | PasswordTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutCompanyInput | PasswordTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PasswordTemplateCreateManyCompanyInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput | PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutCompanyInput | PasswordTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type PasswordCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordShareCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MfaCredentialCreateNestedManyWithoutUserInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
  }

  export type RecoveryCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
  }

  export type PasswordHistoryCreateNestedManyWithoutChangedByUserInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachCreateNestedManyWithoutCheckedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordBreachCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationPolicyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
  }

  export type PasswordRotationCreateNestedManyWithoutRotatedByUserInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type SavedSearchCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
  }

  export type SearchHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type PasswordTemplateCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type EmailVerificationTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SecurityQuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
  }

  export type PasswordUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordShareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MfaCredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
  }

  export type RecoveryCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
  }

  export type PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
  }

  export type PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type SavedSearchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SecurityQuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumMfaMethodFieldUpdateOperationsInput = {
    set?: $Enums.MfaMethod | null
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type PasswordUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutOwnerInput | PasswordUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutOwnerInput | PasswordUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutOwnerInput | PasswordUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordShareUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutUserInput | PasswordShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutUserInput | PasswordShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutUserInput | PasswordShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MfaCredentialUpdateManyWithoutUserNestedInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    upsert?: MfaCredentialUpsertWithWhereUniqueWithoutUserInput | MfaCredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    set?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    disconnect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    delete?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    update?: MfaCredentialUpdateWithWhereUniqueWithoutUserInput | MfaCredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MfaCredentialUpdateManyWithWhereWithoutUserInput | MfaCredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
  }

  export type RecoveryCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    upsert?: RecoveryCodeUpsertWithWhereUniqueWithoutUserInput | RecoveryCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    set?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    disconnect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    delete?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    update?: RecoveryCodeUpdateWithWhereUniqueWithoutUserInput | RecoveryCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecoveryCodeUpdateManyWithWhereWithoutUserInput | RecoveryCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
  }

  export type PasswordHistoryUpdateManyWithoutChangedByUserNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput | PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUpdateManyWithoutCheckedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput | PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordBreachUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput | PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    set?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    disconnect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    delete?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    update?: PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput | PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
  }

  export type PasswordRotationUpdateManyWithoutRotatedByUserNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput | PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type SavedSearchUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    upsert?: SavedSearchUpsertWithWhereUniqueWithoutUserInput | SavedSearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    set?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    disconnect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    delete?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    update?: SavedSearchUpdateWithWhereUniqueWithoutUserInput | SavedSearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedSearchUpdateManyWithWhereWithoutUserInput | SavedSearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
  }

  export type SearchHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type PasswordTemplateUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutOwnerInput | PasswordTemplateUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutCreatedByInput | RoleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutCreatedByInput | RoleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutCreatedByInput | RoleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type EmailVerificationTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SecurityQuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    upsert?: SecurityQuestionUpsertWithWhereUniqueWithoutUserInput | SecurityQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    set?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    disconnect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    delete?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    update?: SecurityQuestionUpdateWithWhereUniqueWithoutUserInput | SecurityQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityQuestionUpdateManyWithWhereWithoutUserInput | SecurityQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
  }

  export type PasswordUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput> | PasswordCreateWithoutOwnerInput[] | PasswordUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutOwnerInput | PasswordCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutOwnerInput | PasswordUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordCreateManyOwnerInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutOwnerInput | PasswordUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutOwnerInput | PasswordUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordShareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput> | PasswordShareCreateWithoutUserInput[] | PasswordShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutUserInput | PasswordShareCreateOrConnectWithoutUserInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutUserInput | PasswordShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordShareCreateManyUserInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutUserInput | PasswordShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutUserInput | PasswordShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MfaCredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput> | MfaCredentialCreateWithoutUserInput[] | MfaCredentialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MfaCredentialCreateOrConnectWithoutUserInput | MfaCredentialCreateOrConnectWithoutUserInput[]
    upsert?: MfaCredentialUpsertWithWhereUniqueWithoutUserInput | MfaCredentialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MfaCredentialCreateManyUserInputEnvelope
    set?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    disconnect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    delete?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    connect?: MfaCredentialWhereUniqueInput | MfaCredentialWhereUniqueInput[]
    update?: MfaCredentialUpdateWithWhereUniqueWithoutUserInput | MfaCredentialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MfaCredentialUpdateManyWithWhereWithoutUserInput | MfaCredentialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
  }

  export type RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput> | RecoveryCodeCreateWithoutUserInput[] | RecoveryCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryCodeCreateOrConnectWithoutUserInput | RecoveryCodeCreateOrConnectWithoutUserInput[]
    upsert?: RecoveryCodeUpsertWithWhereUniqueWithoutUserInput | RecoveryCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecoveryCodeCreateManyUserInputEnvelope
    set?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    disconnect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    delete?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    connect?: RecoveryCodeWhereUniqueInput | RecoveryCodeWhereUniqueInput[]
    update?: RecoveryCodeUpdateWithWhereUniqueWithoutUserInput | RecoveryCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecoveryCodeUpdateManyWithWhereWithoutUserInput | RecoveryCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput> | PasswordHistoryCreateWithoutChangedByUserInput[] | PasswordHistoryUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutChangedByUserInput | PasswordHistoryCreateOrConnectWithoutChangedByUserInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput[]
    createMany?: PasswordHistoryCreateManyChangedByUserInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput | PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput | PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput> | PasswordBreachCreateWithoutCheckedByUserInput[] | PasswordBreachUncheckedCreateWithoutCheckedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutCheckedByUserInput | PasswordBreachCreateOrConnectWithoutCheckedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput[]
    createMany?: PasswordBreachCreateManyCheckedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput | PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput> | PasswordBreachCreateWithoutResolvedByUserInput[] | PasswordBreachUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutResolvedByUserInput | PasswordBreachCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: PasswordBreachCreateManyResolvedByUserInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput | PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput | PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput> | PasswordRotationPolicyCreateWithoutOwnerInput[] | PasswordRotationPolicyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutOwnerInput | PasswordRotationPolicyCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordRotationPolicyCreateManyOwnerInputEnvelope
    set?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    disconnect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    delete?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    connect?: PasswordRotationPolicyWhereUniqueInput | PasswordRotationPolicyWhereUniqueInput[]
    update?: PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput | PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput | PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
  }

  export type PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput> | PasswordRotationCreateWithoutRotatedByUserInput[] | PasswordRotationUncheckedCreateWithoutRotatedByUserInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutRotatedByUserInput | PasswordRotationCreateOrConnectWithoutRotatedByUserInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput[]
    createMany?: PasswordRotationCreateManyRotatedByUserInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput | PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput | PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type SavedSearchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput> | SavedSearchCreateWithoutUserInput[] | SavedSearchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedSearchCreateOrConnectWithoutUserInput | SavedSearchCreateOrConnectWithoutUserInput[]
    upsert?: SavedSearchUpsertWithWhereUniqueWithoutUserInput | SavedSearchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedSearchCreateManyUserInputEnvelope
    set?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    disconnect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    delete?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    connect?: SavedSearchWhereUniqueInput | SavedSearchWhereUniqueInput[]
    update?: SavedSearchUpdateWithWhereUniqueWithoutUserInput | SavedSearchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedSearchUpdateManyWithWhereWithoutUserInput | SavedSearchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput> | PasswordTemplateCreateWithoutOwnerInput[] | PasswordTemplateUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PasswordTemplateCreateOrConnectWithoutOwnerInput | PasswordTemplateCreateOrConnectWithoutOwnerInput[]
    upsert?: PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PasswordTemplateCreateManyOwnerInputEnvelope
    set?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    disconnect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    delete?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    connect?: PasswordTemplateWhereUniqueInput | PasswordTemplateWhereUniqueInput[]
    update?: PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput | PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PasswordTemplateUpdateManyWithWhereWithoutOwnerInput | PasswordTemplateUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput> | RoleCreateWithoutCreatedByInput[] | RoleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatedByInput | RoleCreateOrConnectWithoutCreatedByInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutCreatedByInput | RoleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RoleCreateManyCreatedByInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutCreatedByInput | RoleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutCreatedByInput | RoleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput> | EmailVerificationTokenCreateWithoutUserInput[] | EmailVerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailVerificationTokenCreateOrConnectWithoutUserInput | EmailVerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope
    set?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    disconnect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    delete?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    connect?: EmailVerificationTokenWhereUniqueInput | EmailVerificationTokenWhereUniqueInput[]
    update?: EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailVerificationTokenUpdateManyWithWhereWithoutUserInput | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput> | SecurityQuestionCreateWithoutUserInput[] | SecurityQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityQuestionCreateOrConnectWithoutUserInput | SecurityQuestionCreateOrConnectWithoutUserInput[]
    upsert?: SecurityQuestionUpsertWithWhereUniqueWithoutUserInput | SecurityQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityQuestionCreateManyUserInputEnvelope
    set?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    disconnect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    delete?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    connect?: SecurityQuestionWhereUniqueInput | SecurityQuestionWhereUniqueInput[]
    update?: SecurityQuestionUpdateWithWhereUniqueWithoutUserInput | SecurityQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityQuestionUpdateManyWithWhereWithoutUserInput | SecurityQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutOwnedPasswordsInput = {
    create?: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedPasswordsInput
    connect?: UserWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutPasswordsInput = {
    create?: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutPasswordsInput
    connect?: FolderWhereUniqueInput
  }

  export type PasswordShareCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type PasswordTagCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordHistoryCreateNestedManyWithoutPasswordEntryInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutPasswordsInput
    connect?: PasswordRotationPolicyWhereUniqueInput
  }

  export type PasswordShareUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type PasswordTagUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
  }

  export type PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type EnumPasswordStrengthFieldUpdateOperationsInput = {
    set?: $Enums.PasswordStrength
  }

  export type UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedPasswordsInput
    upsert?: UserUpsertWithoutOwnedPasswordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedPasswordsInput, UserUpdateWithoutOwnedPasswordsInput>, UserUncheckedUpdateWithoutOwnedPasswordsInput>
  }

  export type FolderUpdateOneWithoutPasswordsNestedInput = {
    create?: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutPasswordsInput
    upsert?: FolderUpsertWithoutPasswordsInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutPasswordsInput, FolderUpdateWithoutPasswordsInput>, FolderUncheckedUpdateWithoutPasswordsInput>
  }

  export type PasswordShareUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutPasswordInput | PasswordShareUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutPasswordInput | PasswordShareUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutPasswordInput | PasswordShareUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type PasswordTagUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutPasswordInput | PasswordTagUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutPasswordInput | PasswordTagUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutPasswordInput | PasswordTagUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput | PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput | PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput | PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutPasswordInput | PasswordBreachUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput | PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput | PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPasswordInput | PasswordRotationUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutPasswordsInput
    upsert?: PasswordRotationPolicyUpsertWithoutPasswordsInput
    disconnect?: PasswordRotationPolicyWhereInput | boolean
    delete?: PasswordRotationPolicyWhereInput | boolean
    connect?: PasswordRotationPolicyWhereUniqueInput
    update?: XOR<XOR<PasswordRotationPolicyUpdateToOneWithWhereWithoutPasswordsInput, PasswordRotationPolicyUpdateWithoutPasswordsInput>, PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput>
  }

  export type PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput> | PasswordShareCreateWithoutPasswordInput[] | PasswordShareUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutPasswordInput | PasswordShareCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutPasswordInput | PasswordShareUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordShareCreateManyPasswordInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutPasswordInput | PasswordShareUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutPasswordInput | PasswordShareUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput> | PasswordTagCreateWithoutPasswordInput[] | PasswordTagUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutPasswordInput | PasswordTagCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutPasswordInput | PasswordTagUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordTagCreateManyPasswordInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutPasswordInput | PasswordTagUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutPasswordInput | PasswordTagUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput> | PasswordHistoryCreateWithoutPasswordEntryInput[] | PasswordHistoryUncheckedCreateWithoutPasswordEntryInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutPasswordEntryInput | PasswordHistoryCreateOrConnectWithoutPasswordEntryInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput[]
    createMany?: PasswordHistoryCreateManyPasswordEntryInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput | PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput | PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput> | PasswordBreachCreateWithoutPasswordInput[] | PasswordBreachUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordBreachCreateOrConnectWithoutPasswordInput | PasswordBreachCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput | PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordBreachCreateManyPasswordInputEnvelope
    set?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    disconnect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    delete?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    connect?: PasswordBreachWhereUniqueInput | PasswordBreachWhereUniqueInput[]
    update?: PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput | PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordBreachUpdateManyWithWhereWithoutPasswordInput | PasswordBreachUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput> | PasswordRotationCreateWithoutPasswordInput[] | PasswordRotationUncheckedCreateWithoutPasswordInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPasswordInput | PasswordRotationCreateOrConnectWithoutPasswordInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput | PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput[]
    createMany?: PasswordRotationCreateManyPasswordInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput | PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPasswordInput | PasswordRotationUpdateManyWithWhereWithoutPasswordInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutHistoryInput = {
    create?: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutHistoryInput
    connect?: PasswordWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordHistoryInput = {
    create?: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type PasswordUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutHistoryInput
    upsert?: PasswordUpsertWithoutHistoryInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutHistoryInput, PasswordUpdateWithoutHistoryInput>, PasswordUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutPasswordHistoryNestedInput = {
    create?: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordHistoryInput
    upsert?: UserUpsertWithoutPasswordHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordHistoryInput, UserUpdateWithoutPasswordHistoryInput>, UserUncheckedUpdateWithoutPasswordHistoryInput>
  }

  export type PasswordCreateNestedOneWithoutBreachesInput = {
    create?: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutBreachesInput
    connect?: PasswordWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordBreachesCheckedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesCheckedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordBreachesResolvedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesResolvedInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PasswordUpdateOneRequiredWithoutBreachesNestedInput = {
    create?: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutBreachesInput
    upsert?: PasswordUpsertWithoutBreachesInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutBreachesInput, PasswordUpdateWithoutBreachesInput>, PasswordUncheckedUpdateWithoutBreachesInput>
  }

  export type UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesCheckedInput
    upsert?: UserUpsertWithoutPasswordBreachesCheckedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordBreachesCheckedInput, UserUpdateWithoutPasswordBreachesCheckedInput>, UserUncheckedUpdateWithoutPasswordBreachesCheckedInput>
  }

  export type UserUpdateOneWithoutPasswordBreachesResolvedNestedInput = {
    create?: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordBreachesResolvedInput
    upsert?: UserUpsertWithoutPasswordBreachesResolvedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordBreachesResolvedInput, UserUpdateWithoutPasswordBreachesResolvedInput>, UserUncheckedUpdateWithoutPasswordBreachesResolvedInput>
  }

  export type UserCreateNestedOneWithoutRotationPoliciesInput = {
    create?: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationPoliciesInput
    connect?: UserWhereUniqueInput
  }

  export type PasswordCreateNestedManyWithoutRotationPolicyInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordRotationCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutRotationPoliciesNestedInput = {
    create?: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationPoliciesInput
    upsert?: UserUpsertWithoutRotationPoliciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRotationPoliciesInput, UserUpdateWithoutRotationPoliciesInput>, UserUncheckedUpdateWithoutRotationPoliciesInput>
  }

  export type PasswordUpdateManyWithoutRotationPolicyNestedInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput | PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput | PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutRotationPolicyInput | PasswordUpdateManyWithWhereWithoutRotationPolicyInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordRotationUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput | PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput | PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPolicyInput | PasswordRotationUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput = {
    create?: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput> | PasswordCreateWithoutRotationPolicyInput[] | PasswordUncheckedCreateWithoutRotationPolicyInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationPolicyInput | PasswordCreateOrConnectWithoutRotationPolicyInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput | PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput[]
    createMany?: PasswordCreateManyRotationPolicyInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput | PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutRotationPolicyInput | PasswordUpdateManyWithWhereWithoutRotationPolicyInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput> | PasswordRotationCreateWithoutPolicyInput[] | PasswordRotationUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PasswordRotationCreateOrConnectWithoutPolicyInput | PasswordRotationCreateOrConnectWithoutPolicyInput[]
    upsert?: PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput | PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PasswordRotationCreateManyPolicyInputEnvelope
    set?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    disconnect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    delete?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    connect?: PasswordRotationWhereUniqueInput | PasswordRotationWhereUniqueInput[]
    update?: PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput | PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PasswordRotationUpdateManyWithWhereWithoutPolicyInput | PasswordRotationUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutRotationsInput = {
    create?: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationsInput
    connect?: PasswordWhereUniqueInput
  }

  export type PasswordRotationPolicyCreateNestedOneWithoutRotationsInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutRotationsInput
    connect?: PasswordRotationPolicyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPasswordRotationsInput = {
    create?: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordRotationsInput
    connect?: UserWhereUniqueInput
  }

  export type PasswordUpdateOneRequiredWithoutRotationsNestedInput = {
    create?: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutRotationsInput
    upsert?: PasswordUpsertWithoutRotationsInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutRotationsInput, PasswordUpdateWithoutRotationsInput>, PasswordUncheckedUpdateWithoutRotationsInput>
  }

  export type PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput = {
    create?: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
    connectOrCreate?: PasswordRotationPolicyCreateOrConnectWithoutRotationsInput
    upsert?: PasswordRotationPolicyUpsertWithoutRotationsInput
    disconnect?: PasswordRotationPolicyWhereInput | boolean
    delete?: PasswordRotationPolicyWhereInput | boolean
    connect?: PasswordRotationPolicyWhereUniqueInput
    update?: XOR<XOR<PasswordRotationPolicyUpdateToOneWithWhereWithoutRotationsInput, PasswordRotationPolicyUpdateWithoutRotationsInput>, PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput>
  }

  export type UserUpdateOneRequiredWithoutPasswordRotationsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordRotationsInput
    upsert?: UserUpsertWithoutPasswordRotationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordRotationsInput, UserUpdateWithoutPasswordRotationsInput>, UserUncheckedUpdateWithoutPasswordRotationsInput>
  }

  export type FolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    connect?: FolderWhereUniqueInput
  }

  export type FolderCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type PasswordCreateNestedManyWithoutFolderInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type PasswordUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
  }

  export type FolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    upsert?: FolderUpsertWithoutChildrenInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutChildrenInput, FolderUpdateWithoutChildrenInput>, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type PasswordUpdateManyWithoutFolderNestedInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutFolderInput | PasswordUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutFolderInput | PasswordUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutFolderInput | PasswordUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type PasswordUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput> | PasswordCreateWithoutFolderInput[] | PasswordUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: PasswordCreateOrConnectWithoutFolderInput | PasswordCreateOrConnectWithoutFolderInput[]
    upsert?: PasswordUpsertWithWhereUniqueWithoutFolderInput | PasswordUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: PasswordCreateManyFolderInputEnvelope
    set?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    disconnect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    delete?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    connect?: PasswordWhereUniqueInput | PasswordWhereUniqueInput[]
    update?: PasswordUpdateWithWhereUniqueWithoutFolderInput | PasswordUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: PasswordUpdateManyWithWhereWithoutFolderInput | PasswordUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutSharedWithInput = {
    create?: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutSharedWithInput
    connect?: PasswordWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedPasswordsInput = {
    create?: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedPasswordsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSharedPasswordsInput = {
    create?: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSharedPasswordsInput
    connect?: TeamWhereUniqueInput
  }

  export type EnumSharePermissionFieldUpdateOperationsInput = {
    set?: $Enums.SharePermission
  }

  export type PasswordUpdateOneRequiredWithoutSharedWithNestedInput = {
    create?: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutSharedWithInput
    upsert?: PasswordUpsertWithoutSharedWithInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutSharedWithInput, PasswordUpdateWithoutSharedWithInput>, PasswordUncheckedUpdateWithoutSharedWithInput>
  }

  export type UserUpdateOneWithoutSharedPasswordsNestedInput = {
    create?: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedPasswordsInput
    upsert?: UserUpsertWithoutSharedPasswordsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedPasswordsInput, UserUpdateWithoutSharedPasswordsInput>, UserUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type TeamUpdateOneWithoutSharedPasswordsNestedInput = {
    create?: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSharedPasswordsInput
    upsert?: TeamUpsertWithoutSharedPasswordsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSharedPasswordsInput, TeamUpdateWithoutSharedPasswordsInput>, TeamUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type PasswordShareCreateNestedManyWithoutTeamInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type PasswordShareUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type PasswordShareUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutTeamInput | PasswordShareUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutTeamInput | PasswordShareUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutTeamInput | PasswordShareUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type PasswordShareUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput> | PasswordShareCreateWithoutTeamInput[] | PasswordShareUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PasswordShareCreateOrConnectWithoutTeamInput | PasswordShareCreateOrConnectWithoutTeamInput[]
    upsert?: PasswordShareUpsertWithWhereUniqueWithoutTeamInput | PasswordShareUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PasswordShareCreateManyTeamInputEnvelope
    set?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    disconnect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    delete?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    connect?: PasswordShareWhereUniqueInput | PasswordShareWhereUniqueInput[]
    update?: PasswordShareUpdateWithWhereUniqueWithoutTeamInput | PasswordShareUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PasswordShareUpdateManyWithWhereWithoutTeamInput | PasswordShareUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type PasswordTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
  }

  export type PasswordTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutTagInput | PasswordTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutTagInput | PasswordTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutTagInput | PasswordTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput> | PasswordTagCreateWithoutTagInput[] | PasswordTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PasswordTagCreateOrConnectWithoutTagInput | PasswordTagCreateOrConnectWithoutTagInput[]
    upsert?: PasswordTagUpsertWithWhereUniqueWithoutTagInput | PasswordTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PasswordTagCreateManyTagInputEnvelope
    set?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    disconnect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    delete?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    connect?: PasswordTagWhereUniqueInput | PasswordTagWhereUniqueInput[]
    update?: PasswordTagUpdateWithWhereUniqueWithoutTagInput | PasswordTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PasswordTagUpdateManyWithWhereWithoutTagInput | PasswordTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
  }

  export type PasswordCreateNestedOneWithoutTagsInput = {
    create?: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutTagsInput
    connect?: PasswordWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPasswordsInput = {
    create?: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPasswordsInput
    connect?: TagWhereUniqueInput
  }

  export type PasswordUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PasswordCreateOrConnectWithoutTagsInput
    upsert?: PasswordUpsertWithoutTagsInput
    connect?: PasswordWhereUniqueInput
    update?: XOR<XOR<PasswordUpdateToOneWithWhereWithoutTagsInput, PasswordUpdateWithoutTagsInput>, PasswordUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPasswordsNestedInput = {
    create?: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPasswordsInput
    upsert?: TagUpsertWithoutPasswordsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPasswordsInput, TagUpdateWithoutPasswordsInput>, TagUncheckedUpdateWithoutPasswordsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditStatus
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutCreatedRolesInput = {
    create?: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedRolesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRolesInput
    upsert?: UserUpsertWithoutCreatedRolesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRolesInput, UserUpdateWithoutCreatedRolesInput>, UserUncheckedUpdateWithoutCreatedRolesInput>
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type UserCreateNestedOneWithoutMfaCredentialsInput = {
    create?: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutMfaCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaCredentialsInput
    upsert?: UserUpsertWithoutMfaCredentialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMfaCredentialsInput, UserUpdateWithoutMfaCredentialsInput>, UserUncheckedUpdateWithoutMfaCredentialsInput>
  }

  export type UserCreateNestedOneWithoutRecoveryCodesInput = {
    create?: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecoveryCodesNestedInput = {
    create?: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryCodesInput
    upsert?: UserUpsertWithoutRecoveryCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecoveryCodesInput, UserUpdateWithoutRecoveryCodesInput>, UserUncheckedUpdateWithoutRecoveryCodesInput>
  }

  export type SavedSearchCreatefolderIdsInput = {
    set: string[]
  }

  export type SavedSearchCreatetagIdsInput = {
    set: string[]
  }

  export type SavedSearchCreatesearchFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSavedSearchesInput = {
    create?: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedSearchesInput
    connect?: UserWhereUniqueInput
  }

  export type SavedSearchUpdatefolderIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SavedSearchUpdatetagIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SavedSearchUpdatesearchFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSavedSearchesNestedInput = {
    create?: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedSearchesInput
    upsert?: UserUpsertWithoutSavedSearchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedSearchesInput, UserUpdateWithoutSavedSearchesInput>, UserUncheckedUpdateWithoutSavedSearchesInput>
  }

  export type SearchHistoryCreatefolderIdsInput = {
    set: string[]
  }

  export type SearchHistoryCreatetagIdsInput = {
    set: string[]
  }

  export type SearchHistoryCreatesearchFieldsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSearchHistoryInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type SearchHistoryUpdatefolderIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SearchHistoryUpdatetagIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SearchHistoryUpdatesearchFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSearchHistoryNestedInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    upsert?: UserUpsertWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchHistoryInput, UserUpdateWithoutSearchHistoryInput>, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserCreateNestedOneWithoutPasswordTemplatesInput = {
    create?: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTemplatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneWithoutPasswordTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordTemplatesInput
    upsert?: UserUpsertWithoutPasswordTemplatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordTemplatesInput, UserUpdateWithoutPasswordTemplatesInput>, UserUncheckedUpdateWithoutPasswordTemplatesInput>
  }

  export type CompanyUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTemplatesInput
    upsert?: CompanyUpsertWithoutTemplatesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTemplatesInput, CompanyUpdateWithoutTemplatesInput>, CompanyUncheckedUpdateWithoutTemplatesInput>
  }

  export type UserCreateNestedOneWithoutEmailVerificationTokensInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput = {
    create?: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput
    upsert?: UserUpsertWithoutEmailVerificationTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput, UserUpdateWithoutEmailVerificationTokensInput>, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserCreateNestedOneWithoutSecurityQuestionsInput = {
    create?: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSecurityQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityQuestionsInput
    upsert?: UserUpsertWithoutSecurityQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityQuestionsInput, UserUpdateWithoutSecurityQuestionsInput>, UserUncheckedUpdateWithoutSecurityQuestionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumMfaMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableFilter<$PrismaModel> | $Enums.MfaMethod | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumMfaMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMfaMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.MfaMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumMfaMethodNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPasswordStrengthFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthFilter<$PrismaModel> | $Enums.PasswordStrength
  }

  export type NestedEnumPasswordStrengthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PasswordStrength | EnumPasswordStrengthFieldRefInput<$PrismaModel>
    in?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    notIn?: $Enums.PasswordStrength[] | ListEnumPasswordStrengthFieldRefInput<$PrismaModel>
    not?: NestedEnumPasswordStrengthWithAggregatesFilter<$PrismaModel> | $Enums.PasswordStrength
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPasswordStrengthFilter<$PrismaModel>
    _max?: NestedEnumPasswordStrengthFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSharePermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionFilter<$PrismaModel> | $Enums.SharePermission
  }

  export type NestedEnumSharePermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SharePermission | EnumSharePermissionFieldRefInput<$PrismaModel>
    in?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SharePermission[] | ListEnumSharePermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumSharePermissionWithAggregatesFilter<$PrismaModel> | $Enums.SharePermission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSharePermissionFilter<$PrismaModel>
    _max?: NestedEnumSharePermissionFilter<$PrismaModel>
  }

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type NestedEnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTemplateCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutPasswordTemplatesInput
  }

  export type PasswordTemplateUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateCreateOrConnectWithoutCompanyInput = {
    where: PasswordTemplateWhereUniqueInput
    create: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type PasswordTemplateCreateManyCompanyInputEnvelope = {
    data: PasswordTemplateCreateManyCompanyInput | PasswordTemplateCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryEmailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaMethod?: EnumMfaMethodNullableFilter<"User"> | $Enums.MfaMethod | null
    companyId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: StringNullableFilter<"User"> | string | null
  }

  export type PasswordTemplateUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PasswordTemplateWhereUniqueInput
    update: XOR<PasswordTemplateUpdateWithoutCompanyInput, PasswordTemplateUncheckedUpdateWithoutCompanyInput>
    create: XOR<PasswordTemplateCreateWithoutCompanyInput, PasswordTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type PasswordTemplateUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PasswordTemplateWhereUniqueInput
    data: XOR<PasswordTemplateUpdateWithoutCompanyInput, PasswordTemplateUncheckedUpdateWithoutCompanyInput>
  }

  export type PasswordTemplateUpdateManyWithWhereWithoutCompanyInput = {
    where: PasswordTemplateScalarWhereInput
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PasswordTemplateScalarWhereInput = {
    AND?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
    OR?: PasswordTemplateScalarWhereInput[]
    NOT?: PasswordTemplateScalarWhereInput | PasswordTemplateScalarWhereInput[]
    id?: StringFilter<"PasswordTemplate"> | string
    name?: StringFilter<"PasswordTemplate"> | string
    description?: StringNullableFilter<"PasswordTemplate"> | string | null
    service?: StringNullableFilter<"PasswordTemplate"> | string | null
    icon?: StringNullableFilter<"PasswordTemplate"> | string | null
    category?: StringNullableFilter<"PasswordTemplate"> | string | null
    isSystem?: BoolFilter<"PasswordTemplate"> | boolean
    isPublic?: BoolFilter<"PasswordTemplate"> | boolean
    ownerId?: StringNullableFilter<"PasswordTemplate"> | string | null
    companyId?: StringNullableFilter<"PasswordTemplate"> | string | null
    defaultFields?: JsonFilter<"PasswordTemplate">
    usageCount?: IntFilter<"PasswordTemplate"> | number
    createdAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordTemplate"> | Date | string
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PasswordTemplateCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PasswordTemplateUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type PasswordCreateWithoutOwnerInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutOwnerInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordCreateManyOwnerInputEnvelope = {
    data: PasswordCreateManyOwnerInput | PasswordCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PasswordShareCreateWithoutUserInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutSharedWithInput
    team?: TeamCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateWithoutUserInput = {
    id?: string
    passwordId: string
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareCreateOrConnectWithoutUserInput = {
    where: PasswordShareWhereUniqueInput
    create: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput>
  }

  export type PasswordShareCreateManyUserInputEnvelope = {
    data: PasswordShareCreateManyUserInput | PasswordShareCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    isTrusted?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    isTrusted?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MfaCredentialCreateWithoutUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialUncheckedCreateWithoutUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type MfaCredentialCreateOrConnectWithoutUserInput = {
    where: MfaCredentialWhereUniqueInput
    create: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput>
  }

  export type MfaCredentialCreateManyUserInputEnvelope = {
    data: MfaCredentialCreateManyUserInput | MfaCredentialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecoveryCodeCreateWithoutUserInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeUncheckedCreateWithoutUserInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RecoveryCodeCreateOrConnectWithoutUserInput = {
    where: RecoveryCodeWhereUniqueInput
    create: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput>
  }

  export type RecoveryCodeCreateManyUserInputEnvelope = {
    data: RecoveryCodeCreateManyUserInput | RecoveryCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordHistoryCreateWithoutChangedByUserInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
    passwordEntry: PasswordCreateNestedOneWithoutHistoryInput
  }

  export type PasswordHistoryUncheckedCreateWithoutChangedByUserInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateOrConnectWithoutChangedByUserInput = {
    where: PasswordHistoryWhereUniqueInput
    create: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput>
  }

  export type PasswordHistoryCreateManyChangedByUserInputEnvelope = {
    data: PasswordHistoryCreateManyChangedByUserInput | PasswordHistoryCreateManyChangedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordBreachCreateWithoutCheckedByUserInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutBreachesInput
    resolvedByUser?: UserCreateNestedOneWithoutPasswordBreachesResolvedInput
  }

  export type PasswordBreachUncheckedCreateWithoutCheckedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachCreateOrConnectWithoutCheckedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    create: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput>
  }

  export type PasswordBreachCreateManyCheckedByUserInputEnvelope = {
    data: PasswordBreachCreateManyCheckedByUserInput | PasswordBreachCreateManyCheckedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordBreachCreateWithoutResolvedByUserInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutBreachesInput
    checkedByUser: UserCreateNestedOneWithoutPasswordBreachesCheckedInput
  }

  export type PasswordBreachUncheckedCreateWithoutResolvedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
  }

  export type PasswordBreachCreateOrConnectWithoutResolvedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    create: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput>
  }

  export type PasswordBreachCreateManyResolvedByUserInputEnvelope = {
    data: PasswordBreachCreateManyResolvedByUserInput | PasswordBreachCreateManyResolvedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationPolicyCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyCreateOrConnectWithoutOwnerInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    create: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordRotationPolicyCreateManyOwnerInputEnvelope = {
    data: PasswordRotationPolicyCreateManyOwnerInput | PasswordRotationPolicyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationCreateWithoutRotatedByUserInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    password: PasswordCreateNestedOneWithoutRotationsInput
    policy?: PasswordRotationPolicyCreateNestedOneWithoutRotationsInput
  }

  export type PasswordRotationUncheckedCreateWithoutRotatedByUserInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationCreateOrConnectWithoutRotatedByUserInput = {
    where: PasswordRotationWhereUniqueInput
    create: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput>
  }

  export type PasswordRotationCreateManyRotatedByUserInputEnvelope = {
    data: PasswordRotationCreateManyRotatedByUserInput | PasswordRotationCreateManyRotatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedSearchCreateWithoutUserInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SavedSearchCreateOrConnectWithoutUserInput = {
    where: SavedSearchWhereUniqueInput
    create: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput>
  }

  export type SavedSearchCreateManyUserInputEnvelope = {
    data: SavedSearchCreateManyUserInput | SavedSearchCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchHistoryCreateWithoutUserInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type SearchHistoryCreateOrConnectWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryCreateManyUserInputEnvelope = {
    data: SearchHistoryCreateManyUserInput | SearchHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTemplateCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutTemplatesInput
  }

  export type PasswordTemplateUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordTemplateCreateOrConnectWithoutOwnerInput = {
    where: PasswordTemplateWhereUniqueInput
    create: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordTemplateCreateManyOwnerInputEnvelope = {
    data: PasswordTemplateCreateManyOwnerInput | PasswordTemplateCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutCreatedByInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
  }

  export type RoleCreateManyCreatedByInputEnvelope = {
    data: RoleCreateManyCreatedByInput | RoleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type EmailVerificationTokenCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailVerificationTokenCreateOrConnectWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenCreateManyUserInputEnvelope = {
    data: EmailVerificationTokenCreateManyUserInput | EmailVerificationTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SecurityQuestionCreateWithoutUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionUncheckedCreateWithoutUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityQuestionCreateOrConnectWithoutUserInput = {
    where: SecurityQuestionWhereUniqueInput
    create: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput>
  }

  export type SecurityQuestionCreateManyUserInputEnvelope = {
    data: SecurityQuestionCreateManyUserInput | SecurityQuestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PasswordTemplateUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PasswordTemplateUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PasswordUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PasswordWhereUniqueInput
    update: XOR<PasswordUpdateWithoutOwnerInput, PasswordUncheckedUpdateWithoutOwnerInput>
    create: XOR<PasswordCreateWithoutOwnerInput, PasswordUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PasswordWhereUniqueInput
    data: XOR<PasswordUpdateWithoutOwnerInput, PasswordUncheckedUpdateWithoutOwnerInput>
  }

  export type PasswordUpdateManyWithWhereWithoutOwnerInput = {
    where: PasswordScalarWhereInput
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PasswordScalarWhereInput = {
    AND?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
    OR?: PasswordScalarWhereInput[]
    NOT?: PasswordScalarWhereInput | PasswordScalarWhereInput[]
    id?: StringFilter<"Password"> | string
    name?: StringFilter<"Password"> | string
    username?: StringFilter<"Password"> | string
    password?: StringFilter<"Password"> | string
    url?: StringNullableFilter<"Password"> | string | null
    notes?: StringNullableFilter<"Password"> | string | null
    folderId?: StringNullableFilter<"Password"> | string | null
    strength?: EnumPasswordStrengthFilter<"Password"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"Password"> | boolean
    totpSecret?: StringNullableFilter<"Password"> | string | null
    expiresAt?: DateTimeNullableFilter<"Password"> | Date | string | null
    isFavorite?: BoolFilter<"Password"> | boolean
    ownerId?: StringFilter<"Password"> | string
    createdAt?: DateTimeFilter<"Password"> | Date | string
    updatedAt?: DateTimeFilter<"Password"> | Date | string
    rotationPolicyId?: StringNullableFilter<"Password"> | string | null
  }

  export type PasswordShareUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordShareWhereUniqueInput
    update: XOR<PasswordShareUpdateWithoutUserInput, PasswordShareUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordShareCreateWithoutUserInput, PasswordShareUncheckedCreateWithoutUserInput>
  }

  export type PasswordShareUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordShareWhereUniqueInput
    data: XOR<PasswordShareUpdateWithoutUserInput, PasswordShareUncheckedUpdateWithoutUserInput>
  }

  export type PasswordShareUpdateManyWithWhereWithoutUserInput = {
    where: PasswordShareScalarWhereInput
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordShareScalarWhereInput = {
    AND?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
    OR?: PasswordShareScalarWhereInput[]
    NOT?: PasswordShareScalarWhereInput | PasswordShareScalarWhereInput[]
    id?: StringFilter<"PasswordShare"> | string
    passwordId?: StringFilter<"PasswordShare"> | string
    userId?: StringNullableFilter<"PasswordShare"> | string | null
    teamId?: StringNullableFilter<"PasswordShare"> | string | null
    permission?: EnumSharePermissionFilter<"PasswordShare"> | $Enums.SharePermission
    createdAt?: DateTimeFilter<"PasswordShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PasswordShare"> | Date | string | null
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: EnumAuditStatusFilter<"AuditLog"> | $Enums.AuditStatus
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    deviceType?: StringNullableFilter<"Session"> | string | null
    isTrusted?: BoolFilter<"Session"> | boolean
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type MfaCredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: MfaCredentialWhereUniqueInput
    update: XOR<MfaCredentialUpdateWithoutUserInput, MfaCredentialUncheckedUpdateWithoutUserInput>
    create: XOR<MfaCredentialCreateWithoutUserInput, MfaCredentialUncheckedCreateWithoutUserInput>
  }

  export type MfaCredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: MfaCredentialWhereUniqueInput
    data: XOR<MfaCredentialUpdateWithoutUserInput, MfaCredentialUncheckedUpdateWithoutUserInput>
  }

  export type MfaCredentialUpdateManyWithWhereWithoutUserInput = {
    where: MfaCredentialScalarWhereInput
    data: XOR<MfaCredentialUpdateManyMutationInput, MfaCredentialUncheckedUpdateManyWithoutUserInput>
  }

  export type MfaCredentialScalarWhereInput = {
    AND?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
    OR?: MfaCredentialScalarWhereInput[]
    NOT?: MfaCredentialScalarWhereInput | MfaCredentialScalarWhereInput[]
    id?: StringFilter<"MfaCredential"> | string
    userId?: StringFilter<"MfaCredential"> | string
    credentialId?: StringFilter<"MfaCredential"> | string
    publicKey?: StringFilter<"MfaCredential"> | string
    counter?: BigIntFilter<"MfaCredential"> | bigint | number
    deviceType?: StringNullableFilter<"MfaCredential"> | string | null
    backedUp?: BoolFilter<"MfaCredential"> | boolean
    transports?: StringNullableFilter<"MfaCredential"> | string | null
    createdAt?: DateTimeFilter<"MfaCredential"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"MfaCredential"> | Date | string | null
  }

  export type RecoveryCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: RecoveryCodeWhereUniqueInput
    update: XOR<RecoveryCodeUpdateWithoutUserInput, RecoveryCodeUncheckedUpdateWithoutUserInput>
    create: XOR<RecoveryCodeCreateWithoutUserInput, RecoveryCodeUncheckedCreateWithoutUserInput>
  }

  export type RecoveryCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: RecoveryCodeWhereUniqueInput
    data: XOR<RecoveryCodeUpdateWithoutUserInput, RecoveryCodeUncheckedUpdateWithoutUserInput>
  }

  export type RecoveryCodeUpdateManyWithWhereWithoutUserInput = {
    where: RecoveryCodeScalarWhereInput
    data: XOR<RecoveryCodeUpdateManyMutationInput, RecoveryCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type RecoveryCodeScalarWhereInput = {
    AND?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
    OR?: RecoveryCodeScalarWhereInput[]
    NOT?: RecoveryCodeScalarWhereInput | RecoveryCodeScalarWhereInput[]
    id?: StringFilter<"RecoveryCode"> | string
    userId?: StringFilter<"RecoveryCode"> | string
    codeHash?: StringFilter<"RecoveryCode"> | string
    used?: BoolFilter<"RecoveryCode"> | boolean
    usedAt?: DateTimeNullableFilter<"RecoveryCode"> | Date | string | null
    createdAt?: DateTimeFilter<"RecoveryCode"> | Date | string
  }

  export type PasswordHistoryUpsertWithWhereUniqueWithoutChangedByUserInput = {
    where: PasswordHistoryWhereUniqueInput
    update: XOR<PasswordHistoryUpdateWithoutChangedByUserInput, PasswordHistoryUncheckedUpdateWithoutChangedByUserInput>
    create: XOR<PasswordHistoryCreateWithoutChangedByUserInput, PasswordHistoryUncheckedCreateWithoutChangedByUserInput>
  }

  export type PasswordHistoryUpdateWithWhereUniqueWithoutChangedByUserInput = {
    where: PasswordHistoryWhereUniqueInput
    data: XOR<PasswordHistoryUpdateWithoutChangedByUserInput, PasswordHistoryUncheckedUpdateWithoutChangedByUserInput>
  }

  export type PasswordHistoryUpdateManyWithWhereWithoutChangedByUserInput = {
    where: PasswordHistoryScalarWhereInput
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyWithoutChangedByUserInput>
  }

  export type PasswordHistoryScalarWhereInput = {
    AND?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
    OR?: PasswordHistoryScalarWhereInput[]
    NOT?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
    id?: StringFilter<"PasswordHistory"> | string
    passwordId?: StringFilter<"PasswordHistory"> | string
    name?: StringFilter<"PasswordHistory"> | string
    username?: StringFilter<"PasswordHistory"> | string
    password?: StringFilter<"PasswordHistory"> | string
    url?: StringNullableFilter<"PasswordHistory"> | string | null
    notes?: StringNullableFilter<"PasswordHistory"> | string | null
    folderId?: StringNullableFilter<"PasswordHistory"> | string | null
    strength?: EnumPasswordStrengthFilter<"PasswordHistory"> | $Enums.PasswordStrength
    hasTotp?: BoolFilter<"PasswordHistory"> | boolean
    totpSecret?: StringNullableFilter<"PasswordHistory"> | string | null
    expiresAt?: DateTimeNullableFilter<"PasswordHistory"> | Date | string | null
    changedBy?: StringFilter<"PasswordHistory"> | string
    changeType?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
  }

  export type PasswordBreachUpsertWithWhereUniqueWithoutCheckedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    update: XOR<PasswordBreachUpdateWithoutCheckedByUserInput, PasswordBreachUncheckedUpdateWithoutCheckedByUserInput>
    create: XOR<PasswordBreachCreateWithoutCheckedByUserInput, PasswordBreachUncheckedCreateWithoutCheckedByUserInput>
  }

  export type PasswordBreachUpdateWithWhereUniqueWithoutCheckedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    data: XOR<PasswordBreachUpdateWithoutCheckedByUserInput, PasswordBreachUncheckedUpdateWithoutCheckedByUserInput>
  }

  export type PasswordBreachUpdateManyWithWhereWithoutCheckedByUserInput = {
    where: PasswordBreachScalarWhereInput
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyWithoutCheckedByUserInput>
  }

  export type PasswordBreachScalarWhereInput = {
    AND?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
    OR?: PasswordBreachScalarWhereInput[]
    NOT?: PasswordBreachScalarWhereInput | PasswordBreachScalarWhereInput[]
    id?: StringFilter<"PasswordBreach"> | string
    passwordId?: StringFilter<"PasswordBreach"> | string
    isBreached?: BoolFilter<"PasswordBreach"> | boolean
    breachCount?: IntFilter<"PasswordBreach"> | number
    hashPrefix?: StringFilter<"PasswordBreach"> | string
    checkedAt?: DateTimeFilter<"PasswordBreach"> | Date | string
    checkedBy?: StringFilter<"PasswordBreach"> | string
    resolved?: BoolFilter<"PasswordBreach"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PasswordBreach"> | Date | string | null
    resolvedBy?: StringNullableFilter<"PasswordBreach"> | string | null
  }

  export type PasswordBreachUpsertWithWhereUniqueWithoutResolvedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    update: XOR<PasswordBreachUpdateWithoutResolvedByUserInput, PasswordBreachUncheckedUpdateWithoutResolvedByUserInput>
    create: XOR<PasswordBreachCreateWithoutResolvedByUserInput, PasswordBreachUncheckedCreateWithoutResolvedByUserInput>
  }

  export type PasswordBreachUpdateWithWhereUniqueWithoutResolvedByUserInput = {
    where: PasswordBreachWhereUniqueInput
    data: XOR<PasswordBreachUpdateWithoutResolvedByUserInput, PasswordBreachUncheckedUpdateWithoutResolvedByUserInput>
  }

  export type PasswordBreachUpdateManyWithWhereWithoutResolvedByUserInput = {
    where: PasswordBreachScalarWhereInput
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyWithoutResolvedByUserInput>
  }

  export type PasswordRotationPolicyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    update: XOR<PasswordRotationPolicyUpdateWithoutOwnerInput, PasswordRotationPolicyUncheckedUpdateWithoutOwnerInput>
    create: XOR<PasswordRotationPolicyCreateWithoutOwnerInput, PasswordRotationPolicyUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordRotationPolicyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    data: XOR<PasswordRotationPolicyUpdateWithoutOwnerInput, PasswordRotationPolicyUncheckedUpdateWithoutOwnerInput>
  }

  export type PasswordRotationPolicyUpdateManyWithWhereWithoutOwnerInput = {
    where: PasswordRotationPolicyScalarWhereInput
    data: XOR<PasswordRotationPolicyUpdateManyMutationInput, PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PasswordRotationPolicyScalarWhereInput = {
    AND?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
    OR?: PasswordRotationPolicyScalarWhereInput[]
    NOT?: PasswordRotationPolicyScalarWhereInput | PasswordRotationPolicyScalarWhereInput[]
    id?: StringFilter<"PasswordRotationPolicy"> | string
    name?: StringFilter<"PasswordRotationPolicy"> | string
    description?: StringNullableFilter<"PasswordRotationPolicy"> | string | null
    rotationDays?: IntFilter<"PasswordRotationPolicy"> | number
    reminderDays?: IntFilter<"PasswordRotationPolicy"> | number
    autoRotate?: BoolFilter<"PasswordRotationPolicy"> | boolean
    requireApproval?: BoolFilter<"PasswordRotationPolicy"> | boolean
    isActive?: BoolFilter<"PasswordRotationPolicy"> | boolean
    ownerId?: StringFilter<"PasswordRotationPolicy"> | string
    createdAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordRotationPolicy"> | Date | string
  }

  export type PasswordRotationUpsertWithWhereUniqueWithoutRotatedByUserInput = {
    where: PasswordRotationWhereUniqueInput
    update: XOR<PasswordRotationUpdateWithoutRotatedByUserInput, PasswordRotationUncheckedUpdateWithoutRotatedByUserInput>
    create: XOR<PasswordRotationCreateWithoutRotatedByUserInput, PasswordRotationUncheckedCreateWithoutRotatedByUserInput>
  }

  export type PasswordRotationUpdateWithWhereUniqueWithoutRotatedByUserInput = {
    where: PasswordRotationWhereUniqueInput
    data: XOR<PasswordRotationUpdateWithoutRotatedByUserInput, PasswordRotationUncheckedUpdateWithoutRotatedByUserInput>
  }

  export type PasswordRotationUpdateManyWithWhereWithoutRotatedByUserInput = {
    where: PasswordRotationScalarWhereInput
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyWithoutRotatedByUserInput>
  }

  export type PasswordRotationScalarWhereInput = {
    AND?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
    OR?: PasswordRotationScalarWhereInput[]
    NOT?: PasswordRotationScalarWhereInput | PasswordRotationScalarWhereInput[]
    id?: StringFilter<"PasswordRotation"> | string
    passwordId?: StringFilter<"PasswordRotation"> | string
    policyId?: StringNullableFilter<"PasswordRotation"> | string | null
    rotationType?: StringFilter<"PasswordRotation"> | string
    oldPassword?: StringNullableFilter<"PasswordRotation"> | string | null
    newPassword?: StringFilter<"PasswordRotation"> | string
    rotatedAt?: DateTimeFilter<"PasswordRotation"> | Date | string
    rotatedBy?: StringFilter<"PasswordRotation"> | string
    scheduledFor?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PasswordRotation"> | Date | string | null
    status?: StringFilter<"PasswordRotation"> | string
    notes?: StringNullableFilter<"PasswordRotation"> | string | null
  }

  export type SavedSearchUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedSearchWhereUniqueInput
    update: XOR<SavedSearchUpdateWithoutUserInput, SavedSearchUncheckedUpdateWithoutUserInput>
    create: XOR<SavedSearchCreateWithoutUserInput, SavedSearchUncheckedCreateWithoutUserInput>
  }

  export type SavedSearchUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedSearchWhereUniqueInput
    data: XOR<SavedSearchUpdateWithoutUserInput, SavedSearchUncheckedUpdateWithoutUserInput>
  }

  export type SavedSearchUpdateManyWithWhereWithoutUserInput = {
    where: SavedSearchScalarWhereInput
    data: XOR<SavedSearchUpdateManyMutationInput, SavedSearchUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedSearchScalarWhereInput = {
    AND?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
    OR?: SavedSearchScalarWhereInput[]
    NOT?: SavedSearchScalarWhereInput | SavedSearchScalarWhereInput[]
    id?: StringFilter<"SavedSearch"> | string
    userId?: StringFilter<"SavedSearch"> | string
    name?: StringFilter<"SavedSearch"> | string
    query?: StringNullableFilter<"SavedSearch"> | string | null
    folderIds?: StringNullableListFilter<"SavedSearch">
    tagIds?: StringNullableListFilter<"SavedSearch">
    filter?: StringNullableFilter<"SavedSearch"> | string | null
    searchFields?: StringNullableListFilter<"SavedSearch">
    createdAt?: DateTimeFilter<"SavedSearch"> | Date | string
    updatedAt?: DateTimeFilter<"SavedSearch"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"SavedSearch"> | Date | string | null
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutUserInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchHistoryScalarWhereInput = {
    AND?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    OR?: SearchHistoryScalarWhereInput[]
    NOT?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringNullableFilter<"SearchHistory"> | string | null
    folderIds?: StringNullableListFilter<"SearchHistory">
    tagIds?: StringNullableListFilter<"SearchHistory">
    filter?: StringNullableFilter<"SearchHistory"> | string | null
    searchFields?: StringNullableListFilter<"SearchHistory">
    resultCount?: IntNullableFilter<"SearchHistory"> | number | null
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
  }

  export type PasswordTemplateUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PasswordTemplateWhereUniqueInput
    update: XOR<PasswordTemplateUpdateWithoutOwnerInput, PasswordTemplateUncheckedUpdateWithoutOwnerInput>
    create: XOR<PasswordTemplateCreateWithoutOwnerInput, PasswordTemplateUncheckedCreateWithoutOwnerInput>
  }

  export type PasswordTemplateUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PasswordTemplateWhereUniqueInput
    data: XOR<PasswordTemplateUpdateWithoutOwnerInput, PasswordTemplateUncheckedUpdateWithoutOwnerInput>
  }

  export type PasswordTemplateUpdateManyWithWhereWithoutOwnerInput = {
    where: PasswordTemplateScalarWhereInput
    data: XOR<PasswordTemplateUpdateManyMutationInput, PasswordTemplateUncheckedUpdateManyWithoutOwnerInput>
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutCreatedByInput, RoleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutCreatedByInput, RoleUncheckedUpdateWithoutCreatedByInput>
  }

  export type RoleUpdateManyWithWhereWithoutCreatedByInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    createdById?: StringNullableFilter<"Role"> | string | null
  }

  export type EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    update: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<EmailVerificationTokenCreateWithoutUserInput, EmailVerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput
    data: XOR<EmailVerificationTokenUpdateWithoutUserInput, EmailVerificationTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailVerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: EmailVerificationTokenScalarWhereInput
    data: XOR<EmailVerificationTokenUpdateManyMutationInput, EmailVerificationTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailVerificationTokenScalarWhereInput = {
    AND?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
    OR?: EmailVerificationTokenScalarWhereInput[]
    NOT?: EmailVerificationTokenScalarWhereInput | EmailVerificationTokenScalarWhereInput[]
    id?: StringFilter<"EmailVerificationToken"> | string
    token?: StringFilter<"EmailVerificationToken"> | string
    userId?: StringFilter<"EmailVerificationToken"> | string
    email?: StringFilter<"EmailVerificationToken"> | string
    expiresAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailVerificationToken"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type SecurityQuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: SecurityQuestionWhereUniqueInput
    update: XOR<SecurityQuestionUpdateWithoutUserInput, SecurityQuestionUncheckedUpdateWithoutUserInput>
    create: XOR<SecurityQuestionCreateWithoutUserInput, SecurityQuestionUncheckedCreateWithoutUserInput>
  }

  export type SecurityQuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: SecurityQuestionWhereUniqueInput
    data: XOR<SecurityQuestionUpdateWithoutUserInput, SecurityQuestionUncheckedUpdateWithoutUserInput>
  }

  export type SecurityQuestionUpdateManyWithWhereWithoutUserInput = {
    where: SecurityQuestionScalarWhereInput
    data: XOR<SecurityQuestionUpdateManyMutationInput, SecurityQuestionUncheckedUpdateManyWithoutUserInput>
  }

  export type SecurityQuestionScalarWhereInput = {
    AND?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
    OR?: SecurityQuestionScalarWhereInput[]
    NOT?: SecurityQuestionScalarWhereInput | SecurityQuestionScalarWhereInput[]
    id?: StringFilter<"SecurityQuestion"> | string
    userId?: StringFilter<"SecurityQuestion"> | string
    question?: StringFilter<"SecurityQuestion"> | string
    answerHash?: StringFilter<"SecurityQuestion"> | string
    createdAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityQuestion"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOwnedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedPasswordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
  }

  export type FolderCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
  }

  export type FolderUncheckedCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type FolderCreateOrConnectWithoutPasswordsInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
  }

  export type PasswordShareCreateWithoutPasswordInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user?: UserCreateNestedOneWithoutSharedPasswordsInput
    team?: TeamCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateWithoutPasswordInput = {
    id?: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareCreateOrConnectWithoutPasswordInput = {
    where: PasswordShareWhereUniqueInput
    create: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordShareCreateManyPasswordInputEnvelope = {
    data: PasswordShareCreateManyPasswordInput | PasswordShareCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTagCreateWithoutPasswordInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordTagUncheckedCreateWithoutPasswordInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordTagCreateOrConnectWithoutPasswordInput = {
    where: PasswordTagWhereUniqueInput
    create: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordTagCreateManyPasswordInputEnvelope = {
    data: PasswordTagCreateManyPasswordInput | PasswordTagCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordHistoryCreateWithoutPasswordEntryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
    changedByUser: UserCreateNestedOneWithoutPasswordHistoryInput
  }

  export type PasswordHistoryUncheckedCreateWithoutPasswordEntryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateOrConnectWithoutPasswordEntryInput = {
    where: PasswordHistoryWhereUniqueInput
    create: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput>
  }

  export type PasswordHistoryCreateManyPasswordEntryInputEnvelope = {
    data: PasswordHistoryCreateManyPasswordEntryInput | PasswordHistoryCreateManyPasswordEntryInput[]
    skipDuplicates?: boolean
  }

  export type PasswordBreachCreateWithoutPasswordInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    checkedByUser: UserCreateNestedOneWithoutPasswordBreachesCheckedInput
    resolvedByUser?: UserCreateNestedOneWithoutPasswordBreachesResolvedInput
  }

  export type PasswordBreachUncheckedCreateWithoutPasswordInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachCreateOrConnectWithoutPasswordInput = {
    where: PasswordBreachWhereUniqueInput
    create: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordBreachCreateManyPasswordInputEnvelope = {
    data: PasswordBreachCreateManyPasswordInput | PasswordBreachCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationCreateWithoutPasswordInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    policy?: PasswordRotationPolicyCreateNestedOneWithoutRotationsInput
    rotatedByUser: UserCreateNestedOneWithoutPasswordRotationsInput
  }

  export type PasswordRotationUncheckedCreateWithoutPasswordInput = {
    id?: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationCreateOrConnectWithoutPasswordInput = {
    where: PasswordRotationWhereUniqueInput
    create: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordRotationCreateManyPasswordInputEnvelope = {
    data: PasswordRotationCreateManyPasswordInput | PasswordRotationCreateManyPasswordInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationPolicyCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutRotationPoliciesInput
    rotations?: PasswordRotationCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PasswordRotationPolicyCreateOrConnectWithoutPasswordsInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    create: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
  }

  export type UserUpsertWithoutOwnedPasswordsInput = {
    update: XOR<UserUpdateWithoutOwnedPasswordsInput, UserUncheckedUpdateWithoutOwnedPasswordsInput>
    create: XOR<UserCreateWithoutOwnedPasswordsInput, UserUncheckedCreateWithoutOwnedPasswordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedPasswordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedPasswordsInput, UserUncheckedUpdateWithoutOwnedPasswordsInput>
  }

  export type UserUpdateWithoutOwnedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FolderUpsertWithoutPasswordsInput = {
    update: XOR<FolderUpdateWithoutPasswordsInput, FolderUncheckedUpdateWithoutPasswordsInput>
    create: XOR<FolderCreateWithoutPasswordsInput, FolderUncheckedCreateWithoutPasswordsInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutPasswordsInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutPasswordsInput, FolderUncheckedUpdateWithoutPasswordsInput>
  }

  export type FolderUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
  }

  export type FolderUncheckedUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PasswordShareUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordShareWhereUniqueInput
    update: XOR<PasswordShareUpdateWithoutPasswordInput, PasswordShareUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordShareCreateWithoutPasswordInput, PasswordShareUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordShareUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordShareWhereUniqueInput
    data: XOR<PasswordShareUpdateWithoutPasswordInput, PasswordShareUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordShareUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordShareScalarWhereInput
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordTagUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordTagWhereUniqueInput
    update: XOR<PasswordTagUpdateWithoutPasswordInput, PasswordTagUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordTagCreateWithoutPasswordInput, PasswordTagUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordTagUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordTagWhereUniqueInput
    data: XOR<PasswordTagUpdateWithoutPasswordInput, PasswordTagUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordTagUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordTagScalarWhereInput
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordTagScalarWhereInput = {
    AND?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
    OR?: PasswordTagScalarWhereInput[]
    NOT?: PasswordTagScalarWhereInput | PasswordTagScalarWhereInput[]
    id?: StringFilter<"PasswordTag"> | string
    passwordId?: StringFilter<"PasswordTag"> | string
    tagId?: StringFilter<"PasswordTag"> | string
    createdAt?: DateTimeFilter<"PasswordTag"> | Date | string
  }

  export type PasswordHistoryUpsertWithWhereUniqueWithoutPasswordEntryInput = {
    where: PasswordHistoryWhereUniqueInput
    update: XOR<PasswordHistoryUpdateWithoutPasswordEntryInput, PasswordHistoryUncheckedUpdateWithoutPasswordEntryInput>
    create: XOR<PasswordHistoryCreateWithoutPasswordEntryInput, PasswordHistoryUncheckedCreateWithoutPasswordEntryInput>
  }

  export type PasswordHistoryUpdateWithWhereUniqueWithoutPasswordEntryInput = {
    where: PasswordHistoryWhereUniqueInput
    data: XOR<PasswordHistoryUpdateWithoutPasswordEntryInput, PasswordHistoryUncheckedUpdateWithoutPasswordEntryInput>
  }

  export type PasswordHistoryUpdateManyWithWhereWithoutPasswordEntryInput = {
    where: PasswordHistoryScalarWhereInput
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryInput>
  }

  export type PasswordBreachUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordBreachWhereUniqueInput
    update: XOR<PasswordBreachUpdateWithoutPasswordInput, PasswordBreachUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordBreachCreateWithoutPasswordInput, PasswordBreachUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordBreachUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordBreachWhereUniqueInput
    data: XOR<PasswordBreachUpdateWithoutPasswordInput, PasswordBreachUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordBreachUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordBreachScalarWhereInput
    data: XOR<PasswordBreachUpdateManyMutationInput, PasswordBreachUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordRotationUpsertWithWhereUniqueWithoutPasswordInput = {
    where: PasswordRotationWhereUniqueInput
    update: XOR<PasswordRotationUpdateWithoutPasswordInput, PasswordRotationUncheckedUpdateWithoutPasswordInput>
    create: XOR<PasswordRotationCreateWithoutPasswordInput, PasswordRotationUncheckedCreateWithoutPasswordInput>
  }

  export type PasswordRotationUpdateWithWhereUniqueWithoutPasswordInput = {
    where: PasswordRotationWhereUniqueInput
    data: XOR<PasswordRotationUpdateWithoutPasswordInput, PasswordRotationUncheckedUpdateWithoutPasswordInput>
  }

  export type PasswordRotationUpdateManyWithWhereWithoutPasswordInput = {
    where: PasswordRotationScalarWhereInput
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyWithoutPasswordInput>
  }

  export type PasswordRotationPolicyUpsertWithoutPasswordsInput = {
    update: XOR<PasswordRotationPolicyUpdateWithoutPasswordsInput, PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput>
    create: XOR<PasswordRotationPolicyCreateWithoutPasswordsInput, PasswordRotationPolicyUncheckedCreateWithoutPasswordsInput>
    where?: PasswordRotationPolicyWhereInput
  }

  export type PasswordRotationPolicyUpdateToOneWithWhereWithoutPasswordsInput = {
    where?: PasswordRotationPolicyWhereInput
    data: XOR<PasswordRotationPolicyUpdateWithoutPasswordsInput, PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput>
  }

  export type PasswordRotationPolicyUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutRotationPoliciesNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordCreateWithoutHistoryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutHistoryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutHistoryInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutPasswordHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
  }

  export type PasswordUpsertWithoutHistoryInput = {
    update: XOR<PasswordUpdateWithoutHistoryInput, PasswordUncheckedUpdateWithoutHistoryInput>
    create: XOR<PasswordCreateWithoutHistoryInput, PasswordUncheckedCreateWithoutHistoryInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutHistoryInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutHistoryInput, PasswordUncheckedUpdateWithoutHistoryInput>
  }

  export type PasswordUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type UserUpsertWithoutPasswordHistoryInput = {
    update: XOR<UserUpdateWithoutPasswordHistoryInput, UserUncheckedUpdateWithoutPasswordHistoryInput>
    create: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordHistoryInput, UserUncheckedUpdateWithoutPasswordHistoryInput>
  }

  export type UserUpdateWithoutPasswordHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PasswordCreateWithoutBreachesInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutBreachesInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutBreachesInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
  }

  export type UserCreateWithoutPasswordBreachesCheckedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordBreachesCheckedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordBreachesCheckedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
  }

  export type UserCreateWithoutPasswordBreachesResolvedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordBreachesResolvedInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordBreachesResolvedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
  }

  export type PasswordUpsertWithoutBreachesInput = {
    update: XOR<PasswordUpdateWithoutBreachesInput, PasswordUncheckedUpdateWithoutBreachesInput>
    create: XOR<PasswordCreateWithoutBreachesInput, PasswordUncheckedCreateWithoutBreachesInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutBreachesInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutBreachesInput, PasswordUncheckedUpdateWithoutBreachesInput>
  }

  export type PasswordUpdateWithoutBreachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutBreachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type UserUpsertWithoutPasswordBreachesCheckedInput = {
    update: XOR<UserUpdateWithoutPasswordBreachesCheckedInput, UserUncheckedUpdateWithoutPasswordBreachesCheckedInput>
    create: XOR<UserCreateWithoutPasswordBreachesCheckedInput, UserUncheckedCreateWithoutPasswordBreachesCheckedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordBreachesCheckedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordBreachesCheckedInput, UserUncheckedUpdateWithoutPasswordBreachesCheckedInput>
  }

  export type UserUpdateWithoutPasswordBreachesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordBreachesCheckedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutPasswordBreachesResolvedInput = {
    update: XOR<UserUpdateWithoutPasswordBreachesResolvedInput, UserUncheckedUpdateWithoutPasswordBreachesResolvedInput>
    create: XOR<UserCreateWithoutPasswordBreachesResolvedInput, UserUncheckedCreateWithoutPasswordBreachesResolvedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordBreachesResolvedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordBreachesResolvedInput, UserUncheckedUpdateWithoutPasswordBreachesResolvedInput>
  }

  export type UserUpdateWithoutPasswordBreachesResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordBreachesResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRotationPoliciesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRotationPoliciesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRotationPoliciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
  }

  export type PasswordCreateWithoutRotationPolicyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
  }

  export type PasswordUncheckedCreateWithoutRotationPolicyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutRotationPolicyInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput>
  }

  export type PasswordCreateManyRotationPolicyInputEnvelope = {
    data: PasswordCreateManyRotationPolicyInput | PasswordCreateManyRotationPolicyInput[]
    skipDuplicates?: boolean
  }

  export type PasswordRotationCreateWithoutPolicyInput = {
    id?: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
    password: PasswordCreateNestedOneWithoutRotationsInput
    rotatedByUser: UserCreateNestedOneWithoutPasswordRotationsInput
  }

  export type PasswordRotationUncheckedCreateWithoutPolicyInput = {
    id?: string
    passwordId: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordRotationCreateOrConnectWithoutPolicyInput = {
    where: PasswordRotationWhereUniqueInput
    create: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput>
  }

  export type PasswordRotationCreateManyPolicyInputEnvelope = {
    data: PasswordRotationCreateManyPolicyInput | PasswordRotationCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRotationPoliciesInput = {
    update: XOR<UserUpdateWithoutRotationPoliciesInput, UserUncheckedUpdateWithoutRotationPoliciesInput>
    create: XOR<UserCreateWithoutRotationPoliciesInput, UserUncheckedCreateWithoutRotationPoliciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRotationPoliciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRotationPoliciesInput, UserUncheckedUpdateWithoutRotationPoliciesInput>
  }

  export type UserUpdateWithoutRotationPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRotationPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PasswordUpsertWithWhereUniqueWithoutRotationPolicyInput = {
    where: PasswordWhereUniqueInput
    update: XOR<PasswordUpdateWithoutRotationPolicyInput, PasswordUncheckedUpdateWithoutRotationPolicyInput>
    create: XOR<PasswordCreateWithoutRotationPolicyInput, PasswordUncheckedCreateWithoutRotationPolicyInput>
  }

  export type PasswordUpdateWithWhereUniqueWithoutRotationPolicyInput = {
    where: PasswordWhereUniqueInput
    data: XOR<PasswordUpdateWithoutRotationPolicyInput, PasswordUncheckedUpdateWithoutRotationPolicyInput>
  }

  export type PasswordUpdateManyWithWhereWithoutRotationPolicyInput = {
    where: PasswordScalarWhereInput
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyWithoutRotationPolicyInput>
  }

  export type PasswordRotationUpsertWithWhereUniqueWithoutPolicyInput = {
    where: PasswordRotationWhereUniqueInput
    update: XOR<PasswordRotationUpdateWithoutPolicyInput, PasswordRotationUncheckedUpdateWithoutPolicyInput>
    create: XOR<PasswordRotationCreateWithoutPolicyInput, PasswordRotationUncheckedCreateWithoutPolicyInput>
  }

  export type PasswordRotationUpdateWithWhereUniqueWithoutPolicyInput = {
    where: PasswordRotationWhereUniqueInput
    data: XOR<PasswordRotationUpdateWithoutPolicyInput, PasswordRotationUncheckedUpdateWithoutPolicyInput>
  }

  export type PasswordRotationUpdateManyWithWhereWithoutPolicyInput = {
    where: PasswordRotationScalarWhereInput
    data: XOR<PasswordRotationUpdateManyMutationInput, PasswordRotationUncheckedUpdateManyWithoutPolicyInput>
  }

  export type PasswordCreateWithoutRotationsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutRotationsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutRotationsInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
  }

  export type PasswordRotationPolicyCreateWithoutRotationsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutRotationPoliciesInput
    passwords?: PasswordCreateNestedManyWithoutRotationPolicyInput
  }

  export type PasswordRotationPolicyUncheckedCreateWithoutRotationsInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutRotationPolicyInput
  }

  export type PasswordRotationPolicyCreateOrConnectWithoutRotationsInput = {
    where: PasswordRotationPolicyWhereUniqueInput
    create: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
  }

  export type UserCreateWithoutPasswordRotationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordRotationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordRotationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
  }

  export type PasswordUpsertWithoutRotationsInput = {
    update: XOR<PasswordUpdateWithoutRotationsInput, PasswordUncheckedUpdateWithoutRotationsInput>
    create: XOR<PasswordCreateWithoutRotationsInput, PasswordUncheckedCreateWithoutRotationsInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutRotationsInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutRotationsInput, PasswordUncheckedUpdateWithoutRotationsInput>
  }

  export type PasswordUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordRotationPolicyUpsertWithoutRotationsInput = {
    update: XOR<PasswordRotationPolicyUpdateWithoutRotationsInput, PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput>
    create: XOR<PasswordRotationPolicyCreateWithoutRotationsInput, PasswordRotationPolicyUncheckedCreateWithoutRotationsInput>
    where?: PasswordRotationPolicyWhereInput
  }

  export type PasswordRotationPolicyUpdateToOneWithWhereWithoutRotationsInput = {
    where?: PasswordRotationPolicyWhereInput
    data: XOR<PasswordRotationPolicyUpdateWithoutRotationsInput, PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput>
  }

  export type PasswordRotationPolicyUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutRotationPoliciesNestedInput
    passwords?: PasswordUpdateManyWithoutRotationPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateWithoutRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput
  }

  export type UserUpsertWithoutPasswordRotationsInput = {
    update: XOR<UserUpdateWithoutPasswordRotationsInput, UserUncheckedUpdateWithoutPasswordRotationsInput>
    create: XOR<UserCreateWithoutPasswordRotationsInput, UserUncheckedCreateWithoutPasswordRotationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordRotationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordRotationsInput, UserUncheckedUpdateWithoutPasswordRotationsInput>
  }

  export type UserUpdateWithoutPasswordRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordRotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FolderCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FolderCreateNestedOneWithoutChildrenInput
    passwords?: PasswordCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passwords?: PasswordUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutChildrenInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
  }

  export type FolderCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderCreateNestedManyWithoutParentInput
    passwords?: PasswordCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    passwords?: PasswordUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutParentInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderCreateManyParentInputEnvelope = {
    data: FolderCreateManyParentInput | FolderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PasswordCreateWithoutFolderInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutFolderInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput>
  }

  export type PasswordCreateManyFolderInputEnvelope = {
    data: PasswordCreateManyFolderInput | PasswordCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type FolderUpsertWithoutChildrenInput = {
    update: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    passwords?: PasswordUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUpsertWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
  }

  export type FolderUpdateManyWithWhereWithoutParentInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutParentInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    icon?: StringNullableFilter<"Folder"> | string | null
    color?: StringNullableFilter<"Folder"> | string | null
    parentId?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
  }

  export type PasswordUpsertWithWhereUniqueWithoutFolderInput = {
    where: PasswordWhereUniqueInput
    update: XOR<PasswordUpdateWithoutFolderInput, PasswordUncheckedUpdateWithoutFolderInput>
    create: XOR<PasswordCreateWithoutFolderInput, PasswordUncheckedCreateWithoutFolderInput>
  }

  export type PasswordUpdateWithWhereUniqueWithoutFolderInput = {
    where: PasswordWhereUniqueInput
    data: XOR<PasswordUpdateWithoutFolderInput, PasswordUncheckedUpdateWithoutFolderInput>
  }

  export type PasswordUpdateManyWithWhereWithoutFolderInput = {
    where: PasswordScalarWhereInput
    data: XOR<PasswordUpdateManyMutationInput, PasswordUncheckedUpdateManyWithoutFolderInput>
  }

  export type PasswordCreateWithoutSharedWithInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    tags?: PasswordTagCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutSharedWithInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    tags?: PasswordTagUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutSharedWithInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
  }

  export type UserCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedPasswordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
  }

  export type TeamCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSharedPasswordsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSharedPasswordsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
  }

  export type PasswordUpsertWithoutSharedWithInput = {
    update: XOR<PasswordUpdateWithoutSharedWithInput, PasswordUncheckedUpdateWithoutSharedWithInput>
    create: XOR<PasswordCreateWithoutSharedWithInput, PasswordUncheckedCreateWithoutSharedWithInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutSharedWithInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutSharedWithInput, PasswordUncheckedUpdateWithoutSharedWithInput>
  }

  export type PasswordUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type UserUpsertWithoutSharedPasswordsInput = {
    update: XOR<UserUpdateWithoutSharedPasswordsInput, UserUncheckedUpdateWithoutSharedPasswordsInput>
    create: XOR<UserCreateWithoutSharedPasswordsInput, UserUncheckedCreateWithoutSharedPasswordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedPasswordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedPasswordsInput, UserUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type UserUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutSharedPasswordsInput = {
    update: XOR<TeamUpdateWithoutSharedPasswordsInput, TeamUncheckedUpdateWithoutSharedPasswordsInput>
    create: XOR<TeamCreateWithoutSharedPasswordsInput, TeamUncheckedCreateWithoutSharedPasswordsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSharedPasswordsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSharedPasswordsInput, TeamUncheckedUpdateWithoutSharedPasswordsInput>
  }

  export type TeamUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSharedPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PasswordShareCreateWithoutTeamInput = {
    id?: string
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
    password: PasswordCreateNestedOneWithoutSharedWithInput
    user?: UserCreateNestedOneWithoutSharedPasswordsInput
  }

  export type PasswordShareUncheckedCreateWithoutTeamInput = {
    id?: string
    passwordId: string
    userId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordShareCreateOrConnectWithoutTeamInput = {
    where: PasswordShareWhereUniqueInput
    create: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput>
  }

  export type PasswordShareCreateManyTeamInputEnvelope = {
    data: PasswordShareCreateManyTeamInput | PasswordShareCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type PasswordShareUpsertWithWhereUniqueWithoutTeamInput = {
    where: PasswordShareWhereUniqueInput
    update: XOR<PasswordShareUpdateWithoutTeamInput, PasswordShareUncheckedUpdateWithoutTeamInput>
    create: XOR<PasswordShareCreateWithoutTeamInput, PasswordShareUncheckedCreateWithoutTeamInput>
  }

  export type PasswordShareUpdateWithWhereUniqueWithoutTeamInput = {
    where: PasswordShareWhereUniqueInput
    data: XOR<PasswordShareUpdateWithoutTeamInput, PasswordShareUncheckedUpdateWithoutTeamInput>
  }

  export type PasswordShareUpdateManyWithWhereWithoutTeamInput = {
    where: PasswordShareScalarWhereInput
    data: XOR<PasswordShareUpdateManyMutationInput, PasswordShareUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedPasswords?: PasswordShareCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedPasswords?: PasswordShareUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PasswordTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    password: PasswordCreateNestedOneWithoutTagsInput
  }

  export type PasswordTagUncheckedCreateWithoutTagInput = {
    id?: string
    passwordId: string
    createdAt?: Date | string
  }

  export type PasswordTagCreateOrConnectWithoutTagInput = {
    where: PasswordTagWhereUniqueInput
    create: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput>
  }

  export type PasswordTagCreateManyTagInputEnvelope = {
    data: PasswordTagCreateManyTagInput | PasswordTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type PasswordTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PasswordTagWhereUniqueInput
    update: XOR<PasswordTagUpdateWithoutTagInput, PasswordTagUncheckedUpdateWithoutTagInput>
    create: XOR<PasswordTagCreateWithoutTagInput, PasswordTagUncheckedCreateWithoutTagInput>
  }

  export type PasswordTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PasswordTagWhereUniqueInput
    data: XOR<PasswordTagUpdateWithoutTagInput, PasswordTagUncheckedUpdateWithoutTagInput>
  }

  export type PasswordTagUpdateManyWithWhereWithoutTagInput = {
    where: PasswordTagScalarWhereInput
    data: XOR<PasswordTagUpdateManyMutationInput, PasswordTagUncheckedUpdateManyWithoutTagInput>
  }

  export type PasswordCreateWithoutTagsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedPasswordsInput
    folder?: FolderCreateNestedOneWithoutPasswordsInput
    sharedWith?: PasswordShareCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationCreateNestedManyWithoutPasswordInput
    rotationPolicy?: PasswordRotationPolicyCreateNestedOneWithoutPasswordsInput
  }

  export type PasswordUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
    sharedWith?: PasswordShareUncheckedCreateNestedManyWithoutPasswordInput
    history?: PasswordHistoryUncheckedCreateNestedManyWithoutPasswordEntryInput
    breaches?: PasswordBreachUncheckedCreateNestedManyWithoutPasswordInput
    rotations?: PasswordRotationUncheckedCreateNestedManyWithoutPasswordInput
  }

  export type PasswordCreateOrConnectWithoutTagsInput = {
    where: PasswordWhereUniqueInput
    create: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPasswordsInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type TagUncheckedCreateWithoutPasswordsInput = {
    id?: string
    name: string
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type TagCreateOrConnectWithoutPasswordsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
  }

  export type PasswordUpsertWithoutTagsInput = {
    update: XOR<PasswordUpdateWithoutTagsInput, PasswordUncheckedUpdateWithoutTagsInput>
    create: XOR<PasswordCreateWithoutTagsInput, PasswordUncheckedCreateWithoutTagsInput>
    where?: PasswordWhereInput
  }

  export type PasswordUpdateToOneWithWhereWithoutTagsInput = {
    where?: PasswordWhereInput
    data: XOR<PasswordUpdateWithoutTagsInput, PasswordUncheckedUpdateWithoutTagsInput>
  }

  export type PasswordUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type TagUpsertWithoutPasswordsInput = {
    update: XOR<TagUpdateWithoutPasswordsInput, TagUncheckedUpdateWithoutPasswordsInput>
    create: XOR<TagCreateWithoutPasswordsInput, TagUncheckedCreateWithoutPasswordsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPasswordsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPasswordsInput, TagUncheckedUpdateWithoutPasswordsInput>
  }

  export type TagUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutPasswordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedRolesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedRolesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedRolesInput = {
    update: XOR<UserUpdateWithoutCreatedRolesInput, UserUncheckedUpdateWithoutCreatedRolesInput>
    create: XOR<UserCreateWithoutCreatedRolesInput, UserUncheckedCreateWithoutCreatedRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRolesInput, UserUncheckedUpdateWithoutCreatedRolesInput>
  }

  export type UserUpdateWithoutCreatedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedRolesInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMfaCredentialsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMfaCredentialsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMfaCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
  }

  export type UserUpsertWithoutMfaCredentialsInput = {
    update: XOR<UserUpdateWithoutMfaCredentialsInput, UserUncheckedUpdateWithoutMfaCredentialsInput>
    create: XOR<UserCreateWithoutMfaCredentialsInput, UserUncheckedCreateWithoutMfaCredentialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMfaCredentialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMfaCredentialsInput, UserUncheckedUpdateWithoutMfaCredentialsInput>
  }

  export type UserUpdateWithoutMfaCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMfaCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRecoveryCodesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecoveryCodesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecoveryCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
  }

  export type UserUpsertWithoutRecoveryCodesInput = {
    update: XOR<UserUpdateWithoutRecoveryCodesInput, UserUncheckedUpdateWithoutRecoveryCodesInput>
    create: XOR<UserCreateWithoutRecoveryCodesInput, UserUncheckedCreateWithoutRecoveryCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecoveryCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecoveryCodesInput, UserUncheckedUpdateWithoutRecoveryCodesInput>
  }

  export type UserUpdateWithoutRecoveryCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecoveryCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSavedSearchesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedSearchesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedSearchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
  }

  export type UserUpsertWithoutSavedSearchesInput = {
    update: XOR<UserUpdateWithoutSavedSearchesInput, UserUncheckedUpdateWithoutSavedSearchesInput>
    create: XOR<UserCreateWithoutSavedSearchesInput, UserUncheckedCreateWithoutSavedSearchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedSearchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedSearchesInput, UserUncheckedUpdateWithoutSavedSearchesInput>
  }

  export type UserUpdateWithoutSavedSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedSearchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSearchHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSearchHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSearchHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
  }

  export type UserUpsertWithoutSearchHistoryInput = {
    update: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordTemplatesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordTemplatesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
  }

  export type CompanyCreateWithoutTemplatesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTemplatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
  }

  export type UserUpsertWithoutPasswordTemplatesInput = {
    update: XOR<UserUpdateWithoutPasswordTemplatesInput, UserUncheckedUpdateWithoutPasswordTemplatesInput>
    create: XOR<UserCreateWithoutPasswordTemplatesInput, UserUncheckedCreateWithoutPasswordTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordTemplatesInput, UserUncheckedUpdateWithoutPasswordTemplatesInput>
  }

  export type UserUpdateWithoutPasswordTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutTemplatesInput = {
    update: XOR<CompanyUpdateWithoutTemplatesInput, CompanyUncheckedUpdateWithoutTemplatesInput>
    create: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTemplatesInput, CompanyUncheckedUpdateWithoutTemplatesInput>
  }

  export type CompanyUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutEmailVerificationTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailVerificationTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailVerificationTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
  }

  export type UserUpsertWithoutEmailVerificationTokensInput = {
    update: XOR<UserUpdateWithoutEmailVerificationTokensInput, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
    create: XOR<UserCreateWithoutEmailVerificationTokensInput, UserUncheckedCreateWithoutEmailVerificationTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailVerificationTokensInput, UserUncheckedUpdateWithoutEmailVerificationTokensInput>
  }

  export type UserUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    securityQuestions?: SecurityQuestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSecurityQuestionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    ownedPasswords?: PasswordCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateCreateNestedManyWithoutOwnerInput
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecurityQuestionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
    ownedPasswords?: PasswordUncheckedCreateNestedManyWithoutOwnerInput
    sharedPasswords?: PasswordShareUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    mfaCredentials?: MfaCredentialUncheckedCreateNestedManyWithoutUserInput
    recoveryCodes?: RecoveryCodeUncheckedCreateNestedManyWithoutUserInput
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutChangedByUserInput
    passwordBreachesChecked?: PasswordBreachUncheckedCreateNestedManyWithoutCheckedByUserInput
    passwordBreachesResolved?: PasswordBreachUncheckedCreateNestedManyWithoutResolvedByUserInput
    rotationPolicies?: PasswordRotationPolicyUncheckedCreateNestedManyWithoutOwnerInput
    passwordRotations?: PasswordRotationUncheckedCreateNestedManyWithoutRotatedByUserInput
    savedSearches?: SavedSearchUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordTemplates?: PasswordTemplateUncheckedCreateNestedManyWithoutOwnerInput
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    createdRoles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecurityQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
  }

  export type UserUpsertWithoutSecurityQuestionsInput = {
    update: XOR<UserUpdateWithoutSecurityQuestionsInput, UserUncheckedUpdateWithoutSecurityQuestionsInput>
    create: XOR<UserCreateWithoutSecurityQuestionsInput, UserUncheckedCreateWithoutSecurityQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityQuestionsInput, UserUncheckedUpdateWithoutSecurityQuestionsInput>
  }

  export type UserUpdateWithoutSecurityQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdById?: string | null
  }

  export type PasswordTemplateCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    ownerId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordTemplateUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutPasswordTemplatesNestedInput
  }

  export type PasswordTemplateUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordCreateManyOwnerInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
  }

  export type PasswordShareCreateManyUserInput = {
    id?: string
    passwordId: string
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: $Enums.AuditStatus
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    deviceName?: string | null
    deviceType?: string | null
    isTrusted?: boolean
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type MfaCredentialCreateManyUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter?: bigint | number
    deviceType?: string | null
    backedUp?: boolean
    transports?: string | null
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type RecoveryCodeCreateManyUserInput = {
    id?: string
    codeHash: string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateManyChangedByUserInput = {
    id?: string
    passwordId: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordBreachCreateManyCheckedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordBreachCreateManyResolvedByUserInput = {
    id?: string
    passwordId: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
  }

  export type PasswordRotationPolicyCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    rotationDays: number
    reminderDays: number
    autoRotate?: boolean
    requireApproval?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordRotationCreateManyRotatedByUserInput = {
    id?: string
    passwordId: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type SavedSearchCreateManyUserInput = {
    id?: string
    name: string
    query?: string | null
    folderIds?: SavedSearchCreatefolderIdsInput | string[]
    tagIds?: SavedSearchCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SavedSearchCreatesearchFieldsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SearchHistoryCreateManyUserInput = {
    id?: string
    query?: string | null
    folderIds?: SearchHistoryCreatefolderIdsInput | string[]
    tagIds?: SearchHistoryCreatetagIdsInput | string[]
    filter?: string | null
    searchFields?: SearchHistoryCreatesearchFieldsInput | string[]
    resultCount?: number | null
    createdAt?: Date | string
  }

  export type PasswordTemplateCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    service?: string | null
    icon?: string | null
    category?: string | null
    isSystem?: boolean
    isPublic?: boolean
    companyId?: string | null
    defaultFields: JsonNullValueInput | InputJsonValue
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    name: string
    email: string
    emailVerified?: Date | string | null
    recoveryEmail?: string | null
    recoveryEmailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    phoneNumber?: string | null
    bio?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: string
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaMethod?: $Enums.MfaMethod | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type RoleCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailVerificationTokenCreateManyUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    email: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SecurityQuestionCreateManyUserInput = {
    id?: string
    question: string
    answerHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordShareUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutSharedWithNestedInput
    team?: TeamUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isTrusted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MfaCredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MfaCredentialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: BigIntFieldUpdateOperationsInput | bigint | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecoveryCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeHash?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUpdateWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordEntry?: PasswordUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type PasswordHistoryUncheckedUpdateWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordBreachUpdateWithoutCheckedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutBreachesNestedInput
    resolvedByUser?: UserUpdateOneWithoutPasswordBreachesResolvedNestedInput
  }

  export type PasswordBreachUncheckedUpdateWithoutCheckedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachUncheckedUpdateManyWithoutCheckedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachUpdateWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutBreachesNestedInput
    checkedByUser?: UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput
  }

  export type PasswordBreachUncheckedUpdateWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordBreachUncheckedUpdateManyWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordRotationPolicyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwords?: PasswordUncheckedUpdateManyWithoutRotationPolicyNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rotationDays?: IntFieldUpdateOperationsInput | number
    reminderDays?: IntFieldUpdateOperationsInput | number
    autoRotate?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationUpdateWithoutRotatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    password?: PasswordUpdateOneRequiredWithoutRotationsNestedInput
    policy?: PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateWithoutRotatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyWithoutRotatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedSearchUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedSearchUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SavedSearchUpdatefolderIdsInput | string[]
    tagIds?: SavedSearchUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SavedSearchUpdatesearchFieldsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    folderIds?: SearchHistoryUpdatefolderIdsInput | string[]
    tagIds?: SearchHistoryUpdatetagIdsInput | string[]
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    searchFields?: SearchHistoryUpdatesearchFieldsInput | string[]
    resultCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutTemplatesNestedInput
  }

  export type PasswordTemplateUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTemplateUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultFields?: JsonNullValueInput | InputJsonValue
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    ownedPasswords?: PasswordUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedPasswords?: PasswordUncheckedUpdateManyWithoutOwnerNestedInput
    sharedPasswords?: PasswordShareUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    mfaCredentials?: MfaCredentialUncheckedUpdateManyWithoutUserNestedInput
    recoveryCodes?: RecoveryCodeUncheckedUpdateManyWithoutUserNestedInput
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutChangedByUserNestedInput
    passwordBreachesChecked?: PasswordBreachUncheckedUpdateManyWithoutCheckedByUserNestedInput
    passwordBreachesResolved?: PasswordBreachUncheckedUpdateManyWithoutResolvedByUserNestedInput
    rotationPolicies?: PasswordRotationPolicyUncheckedUpdateManyWithoutOwnerNestedInput
    passwordRotations?: PasswordRotationUncheckedUpdateManyWithoutRotatedByUserNestedInput
    savedSearches?: SavedSearchUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordTemplates?: PasswordTemplateUncheckedUpdateManyWithoutOwnerNestedInput
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    createdRoles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    securityQuestions?: SecurityQuestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaMethod?: NullableEnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityQuestionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answerHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordShareCreateManyPasswordInput = {
    id?: string
    userId?: string | null
    teamId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PasswordTagCreateManyPasswordInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateManyPasswordEntryInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength: $Enums.PasswordStrength
    hasTotp: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    changedBy: string
    changeType?: string
    createdAt?: Date | string
  }

  export type PasswordBreachCreateManyPasswordInput = {
    id?: string
    isBreached: boolean
    breachCount?: number
    hashPrefix: string
    checkedAt?: Date | string
    checkedBy: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type PasswordRotationCreateManyPasswordInput = {
    id?: string
    policyId?: string | null
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordShareUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutSharedPasswordsNestedInput
    team?: TeamUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordTagUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutPasswordsNestedInput
  }

  export type PasswordTagUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUpdateWithoutPasswordEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUser?: UserUpdateOneRequiredWithoutPasswordHistoryNestedInput
  }

  export type PasswordHistoryUncheckedUpdateWithoutPasswordEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordBreachUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkedByUser?: UserUpdateOneRequiredWithoutPasswordBreachesCheckedNestedInput
    resolvedByUser?: UserUpdateOneWithoutPasswordBreachesResolvedNestedInput
  }

  export type PasswordBreachUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordBreachUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    isBreached?: BoolFieldUpdateOperationsInput | boolean
    breachCount?: IntFieldUpdateOperationsInput | number
    hashPrefix?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkedBy?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    policy?: PasswordRotationPolicyUpdateOneWithoutRotationsNestedInput
    rotatedByUser?: UserUpdateOneRequiredWithoutPasswordRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPasswordInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: NullableStringFieldUpdateOperationsInput | string | null
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordCreateManyRotationPolicyInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    folderId?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordRotationCreateManyPolicyInput = {
    id?: string
    passwordId: string
    rotationType?: string
    oldPassword?: string | null
    newPassword: string
    rotatedAt?: Date | string
    rotatedBy: string
    scheduledFor?: Date | string | null
    completedAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type PasswordUpdateWithoutRotationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    folder?: FolderUpdateOneWithoutPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateWithoutRotationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateManyWithoutRotationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordRotationUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    password?: PasswordUpdateOneRequiredWithoutRotationsNestedInput
    rotatedByUser?: UserUpdateOneRequiredWithoutPasswordRotationsNestedInput
  }

  export type PasswordRotationUncheckedUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordRotationUncheckedUpdateManyWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    rotationType?: StringFieldUpdateOperationsInput | string
    oldPassword?: NullableStringFieldUpdateOperationsInput | string | null
    newPassword?: StringFieldUpdateOperationsInput | string
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedBy?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FolderCreateManyParentInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordCreateManyFolderInput = {
    id?: string
    name: string
    username: string
    password: string
    url?: string | null
    notes?: string | null
    strength?: $Enums.PasswordStrength
    hasTotp?: boolean
    totpSecret?: string | null
    expiresAt?: Date | string | null
    isFavorite?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rotationPolicyId?: string | null
  }

  export type FolderUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUpdateManyWithoutParentNestedInput
    passwords?: PasswordUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    passwords?: PasswordUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedPasswordsNestedInput
    sharedWith?: PasswordShareUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUpdateManyWithoutPasswordNestedInput
    rotationPolicy?: PasswordRotationPolicyUpdateOneWithoutPasswordsNestedInput
  }

  export type PasswordUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedWith?: PasswordShareUncheckedUpdateManyWithoutPasswordNestedInput
    tags?: PasswordTagUncheckedUpdateManyWithoutPasswordNestedInput
    history?: PasswordHistoryUncheckedUpdateManyWithoutPasswordEntryNestedInput
    breaches?: PasswordBreachUncheckedUpdateManyWithoutPasswordNestedInput
    rotations?: PasswordRotationUncheckedUpdateManyWithoutPasswordNestedInput
  }

  export type PasswordUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: EnumPasswordStrengthFieldUpdateOperationsInput | $Enums.PasswordStrength
    hasTotp?: BoolFieldUpdateOperationsInput | boolean
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type PasswordShareCreateManyTeamInput = {
    id?: string
    passwordId: string
    userId?: string | null
    permission?: $Enums.SharePermission
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordShareUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: PasswordUpdateOneRequiredWithoutSharedWithNestedInput
    user?: UserUpdateOneWithoutSharedPasswordsNestedInput
  }

  export type PasswordShareUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordShareUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumSharePermissionFieldUpdateOperationsInput | $Enums.SharePermission
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordTagCreateManyTagInput = {
    id?: string
    passwordId: string
    createdAt?: Date | string
  }

  export type PasswordTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: PasswordUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PasswordTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}