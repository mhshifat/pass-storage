// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider   = "prisma-client-js"
  output     = "../src/app/generated"
  engineType = "binary"
}

datasource db {
  provider = "postgresql"
}

model Company {
  id        String   @id @default(cuid())
  name      String
  subdomain String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users                  User[]
  templates              PasswordTemplate[]
  ipWhitelists           IpWhitelist[]
  geographicRestrictions GeographicRestriction[]
  threatEvents           ThreatEvent[]
  rateLimits             RateLimit[]

  @@index([subdomain])
}

model User {
  id                    String     @id @default(cuid())
  name                  String
  email                 String
  emailVerified         DateTime?
  recoveryEmail         String? // Secondary email for account recovery
  recoveryEmailVerified DateTime?
  image                 String?
  password              String? // Optional for OAuth users
  phoneNumber           String? // For SMS MFA
  bio                   String? // User bio/description
  preferences           Json? // User preferences (theme, notifications, etc.)
  role                  String     @default("USER")
  isActive              Boolean    @default(true)
  mfaEnabled            Boolean    @default(false)
  mfaSecret             String? // For TOTP MFA
  mfaMethod             MfaMethod? // Preferred MFA method
  companyId             String?
  createdAt             DateTime   @default(now())
  updatedAt             DateTime   @updatedAt
  lastLoginAt           DateTime?

  // Relations
  company                  Company?                 @relation(fields: [companyId], references: [id], onDelete: SetNull)
  ownedPasswords           Password[]               @relation("PasswordOwner")
  sharedPasswords          PasswordShare[]
  teamMemberships          TeamMember[]
  auditLogs                AuditLog[]
  threatEvents             ThreatEvent[]
  sessions                 Session[]
  accounts                 Account[]
  mfaCredentials           MfaCredential[]
  recoveryCodes            RecoveryCode[]
  passwordHistory          PasswordHistory[]        @relation("PasswordHistoryChangedBy")
  passwordBreachesChecked  PasswordBreach[]         @relation("PasswordBreachCheckedBy")
  passwordBreachesResolved PasswordBreach[]         @relation("PasswordBreachResolvedBy")
  rotationPolicies         PasswordRotationPolicy[] @relation("PasswordRotationPolicyOwner")
  passwordRotations        PasswordRotation[]       @relation("PasswordRotationRotatedBy")
  savedSearches            SavedSearch[]            @relation("SavedSearches")
  searchHistory            SearchHistory[]          @relation("SearchHistory")
  passwordTemplates        PasswordTemplate[]       @relation("PasswordTemplateOwner")

  createdById  String?
  createdBy    User?   @relation("UserCreatedBy", fields: [createdById], references: [id])
  createdUsers User[]  @relation("UserCreatedBy")
  createdRoles Role[]  @relation("RoleCreatedBy")

  emailVerificationTokens       EmailVerificationToken[]
  passwordResetTokens           PasswordResetToken[]
  securityQuestions             SecurityQuestion[]
  ipWhitelists                  IpWhitelist[]
  geographicRestrictions        GeographicRestriction[]
  createdIpWhitelists           IpWhitelist[]            @relation("IpWhitelistCreator")
  createdGeographicRestrictions GeographicRestriction[]  @relation("GeographicRestrictionCreator")

  @@index([email])
  @@index([phoneNumber])
  @@index([companyId])
  @@index([recoveryEmail])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id                String   @id @default(cuid())
  sessionToken      String   @unique
  userId            String
  expires           DateTime
  ipAddress         String?
  userAgent         String?
  deviceName        String? // Device name/identifier
  deviceType        String? // mobile, desktop, tablet
  deviceFingerprint String? // Unique device fingerprint for identification
  isTrusted         Boolean  @default(false) // Trusted device flag
  requireMfa        Boolean  @default(false) // Device-specific MFA requirement
  lastActiveAt      DateTime @default(now()) // Last activity timestamp
  createdAt         DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isTrusted])
  @@index([userId, deviceFingerprint])
  @@index([expires])
}

model Password {
  id         String           @id @default(cuid())
  name       String
  username   String
  password   String // Encrypted
  url        String?
  notes      String?
  folderId   String?
  strength   PasswordStrength @default(MEDIUM)
  hasTotp    Boolean          @default(false)
  totpSecret String? // Encrypted
  expiresAt  DateTime?
  isFavorite Boolean          @default(false)
  ownerId    String
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  // Relations
  owner            User               @relation("PasswordOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  folder           Folder?            @relation(fields: [folderId], references: [id], onDelete: SetNull)
  sharedWith       PasswordShare[]
  tags             PasswordTag[]
  history          PasswordHistory[]
  breaches         PasswordBreach[]
  rotationPolicyId String?
  rotations        PasswordRotation[]

  // Relations
  rotationPolicy PasswordRotationPolicy? @relation(fields: [rotationPolicyId], references: [id], onDelete: SetNull)

  @@index([ownerId])
  @@index([folderId])
  @@index([rotationPolicyId])
  @@index([isFavorite])
}

model PasswordHistory {
  id         String           @id @default(cuid())
  passwordId String
  name       String
  username   String
  password   String // Encrypted
  url        String?
  notes      String?
  folderId   String?
  strength   PasswordStrength
  hasTotp    Boolean
  totpSecret String? // Encrypted
  expiresAt  DateTime?
  changedBy  String // User ID who made the change
  changeType String           @default("UPDATE") // CREATE, UPDATE, RESTORE
  createdAt  DateTime         @default(now())

  // Relations
  passwordEntry Password @relation(fields: [passwordId], references: [id], onDelete: Cascade)
  changedByUser User     @relation("PasswordHistoryChangedBy", fields: [changedBy], references: [id], onDelete: SetNull)

  @@index([passwordId])
  @@index([changedBy])
  @@index([createdAt])
}

model PasswordBreach {
  id          String    @id @default(cuid())
  passwordId  String
  isBreached  Boolean
  breachCount Int       @default(0)
  hashPrefix  String // First 5 chars of SHA-1 hash (k-anonymity)
  checkedAt   DateTime  @default(now())
  checkedBy   String // User ID who triggered the check
  resolved    Boolean   @default(false) // User marked as resolved
  resolvedAt  DateTime?
  resolvedBy  String? // User ID who resolved it

  // Relations
  password       Password @relation(fields: [passwordId], references: [id], onDelete: Cascade)
  checkedByUser  User     @relation("PasswordBreachCheckedBy", fields: [checkedBy], references: [id], onDelete: SetNull)
  resolvedByUser User?    @relation("PasswordBreachResolvedBy", fields: [resolvedBy], references: [id], onDelete: SetNull)

  @@index([passwordId])
  @@index([checkedBy])
  @@index([checkedAt])
  @@index([isBreached])
  @@index([resolved])
}

model PasswordRotationPolicy {
  id              String   @id @default(cuid())
  name            String
  description     String?
  rotationDays    Int // Days between rotations (e.g., 90 for 90 days)
  reminderDays    Int // Days before rotation to send reminder (e.g., 7 for 7 days before)
  autoRotate      Boolean  @default(false) // Automatically rotate password on schedule
  requireApproval Boolean  @default(false) // Require approval before auto-rotation
  isActive        Boolean  @default(true)
  ownerId         String // User who created the policy
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  owner     User               @relation("PasswordRotationPolicyOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  passwords Password[]
  rotations PasswordRotation[]

  @@index([ownerId])
  @@index([isActive])
}

model PasswordRotation {
  id           String    @id @default(cuid())
  passwordId   String
  policyId     String? // Optional: which policy triggered this rotation
  rotationType String    @default("MANUAL") // MANUAL, SCHEDULED, POLICY
  oldPassword  String? // Encrypted old password (optional, for history)
  newPassword  String // Encrypted new password
  rotatedAt    DateTime  @default(now())
  rotatedBy    String // User ID who performed the rotation
  scheduledFor DateTime? // When this rotation was scheduled for
  completedAt  DateTime? // When rotation was actually completed
  status       String    @default("COMPLETED") // COMPLETED, PENDING, FAILED, CANCELLED
  notes        String?

  // Relations
  password      Password                @relation(fields: [passwordId], references: [id], onDelete: Cascade)
  policy        PasswordRotationPolicy? @relation(fields: [policyId], references: [id], onDelete: SetNull)
  rotatedByUser User                    @relation("PasswordRotationRotatedBy", fields: [rotatedBy], references: [id], onDelete: SetNull)

  @@index([passwordId])
  @@index([policyId])
  @@index([rotatedBy])
  @@index([rotatedAt])
  @@index([status])
  @@index([scheduledFor])
}

model Folder {
  id          String   @id @default(cuid())
  name        String
  description String?
  icon        String?
  color       String?
  parentId    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  parent    Folder?    @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  Folder[]   @relation("FolderHierarchy")
  passwords Password[]

  @@index([parentId])
}

model PasswordShare {
  id         String          @id @default(cuid())
  passwordId String
  userId     String?
  teamId     String?
  permission SharePermission @default(READ)
  createdAt  DateTime        @default(now())
  expiresAt  DateTime?

  // Relations
  password Password @relation(fields: [passwordId], references: [id], onDelete: Cascade)
  user     User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  team     Team?    @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([passwordId])
  @@index([userId])
  @@index([teamId])
}

model Team {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  members         TeamMember[]
  sharedPasswords PasswordShare[]

  @@index([name])
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      TeamRole @default(MEMBER)
  createdAt DateTime @default(now())

  // Relations
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String?
  icon      String?
  createdAt DateTime @default(now())

  // Relations
  passwords PasswordTag[]
}

model PasswordTag {
  id         String   @id @default(cuid())
  passwordId String
  tagId      String
  createdAt  DateTime @default(now())

  // Relations
  password Password @relation(fields: [passwordId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([passwordId, tagId])
  @@index([passwordId])
  @@index([tagId])
}

model AuditLog {
  id         String      @id @default(cuid())
  userId     String?
  action     String
  resource   String
  resourceId String?
  details    Json?
  ipAddress  String?
  userAgent  String?
  status     AuditStatus @default(SUCCESS)
  createdAt  DateTime    @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  // Note: resourceId is a generic field that can reference any resource type (User, Password, Team, etc.)
  // It does not have a foreign key constraint because it's polymorphic

  @@index([userId])
  @@index([resourceId])
  @@index([createdAt])
}

model Settings {
  id        String   @id @default(cuid())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt

  @@index([key])
}

model ThreatEvent {
  id         String         @id @default(cuid())
  userId     String?
  companyId  String?
  threatType ThreatType
  severity   ThreatSeverity @default(MEDIUM)
  ipAddress  String?
  userAgent  String?
  details    Json?
  isResolved Boolean        @default(false)
  resolvedAt DateTime?
  resolvedBy String?
  createdAt  DateTime       @default(now())

  // Relations
  user    User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  company Company? @relation(fields: [companyId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([companyId])
  @@index([threatType])
  @@index([severity])
  @@index([isResolved])
  @@index([createdAt])
  @@index([ipAddress])
}

model RateLimit {
  id             String        @id @default(cuid())
  identifier     String // IP address or userId
  identifierType RateLimitType
  action         String // e.g., "LOGIN", "PASSWORD_RESET"
  count          Int           @default(1)
  windowStart    DateTime      @default(now())
  windowEnd      DateTime
  companyId      String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  company Company? @relation(fields: [companyId], references: [id], onDelete: SetNull)

  @@unique([identifier, identifierType, action, windowStart])
  @@index([identifier, identifierType, action])
  @@index([windowEnd])
  @@index([companyId])
}

enum ThreatType {
  BRUTE_FORCE
  RATE_LIMIT_EXCEEDED
  UNUSUAL_ACCESS_PATTERN
  SUSPICIOUS_LOCATION
  MULTIPLE_FAILED_LOGINS
  ANOMALY_DETECTED
}

enum ThreatSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum RateLimitType {
  IP
  USER
}

model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  isSystem    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  createdById String?
  createdBy   User?            @relation("RoleCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  permissions RolePermission[]

  @@index([name])
  @@index([createdById])
}

model Permission {
  id          String   @id @default(cuid())
  key         String   @unique
  name        String
  description String?
  category    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  rolePermissions RolePermission[]

  @@index([key])
  @@index([category])
}

model RolePermission {
  id           String   @id @default(cuid())
  roleId       String
  permissionId String
  createdAt    DateTime @default(now())

  // Relations
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

// Enums
enum UserRole {
  SUPER_ADMIN
  ADMIN
  MANAGER
  USER
  AUDITOR
}

enum TeamRole {
  MANAGER
  MEMBER
}

enum SharePermission {
  READ
  WRITE
  ADMIN
}

enum PasswordStrength {
  WEAK
  MEDIUM
  STRONG
}

enum AuditStatus {
  SUCCESS
  FAILED
  WARNING
  BLOCKED
}

enum MfaMethod {
  TOTP
  SMS
  EMAIL
  WEBAUTHN
}

model MfaCredential {
  id           String    @id @default(cuid())
  userId       String
  credentialId String    @unique // Base64URL encoded credential ID
  publicKey    String // Base64URL encoded public key
  counter      BigInt    @default(0)
  deviceType   String? // e.g., "singleDevice", "multiDevice"
  backedUp     Boolean   @default(false)
  transports   String? // JSON array of transport methods
  createdAt    DateTime  @default(now())
  lastUsedAt   DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([credentialId])
}

model RecoveryCode {
  id        String    @id @default(cuid())
  userId    String
  codeHash  String // Hashed recovery code
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([codeHash])
}

model SavedSearch {
  id           String    @id @default(cuid())
  userId       String
  name         String
  query        String? // Search query text
  folderIds    String[]  @default([]) // Array of folder IDs for hierarchy search
  tagIds       String[]  @default([]) // Array of tag IDs
  filter       String? // weak, expiring, favorites
  searchFields String[]  @default([]) // Fields to search in: name, username, url, notes
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  lastUsedAt   DateTime?

  // Relations
  user User @relation("SavedSearches", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, createdAt])
}

model SearchHistory {
  id           String   @id @default(cuid())
  userId       String
  query        String? // Search query text
  folderIds    String[] @default([]) // Array of folder IDs
  tagIds       String[] @default([]) // Array of tag IDs
  filter       String? // weak, expiring, favorites
  searchFields String[] @default([]) // Fields searched
  resultCount  Int? // Number of results found
  createdAt    DateTime @default(now())

  // Relations
  user User @relation("SearchHistory", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, createdAt])
  @@index([createdAt])
}

model PasswordTemplate {
  id            String   @id @default(cuid())
  name          String
  description   String?
  service       String? // Service name (e.g., "AWS", "GitHub", "Gmail")
  icon          String? // Icon/emoji for the template
  category      String? // Category (e.g., "Cloud", "Social", "Banking")
  isSystem      Boolean  @default(false) // System templates vs user-created
  isPublic      Boolean  @default(false) // Public templates can be shared
  ownerId       String? // null for system templates, userId for user templates
  companyId     String? // For company-specific templates
  defaultFields Json // JSON object with default field values (name, username, url, notes, etc.)
  usageCount    Int      @default(0) // Track how many times template is used
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  owner   User?    @relation("PasswordTemplateOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  company Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([ownerId])
  @@index([companyId])
  @@index([isSystem])
  @@index([isPublic])
  @@index([category])
  @@index([service])
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  email     String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([email])
  @@index([expiresAt])
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  email     String
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([email])
  @@index([expiresAt])
  @@index([used])
}

model SecurityQuestion {
  id         String   @id @default(cuid())
  userId     String
  question   String
  answerHash String // Hashed answer
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model IpWhitelist {
  id          String   @id @default(cuid())
  userId      String? // null for company-wide whitelist
  companyId   String? // null for user-specific whitelist
  ipAddress   String // IP address or CIDR range (e.g., "192.168.1.1" or "192.168.1.0/24")
  description String? // Optional description
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String? // Who created this whitelist entry

  user    User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)
  creator User?    @relation("IpWhitelistCreator", fields: [createdById], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([companyId])
  @@index([ipAddress])
  @@index([isActive])
}

model GeographicRestriction {
  id          String   @id @default(cuid())
  userId      String? // null for company-wide restriction
  companyId   String? // null for user-specific restriction
  countryCode String // ISO 3166-1 alpha-2 country code (e.g., "US", "GB")
  action      String   @default("BLOCK") // BLOCK or ALLOW
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String? // Who created this restriction

  user    User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company? @relation(fields: [companyId], references: [id], onDelete: Cascade)
  creator User?    @relation("GeographicRestrictionCreator", fields: [createdById], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([companyId])
  @@index([countryCode])
  @@index([isActive])
}
